<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术博客</title>
  
  <subtitle>学习的点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://minminminzhang.github.io/"/>
  <updated>2019-01-13T10:32:37.213Z</updated>
  <id>https://minminminzhang.github.io/</id>
  
  <author>
    <name>张敏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux系统初步了解</title>
    <link href="https://minminminzhang.github.io/2019/cjqur6yra000b44nufmapdxlk/"/>
    <id>https://minminminzhang.github.io/2019/cjqur6yra000b44nufmapdxlk/</id>
    <published>2019-01-13T08:27:42.514Z</published>
    <updated>2019-01-13T10:32:37.213Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习了有关于linux操作系统的基础以及相关指令，接下来做一介绍。linux系统是“多任务，多用户”，即主机上可以同时允许多人上线来工作，并且资源的分配较为公平。这也将存在一个问题：关机问题。在Windows系统中，由于是单用户，所以即使计算机关机，对于别人也不会有影响。但在Linux系统中，由于每个程序都是在后台执行的，因此，在你看不到的屏幕背后其实可能有很多人同时在你的主机上面工作，例如浏览网页，传送信件等，如果直接按下电源开关来关机，则其他人的数据可能就此终端了。</p><p>1.Linux登陆纯文本界面</p><p>Linux默认的情况下会提供6个Terminal来让用户登录，切换的方式为使用【Ctrl】+【Alt】+【F1】~【F6】的组合按钮。</p><p>系统将【F1】~【F6】命名为tty1~tty6的操作界面环境。按下【Ctrl】+【Alt】+【F7】转换到图形界面桌面。</p><p>按下【Ctrl】+【Alt】+【F1】来到tty1的登陆界面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CentOS release 5.3 (Final)</span><br><span class="line">Kernel 2.6.18-128.el5 on an i686</span><br><span class="line"></span><br><span class="line">www login: vbird</span><br><span class="line">Password:</span><br><span class="line">[vbird@www~] $_</span><br></pre></td></tr></table></figure><p>(1).CentOS release 5.3 (Final)</p><p>显示Linux distribution的名称与版本</p><p>(2).Kernel 2.6.18-128.el5 on an i686</p><p>显示内核版本</p><p>(3).www login</p><p>主机名</p><p>(4).Password</p><p>密码，输入后不会显示</p><p>(5).[vbird@www~] $_</p><p>登陆后，显示的正确信息。最左边的vbird显示的是当前用户的账号，而@之后接的www则是主机名。最右边的~则指的是“当前所在的目录”，那个$是提示符。</p><p>这样就已登陆主机了。</p><p>2.基本命令操作</p><p>(1)显示日期与时间：date</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vbird@www~] $ date</span><br><span class="line">Sun Jan 13 17:34:52 CST 2019</span><br></pre></td></tr></table></figure><p>上面显示为：星期天，1月13日，时间为17:34:52，在2019年的CTS时区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[vbird@www~] $ date  +%Y/%m/%d</span><br><span class="line">2019/1/13</span><br><span class="line">[vbird@www~] $ date  +%H:%M</span><br><span class="line">17:34</span><br></pre></td></tr></table></figure><p>(2)显示日历的命令：cal</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[vbird@www~] $ cal</span><br><span class="line">January 2019</span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">      1  2  3  4  5</span><br><span class="line">6  7  8  9 10 11  12  </span><br><span class="line">13 14 15 16 17 18 19 </span><br><span class="line">20 21 22 23 24 25 26 </span><br><span class="line">27 28 29 30 31</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>[vbird@www~] $ cal [[month] year]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vbird@www~] $ cal 2019</span><br><span class="line">查询2019年所有日历</span><br></pre></td></tr></table></figure><p>基本的cal语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[vbird@www~] $ cal [[month] year]</span><br></pre></td></tr></table></figure><p>(3)计算器：bc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[vbird@www~] $ bc</span><br><span class="line">1+4+3    </span><br><span class="line">8</span><br><span class="line">10%3    </span><br><span class="line">1</span><br><span class="line">10/100 </span><br><span class="line">0</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><p>quit:离开计算器</p><p>在上文中10/100结果为0，因为bc默认输出整数，如果要输出全部小数，就要执行scale=number,number代表小数点后的位数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[vbird@www~] $ bc</span><br><span class="line">scale=3     </span><br><span class="line">1/3</span><br><span class="line">.333</span><br><span class="line">34/100</span><br><span class="line">0.340</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><p>(2)改变支持语言</p><p>①显示目前所支持的语言</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vbird@www~] $ echo   $LANG  </span><br><span class="line">zh_CN.UTF-8</span><br></pre></td></tr></table></figure><p>上面的意思是目前的语言(LANG)为zh_CN.UTF-8</p><p>②修改语言为英文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[vbird@www~] $ LANG=en__US</span><br><span class="line">[vbird@www~] $ echo   $LANG  </span><br><span class="line">en__US</span><br></pre></td></tr></table></figure><p>再次确认，支持语言由汉语改成英语</p><p>3.正确关机</p><p>若不正常关机，则可能造成文件系统的毁损。</p><p>在正常情况下，关机要注意下面几件事：</p><p>(1)查看系统的使用状态</p><p>如果要谁在线，执行命令”who”。查看网络的联机状态，执行命令”netstat -a”。查看后台执行的程序，用命令“ps-aux”。</p><p>(2)通知在线用户关机的时刻</p><p>用shutdown这个命令来实现</p><p>Linux，除了以tty7图形界面来登陆系统，无论以什么身份都能够关机外，只有root有权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # /sbin/shutdown [-t秒]      时间 [警告消息]</span><br><span class="line">参数：</span><br><span class="line">-t sec:-t后面加秒数，表示几秒后关机</span><br><span class="line">-k    :不是真的关机，只是发送警告消息出去</span><br><span class="line">-r    :在将系统的服务停掉之后就重启</span><br><span class="line">-h    :将系统的服务停掉之后，立即关机</span><br><span class="line">-n    :不经过init程序，直接以shutdown来关机</span><br><span class="line">-f    :关机并开机之后，强制略过fsck的磁盘检查</span><br><span class="line">-F    :系统重启之后，强制进行fsck的磁盘检查</span><br><span class="line">-c    :取消已经在进行的shutdown命令内容</span><br><span class="line">时间  ：一定要加入的参数，指定系统关机的时间。</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # shutdown -h now</span><br><span class="line">立刻关机</span><br><span class="line"></span><br><span class="line">[root@www ~] # shutdown -h 20：25</span><br><span class="line">系统在今天的20：25关机。如果在超过20：25执行此命令，则隔天的20：25关机。</span><br><span class="line"></span><br><span class="line">[root@www ~] # shutdown -h +10</span><br><span class="line">十分钟后关机</span><br><span class="line"></span><br><span class="line">[root@www ~] # shutdown -r now</span><br><span class="line">系统立刻重启</span><br><span class="line"></span><br><span class="line">[root@www ~] # shutdown -r +30 &apos;The system will reboot&apos;</span><br><span class="line">再过三十分钟系统重启，将后面消息显示给所有用户</span><br><span class="line"></span><br><span class="line">[root@www ~] # shutdown -k now &apos;The system will reboot&apos;</span><br><span class="line">仅发出警告信件的参数，系统并不会关机</span><br></pre></td></tr></table></figure><p>4.补充</p><p>(1)[Tab]键具有命令补全和文件补齐功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[vbird@www~] $ ca [Tab][Tab]</span><br><span class="line">执行这个命令以后，所有以ca开头的命令都被显示出来。</span><br><span class="line">[vbird@www~] $ ls -al ~/.bash[Tab][Tab]</span><br><span class="line">所有以.bash开头的文件名都会被显示出来</span><br><span class="line">[Tab]接在一串命令的第一个命令之后，则为“命令补全”</span><br><span class="line">[Tab]接在一串命令的第二个命令之后，则为“文件补齐”</span><br></pre></td></tr></table></figure><p>(2)[Ctrl]-c可以停止运行，让程序停下来。</p><p>(3)[Ctrl]-d代表键盘输入结束。</p><p>(4)man page</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vbird@www~] $ man date</span><br><span class="line">执行这个命令查询到关于date命令的使用方法</span><br></pre></td></tr></table></figure><p>(5) man -f  man</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[vbird@www~] $ man -f man</span><br><span class="line">执行这个命令后，输出的数据包括两部分。左部分是命令以及该命令代表的意义。右半部份是这个命令的简易说明。</span><br><span class="line">[vbird@www~] $ man -f </span><br><span class="line">执行这个命令后，只会找到命令以及该命令代表的意义</span><br></pre></td></tr></table></figure><p>(6) man -k  man</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[vbird@www~] $ man -k man</span><br><span class="line">只要有man的关键字都会列出来</span><br></pre></td></tr></table></figure><p>我们知道Linux中有很多的命令，但不用挨个去背。</p><p>一般遇到记不清楚的命令，可以这样查找：</p><p>首先：man+模糊命令，找相关的说明。然后：模糊命令+两次[Tab]键，查找以模糊命令开头的命令，查找到以后再去man查询命令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近学习了有关于linux操作系统的基础以及相关指令，接下来做一介绍。linux系统是“多任务，多用户”，即主机上可以同时允许多人上线来工作，并且资源的分配较为公平。这也将存在一个问题：关机问题。在Windows系统中，由于是单用户，所以即使计算机关机，对于别人也不会有影响
      
    
    </summary>
    
      <category term="linux系统应用命令 " scheme="https://minminminzhang.github.io/categories/linux%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="linux系统应用命令" scheme="https://minminminzhang.github.io/tags/linux%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>小顽童OA项目之邮件功能模块 </title>
    <link href="https://minminminzhang.github.io/2019/cjqur6ytm001a44nuhp6obafj/"/>
    <id>https://minminminzhang.github.io/2019/cjqur6ytm001a44nuhp6obafj/</id>
    <published>2019-01-05T07:40:54.611Z</published>
    <updated>2019-01-05T08:13:02.538Z</updated>
    
    <content type="html"><![CDATA[<p>我开发的第一部分是实现发送邮件的业务：实现简单邮件的发送，以及带图片，带附件的邮件发送。将每次发送邮件的记录进行保存，并且可以通过id，或者其他字段进行查询，修改，删除。</p><p>首先，第一步是实现邮件发送业务并保存记录：</p><p>在pom.xml中写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在application.properties进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.host=smtp.163.com</span><br><span class="line">spring.mail.username=minzhang1534781927@163.com</span><br><span class="line">spring.mail.password=468975520zm</span><br><span class="line">spring.mail.default-encoding=UTF-8</span><br><span class="line">spring.mail.port=25</span><br><span class="line">spring.mail.properties.mail.smtp.auth=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.enable=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.required=true</span><br></pre></td></tr></table></figure><p>在Mapper层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package org.ppcirgo.oa.mapper;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.annotations.*;</span><br><span class="line">import org.ppcirgo.oa.beans.model.MailModel;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line">@Repository</span><br><span class="line">public interface MailMapper &#123;</span><br><span class="line"></span><br><span class="line">    //保存发邮件记录</span><br><span class="line">    @Insert(value=&quot;insert into emailRecord (sender,receiver,time,subject,status,content,password)  values(#&#123;sender&#125;,#&#123;receiver&#125;,#&#123;time&#125;,#&#123;subject&#125;,#&#123;status&#125;,#&#123;content&#125;,#&#123;password&#125;)&quot;)</span><br><span class="line">    int saveEmailRecord(MailModel mailModel);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在Service层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package org.ppcirgo.oa.service;</span><br><span class="line">import org.ppcirgo.oa.beans.model.MailModel;</span><br><span class="line"></span><br><span class="line">public interface MailService &#123;</span><br><span class="line"></span><br><span class="line">  //发送简单邮件</span><br><span class="line">  public MailModel sendSimpleMail(String from, String to, String subject, String content);</span><br><span class="line">  </span><br><span class="line">//发送带图片的邮件</span><br><span class="line">  public MailModel sendInilneMail(String from,String to, String subject, String content,String resPath,String resId);</span><br><span class="line">  </span><br><span class="line">  //发送带附件的邮件</span><br><span class="line">  public MailModel sendAttachmentMail(String from,String to,String subject,String content,String filePath);</span><br><span class="line">  </span><br><span class="line">  //保存发邮件记录</span><br><span class="line">  int saveEmailRecord(MailModel mailModel);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在ServiceImpl层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">package org.ppcirgo.oa.service.impl;</span><br><span class="line"></span><br><span class="line">import org.ppcirgo.oa.beans.model.MailModel;</span><br><span class="line">import org.ppcirgo.oa.mapper.MailMapper;</span><br><span class="line">import org.ppcirgo.oa.service.MailService;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.core.io.FileSystemResource;</span><br><span class="line">import org.springframework.mail.SimpleMailMessage;</span><br><span class="line">import org.springframework.mail.javamail.JavaMailSender;</span><br><span class="line">import org.springframework.mail.javamail.MimeMessageHelper;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import javax.mail.MessagingException;</span><br><span class="line">import javax.mail.internet.MimeMessage;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">@Service</span><br><span class="line">public class MailServiceImpl  implements MailService &#123;</span><br><span class="line"></span><br><span class="line">    private final Logger logger = LoggerFactory.getLogger(this.getClass());</span><br><span class="line">    @Autowired</span><br><span class="line">    private JavaMailSender mailSender;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MailMapper mailMapper;</span><br><span class="line"></span><br><span class="line">    MailModel emailModel=new MailModel();</span><br><span class="line"></span><br><span class="line"> /*   </span><br><span class="line">     * 发送简单邮件</span><br><span class="line">     * @Param sender     邮件发送者</span><br><span class="line">     * @Param receiver   邮件接收者</span><br><span class="line">     * @Param content    邮件内容</span><br><span class="line">     */</span><br><span class="line">    public MailModel sendSimpleMail(String sender, String receiver, String subject, String content) &#123;</span><br><span class="line">        SimpleMailMessage message = new SimpleMailMessage();</span><br><span class="line">        message.setFrom(sender);</span><br><span class="line">        message.setTo(receiver);</span><br><span class="line">        message.setSubject(subject);</span><br><span class="line">        message.setText(content);</span><br><span class="line">        try &#123;</span><br><span class="line">            mailSender.send(message);</span><br><span class="line">            logger.info(&quot;简单邮件已经发送&quot;);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;发送邮件发生异常&quot;,e);</span><br><span class="line">        &#125;</span><br><span class="line">        return  emailModel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> /*   </span><br><span class="line">     * 发送嵌入静态资源（一般是图片）的邮件</span><br><span class="line">     * @Param sender     邮件发送者</span><br><span class="line">     * @Param receiver   邮件接收者</span><br><span class="line">     * @Param content    邮件内容，需要包括一个静态资源id，比如：&lt;img src=\&quot;cid:resId01\&quot;&gt;</span><br><span class="line">     * @Param resPath    静态资源路径和文件名</span><br><span class="line">     * @Param resId      静态资源id</span><br><span class="line">     */</span><br><span class="line">    public MailModel  sendInilneMail(String sender,String receiver, String subject, String content,String resPath,String resId)&#123;</span><br><span class="line">        MimeMessage message= mailSender.createMimeMessage();</span><br><span class="line">        try &#123;</span><br><span class="line">            //true表示需要创建一个multipart message</span><br><span class="line">            MimeMessageHelper helper=new MimeMessageHelper(message,true);</span><br><span class="line">            helper.setFrom(sender);</span><br><span class="line">            helper.setTo(receiver);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            helper.setText(content,true);</span><br><span class="line">            FileSystemResource res=new FileSystemResource(new File(resPath));</span><br><span class="line">            helper.addInline(resId,res);</span><br><span class="line">            mailSender.send(message);</span><br><span class="line">            logger.info(&quot;嵌入静态资源的邮件已经发送&quot;);</span><br><span class="line">        &#125; catch (MessagingException e) &#123;</span><br><span class="line">            logger.error(&quot;发送嵌入静态资源的邮件已经发生异常&quot;,e);</span><br><span class="line">        &#125;</span><br><span class="line">        return  emailModel;</span><br><span class="line">    &#125;</span><br><span class="line">   /*   </span><br><span class="line">     * 发送带附件的邮件</span><br><span class="line">     * @Param sender     邮件发送者</span><br><span class="line">     * @Param receiver   邮件接收者</span><br><span class="line">     * @Param content    邮件内容</span><br><span class="line">     * @Param filePath   附件路径</span><br><span class="line">     */</span><br><span class="line">   public MailModel  sendAttachmentMail(String sender,String receiver,String subject,String content,String filePath)&#123;</span><br><span class="line"></span><br><span class="line">        MimeMessage message=mailSender.createMimeMessage();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //true表示需要创建一个multipart message</span><br><span class="line">            MimeMessageHelper helper=new MimeMessageHelper(message,true);</span><br><span class="line">            helper.setFrom(sender);</span><br><span class="line">            helper.setTo(receiver);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            helper.setText(content,true);</span><br><span class="line">            FileSystemResource file=new FileSystemResource(new File(filePath));</span><br><span class="line">            String fileName=filePath.substring(filePath.lastIndexOf(File.separator));</span><br><span class="line">            helper.addAttachment(fileName,file);</span><br><span class="line">            mailSender.send(message);</span><br><span class="line">            logger.info(&quot;带附件的邮件已经发送&quot;);</span><br><span class="line">        &#125; catch (MessagingException e) &#123;</span><br><span class="line">            logger.error(&quot;发送带附件的邮件时发生异常&quot;,e);</span><br><span class="line">        &#125;</span><br><span class="line">          return  emailModel;</span><br><span class="line">    &#125;</span><br><span class="line">       @Override</span><br><span class="line">    public int saveEmailRecord(MailModel mailModel) &#123;</span><br><span class="line">        return  mailMapper.saveEmailRecord(mailModel);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在Controller层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package org.ppcirgo.oa.controller;</span><br><span class="line">import org.ppcirgo.oa.AJAXResult;</span><br><span class="line">import org.ppcirgo.oa.beans.model.MailModel;</span><br><span class="line">import org.ppcirgo.oa.service.MailService;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.mail.SimpleMailMessage;</span><br><span class="line">import org.springframework.mail.javamail.JavaMailSender;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class MailController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MailService mailService;</span><br><span class="line">    private String defaultStatus=&quot;1&quot;;//默认的发邮件状态</span><br><span class="line">   </span><br><span class="line"> //    简单邮件发送,并保存记录    </span><br><span class="line">    @RequestMapping(value=&quot;/sendSimpleEmail&quot;,method = RequestMethod.GET)</span><br><span class="line">    public Object sendSimpleMail(</span><br><span class="line">            @RequestParam(value=&quot;sender&quot;,required = false) String sender,</span><br><span class="line">            @RequestParam(value=&quot;receiver&quot;,required = false )String receiver,</span><br><span class="line">            @RequestParam(value=&quot;subject&quot;,required = false)  String subject,</span><br><span class="line">            @RequestParam(value=&quot;content&quot;,required = false)  String content</span><br><span class="line">    ) &#123;</span><br><span class="line">            MailModel mailModel=mailService.sendSimpleMail(sender,receiver,subject,content);</span><br><span class="line">            mailModel.setTime(DateUtlis.currentTime((System.currentTimeMillis())));</span><br><span class="line">            mailModel.setStatus(defaultStatus);</span><br><span class="line">         if(mailService.saveEmailRecord(mailModel)&gt;0)</span><br><span class="line">            return new AJAXResult(MsgCode.success);</span><br><span class="line">         else</span><br><span class="line">            return new AJAXResult(MsgCode.error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      //    带有附件的邮件</span><br><span class="line">    @RequestMapping(value=&quot;/sendInlineMail&quot;,method =RequestMethod.GET)</span><br><span class="line">    public Object sendInilneMail(</span><br><span class="line">            @RequestParam(value=&quot;sender&quot;,required = false) String sender,</span><br><span class="line">            @RequestParam(value=&quot;receiver&quot;,required = false )String receiver,</span><br><span class="line">            @RequestParam(value=&quot;subject&quot;,required = false)  String subject,</span><br><span class="line">            @RequestParam(value=&quot;content&quot;,required = false)  String content,</span><br><span class="line">            @RequestParam(value=&quot;resPath&quot;,required = false)  String resPath,</span><br><span class="line">           @RequestParam(value=&quot;resId&quot;,required = false)  String resId</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">        MailModel mailModel=mailService.sendInilneMail(sender, receiver, subject, content,resPath,resId);</span><br><span class="line">            mailModel.setTime(DateUtlis.currentTime((System.currentTimeMillis())));</span><br><span class="line">            mailModel.setStatus(defaultStatus);</span><br><span class="line"></span><br><span class="line">        if(mailService.saveEmailRecord(mailModel)&gt;0)</span><br><span class="line">            return new AJAXResult(MsgCode.success);</span><br><span class="line">        else</span><br><span class="line">            return new AJAXResult(MsgCode.error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 带有附件的邮件    </span><br><span class="line">    @RequestMapping(value=&quot;/sendAttachmentMail&quot;,method =RequestMethod.GET)</span><br><span class="line">    public Object sendAttachmentMail(</span><br><span class="line">            @RequestParam(value=&quot;sender&quot;,required = false) String sender,</span><br><span class="line">            @RequestParam(value=&quot;receiver&quot;,required = false )String receiver,</span><br><span class="line">            @RequestParam(value=&quot;subject&quot;,required = false)  String subject,</span><br><span class="line">            @RequestParam(value=&quot;content&quot;,required = false)  String content,</span><br><span class="line">            @RequestParam(value=&quot;filePath&quot;,required = false)  String filePath</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">        MailModel mailModel=mailService.sendAttachmentMail(sender, receiver, subject, content,filePath);</span><br><span class="line">        mailModel.setTime(DateUtlis.currentTime((System.currentTimeMillis())));</span><br><span class="line">        mailModel.setStatus(defaultStatus);</span><br><span class="line">        if(mailService.saveEmailRecord(mailModel)&gt;0)</span><br><span class="line">            return new AJAXResult(MsgCode.success);</span><br><span class="line">        else</span><br><span class="line">            return new AJAXResult(MsgCode.error);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在model中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package org.ppcirgo.oa.beans.model;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.ToString;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@ToString</span><br><span class="line">public class MailModel &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String sender;   //邮件发送者</span><br><span class="line">    private  String receiver;  //邮件接收者</span><br><span class="line">    private String time;      //邮件发送时间</span><br><span class="line">    private  String  subject;   //邮件主题</span><br><span class="line">    private String status;      //邮件发送状态  1：发送成功  0：发送失败</span><br><span class="line">    private String content;     //邮件内容</span><br><span class="line">    private  String password;   //找回密码时，系统产生的随机密码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了第一步，则通过id，或者其他字段进行查询，修改，删除邮件记录，将变得很简单。在Mapper层写Sql语句，Service层写接口，ServiceImpl层写实现Service层接口的类，最后在Controller进行Service的调用。</p><p>在Mapper层添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//根据发送者查找邮件内容</span><br><span class="line">@Select(value=&quot;select * from emailRecord where id=#&#123;id&#125;&quot;)</span><br><span class="line"> List&lt;MailModel&gt;  getEmailRecordById(@Param(&quot;id&quot;) Integer id);</span><br><span class="line"></span><br><span class="line">//根据标题查询邮件内容</span><br><span class="line">@Select(value=&quot;select * from emailRecord where subject  like  &apos;%$&#123;subject&#125;%&apos;&quot;)</span><br><span class="line"> List&lt;MailModel&gt; getEmailRecordBySubject(@Param(&quot;subject&quot;) String subject);</span><br><span class="line"></span><br><span class="line">//根据发送者修改邮件主题</span><br><span class="line">@Update(value = &quot; update emailRecord set subject=#&#123;subject&#125; where id=#&#123;sender&#125; &quot;)</span><br><span class="line">int updateEmailRecordBySender(@Param(&quot;subject&quot;) String subject, @Param(&quot;sender&quot;) String sender);</span><br><span class="line"></span><br><span class="line">//根据发送者改变发送邮件的state</span><br><span class="line">@Update(value=&quot; update emailRecord set status=#&#123;status&#125; where sender=#&#123;sender&#125;&quot;)</span><br><span class="line">int updateStatusById(@Param(&quot;status&quot;) String status  ,@Param(&quot;sender&quot;) String sender);</span><br><span class="line"></span><br><span class="line">//根据发送者删除邮件</span><br><span class="line">@Delete(value=&quot;delete from emailRecord where sender=#&#123;sender&#125;&quot;)</span><br><span class="line">int  deleteEmailRecordBySender(@Param(&quot;sender&quot;) String sender);</span><br></pre></td></tr></table></figure><p>其他层按照此格式书写代码。</p><p>这样就实现了一个OA项目完整的邮件功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我开发的第一部分是实现发送邮件的业务：实现简单邮件的发送，以及带图片，带附件的邮件发送。将每次发送邮件的记录进行保存，并且可以通过id，或者其他字段进行查询，修改，删除。&lt;/p&gt;
&lt;p&gt;首先，第一步是实现邮件发送业务并保存记录：&lt;/p&gt;
&lt;p&gt;在pom.xml中写入：&lt;/p
      
    
    </summary>
    
      <category term="邮件功能开发" scheme="https://minminminzhang.github.io/categories/%E9%82%AE%E4%BB%B6%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Springboot" scheme="https://minminminzhang.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>小顽童OA项目介绍 </title>
    <link href="https://minminminzhang.github.io/2019/cjqur6yrd000f44nuafiz1pmu/"/>
    <id>https://minminminzhang.github.io/2019/cjqur6yrd000f44nuafiz1pmu/</id>
    <published>2019-01-05T03:12:49.408Z</published>
    <updated>2019-01-13T10:34:25.517Z</updated>
    
    <content type="html"><![CDATA[<p>小顽童之OA项目介绍：基于一个员工在50-100的小型公司的背景，实现简洁办公自动化。具体要实现的功能有：</p><p>1.周计划（编辑/展示给某组或者部门）</p><p>2.月计划（编辑/展示给某组或者部门，计划书的完成进度跟踪，以及提醒及任务安排）</p><p>3.考勤管理（移动app考勤+人脸识别+定位+照片），考勤查询（矿工，请假，休假，正常，迟到）。</p><p>4.自动统计里程与绩效。</p><p>5.加盟管理（创建/编辑/删除某部门的方案，以及活动效果反馈）</p><p>6.导出相关表单为excel文件（如消费者的详细信息）</p><p>7.公司事物通知</p><p>8.公司邮件</p><p>9.移动办公支持</p><p>10.会展示一个页面给商家，进行反馈，以及提交需求和建议。同时可以展示公司近期的活动安排。</p><p>11.提供管理小顽童项目的接口（上架下架产品）</p><p>小顽童之OA项目使用了Springboot轻量级框架，这也是现在企业较为常用的框架。Springboot是Spring框架的集成，相比于Spring框架，Springboot框架除了拥有Spring框架的功能外，配置很简单。只要在pom.xml文件中添加相关依赖，maven可以自动下载。不用担心jar包版本之间的依赖冲突了。开发效率很高。</p><p>搭建Springboot框架所需要的前提</p><p>①jdk8-jdk11  ②Maven3.3  ③Tomcat9.0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;小顽童之OA项目介绍：基于一个员工在50-100的小型公司的背景，实现简洁办公自动化。具体要实现的功能有：&lt;/p&gt;
&lt;p&gt;1.周计划（编辑/展示给某组或者部门）&lt;/p&gt;
&lt;p&gt;2.月计划（编辑/展示给某组或者部门，计划书的完成进度跟踪，以及提醒及任务安排）&lt;/p&gt;
&lt;p&gt;3
      
    
    </summary>
    
      <category term="OA项目介绍" scheme="https://minminminzhang.github.io/categories/OA%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="Springboot" scheme="https://minminminzhang.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>一道关于顺时针打印矩阵的常见算法题</title>
    <link href="https://minminminzhang.github.io/2018/cjqur6yr6000a44nu0op2bzlg/"/>
    <id>https://minminminzhang.github.io/2018/cjqur6yr6000a44nu0op2bzlg/</id>
    <published>2018-12-21T13:28:29.079Z</published>
    <updated>2018-12-23T07:52:20.683Z</updated>
    
    <content type="html"><![CDATA[<p>描述如下：</p><p>假设有一个4*4的矩阵，具体为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1        2       3       4  </span><br><span class="line"></span><br><span class="line">5        6       7       8  </span><br><span class="line"></span><br><span class="line">9       10       11      12</span><br><span class="line"></span><br><span class="line">13      14       15      16</span><br></pre></td></tr></table></figure><pre><code>需要顺时针打印这个矩阵，上面输出的结果应该为：【1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10】。</code></pre><p>考虑将函数的输入当作是一个二维数组（表示矩阵），返回值是矩阵的打印顺序集合。顺时针打印需要明确以下两点：</p><p>（1）知道当前打印到哪一行和哪一列了</p><p>（2）不能出现越界和重复打印</p><p> 对于第一点，定义两个变量row和col指向当前打印的行和列即可；第二点，顺时针打印其实是一圈一圈的打印，打印过程中的任何一次顺时针打印圈都可以用四个变量唯一确定。当前圈的第一行和最后一行，当前圈的最左一列和最右一列。越界问题其实就是要限定row和col变量的取值范围。</p><p>具体的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"> /**</span><br><span class="line">  *top：当前打印圈的第一行；left：当前打印圈的最左列；bottom：当前打印圈的最后一行；right：当前打印圈的最</span><br><span class="line">  *右边一列。top和bottom是用来限定row的取值范围；left和right是用来限定col的取值范围。</span><br><span class="line">  * @param matric</span><br><span class="line">  */</span><br><span class="line">public class printMatric &#123; </span><br><span class="line">    public printMatric(int[][] matric) &#123;</span><br><span class="line">        if (matric == null) &#123;</span><br><span class="line">            System.out.print(&quot;矩阵为空！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //获取矩阵的行和列</span><br><span class="line">        int row = matric.length;</span><br><span class="line">        int col = matric.length;</span><br><span class="line"></span><br><span class="line">        //保存待返回的结果集</span><br><span class="line">        ArrayList&lt;Integer&gt; res = new ArrayList(row * col);</span><br><span class="line">        </span><br><span class="line">        int top = 0, left = 0, bottom = row - 1, right = col - 1;</span><br><span class="line">        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">        </span><br><span class="line">            //从左到右</span><br><span class="line">            for (int m = left; m &lt;= right; m++) &#123;</span><br><span class="line">                res.add(matric[top][m]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">           //从上到下</span><br><span class="line">            for (int m = top + 1; m &lt;=bottom; m++) &#123;</span><br><span class="line">                res.add(matric[m][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            //从右到左</span><br><span class="line">            //只剩一行时，从左到右和从右到左打印的是同一行</span><br><span class="line">            if (top != bottom) &#123;</span><br><span class="line">                for (int m = right - 1; m &gt;= left; m--) &#123;</span><br><span class="line">                    res.add(matric[bottom][m]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           //从下到上</span><br><span class="line">            if (right != left) &#123;</span><br><span class="line">                for (int m = bottom - 1; m &gt; top; m--) &#123;</span><br><span class="line">                    res.add(matric[m][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //为下一圈打印做准备</span><br><span class="line">            top++;</span><br><span class="line">            left++;</span><br><span class="line">            bottom--;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">            System.out.print(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">       int[][] matric = new int[][]&#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125;, &#123;13, 14, 15, 16&#125;&#125;;</span><br><span class="line">        printMatric printMatric = new printMatric(matric);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试之后得到的打印结果是：【1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10】。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;描述如下：&lt;/p&gt;
&lt;p&gt;假设有一个4*4的矩阵，具体为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span
      
    
    </summary>
    
      <category term="顺时针打印矩阵" scheme="https://minminminzhang.github.io/categories/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    
    
      <category term="顺时针打印矩阵" scheme="https://minminminzhang.github.io/tags/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    
  </entry>
  
  <entry>
    <title>用迭代算法解决汉诺塔问题</title>
    <link href="https://minminminzhang.github.io/2018/cjqur6yr3000644nu5mywle5g/"/>
    <id>https://minminminzhang.github.io/2018/cjqur6yr3000644nu5mywle5g/</id>
    <published>2018-12-13T13:34:16.437Z</published>
    <updated>2018-12-13T13:35:47.249Z</updated>
    
    <content type="html"><![CDATA[<p>   汉诺塔游戏可以简单描述为：n个盘子和3根柱子：A(起始柱子)、B(过渡柱子)、C(目的柱子)，盘子的大小不同且中间有一孔，可以将盘子“串”在柱子上，每个盘子只能放在比它大的盘子上面。起初，所有盘子在A柱上，问题是将盘子一个一个地从A柱子移动到C柱子。移动过程中，可以使用B柱，但盘子也只能放在比它大的盘子上面。</p><p>因此我们得出汉诺塔问题的以下几个限制条件：</p><p>1.在小圆盘上不能放大圆盘。</p><p>2.在三根柱子之间一回只能移动一个圆盘。</p><p>3.只能移动在最顶端的圆盘。</p><p>首先，我们从简单的例子开始分析，然后再总结出一般规律：</p><p>1.当n=1的时候，即此时只有一个盘子，那么直接将其移动至C即可。移动过程就是 A -&gt; C</p><p>2.当n=2的时候，这时候有两个盘子，那么在一开始移动的时候，我们需要借助B柱作为过渡的柱子，即将A柱最上面的那个小圆盘移至B柱，然后将A柱底下的圆盘移至C柱，最后将B柱的圆盘移至C柱即可。那么完整移动过程就是A -&gt; B , A -&gt; C , B -&gt; C</p><p>3.当n=3的时候，那么此时从上到下依次摆放着从小到大的三个圆盘，根据题目的限制条件：在小圆盘上不能放大圆盘，而且把圆盘从A柱移至C柱后，C柱圆盘的摆放情况和刚开始A柱的是一模一样的。所以呢，我们每次移至C柱的圆盘（移至C柱后不再移到其他柱子上去），必须是从大到小的，即一开始的时候，我们应该想办法把最大的圆盘移至C柱，然后再想办法将第二大的圆盘移至C柱……然后重复这样的过程，直到所有的圆盘都按照原来A柱摆放的样子移动到了C柱。</p><p>那么根据这样的思路，思考如何才能够将最大的盘子移至C柱？</p><p>要将最大的盘子移至C柱，那么必然要先搬掉A柱上面的n-1个盘子，而C柱一开始的时候是作为目标柱的，所以我们可以用B柱作为”暂存”这n-1个盘子的过渡柱，当把这n-1的盘子移至B柱后，我们就可以把A柱最底下的盘子移至C柱了。</p><p>我们来看看现在各个柱子上盘子的情况，A柱上无盘子，而B柱从上到下依次摆放着从小到大的n-1个盘子，C柱上摆放着最大的那个盘子。</p><p>所以接下来那就是要把B柱这剩下的n-1个盘子移至C柱，那么我们需要借助A柱，将A柱作为新的”过渡”柱，B柱为初始柱，将这n-1个盘子移至目标C柱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HanoiTower&#123;</span><br><span class="line">    topN：移动的盘子数</span><br><span class="line">    from：初始柱子</span><br><span class="line">    to：目的柱子</span><br><span class="line">    inter：过渡柱子</span><br><span class="line">    public static void  doTower(int topN,char from,char inter ,char to)&#123;</span><br><span class="line">          if(topN==1)&#123;</span><br><span class="line">               System.out.println(&quot;盘子1，从”+from+“柱子到”+to+&quot;柱子&quot;);</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">               doTower(topN-1,from,to ,inter);</span><br><span class="line">               System.out.println(&quot;盘子&quot;+topN+&quot;，从&quot;+from+“柱子到”+to+&quot;柱子&quot;);</span><br><span class="line">                doTower(topN-1,inter,from ,to);</span><br><span class="line">          &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TestHanoiTower&#123;</span><br><span class="line">        public class void main(String [] args)&#123;</span><br><span class="line">                 HanoiTower.doTower(3,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>​    程序结果为：盘子1，从A柱子到C柱子</p><pre><code>盘子2，从A柱子到B柱子盘子1，从C柱子到B柱子盘子3，从A柱子到C柱子盘子1，从B柱子到A柱子盘子2，从B柱子到C柱子盘子1，从A柱子到C柱子</code></pre><p>即我们用迭代算法解决了汉诺塔问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   汉诺塔游戏可以简单描述为：n个盘子和3根柱子：A(起始柱子)、B(过渡柱子)、C(目的柱子)，盘子的大小不同且中间有一孔，可以将盘子“串”在柱子上，每个盘子只能放在比它大的盘子上面。起初，所有盘子在A柱上，问题是将盘子一个一个地从A柱子移动到C柱子。移动过程中，可以使
      
    
    </summary>
    
      <category term="迭代算法" scheme="https://minminminzhang.github.io/categories/%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="汉诺塔" scheme="https://minminminzhang.github.io/tags/%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    
  </entry>
  
  <entry>
    <title>用递归和迭代解决二叉树问题 </title>
    <link href="https://minminminzhang.github.io/2018/cjqur6yr1000544nudc9h5ugb/"/>
    <id>https://minminminzhang.github.io/2018/cjqur6yr1000544nudc9h5ugb/</id>
    <published>2018-12-13T08:33:40.644Z</published>
    <updated>2018-12-13T13:19:29.234Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树是数据结构最常见的一种应用。关于二叉树的很多问题都可以用递归和迭代来解决。</p><p>二叉树是一颗树，其中每个节点都不能有对于两个儿子。用代码可以简单的表示为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode&#123;</span><br><span class="line">   int val;</span><br><span class="line">   //左孩子</span><br><span class="line">   TreeNode left;</span><br><span class="line">   //右孩子</span><br><span class="line">   TreeNode left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.求二叉树的最大深度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int maxDeath(TreeNode node)&#123;</span><br><span class="line">    if(node==null)&#123;</span><br><span class="line">       return 0;</span><br><span class="line">&#125; </span><br><span class="line"> int left=maxDeath(node.left);</span><br><span class="line"> int right=maxDeath(node.right);</span><br><span class="line"> return Math.max(left,right)+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.求二叉树的最小深度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int getMinDepth()&#123;</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return getMin(root);</span><br><span class="line">&#125;</span><br><span class="line">int getMin(TreeNode root)&#123;</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    if（root.left==null&amp;&amp;root.right==null）&#123;</span><br><span class="line">      return 1;</span><br><span class="line">      &#125;</span><br><span class="line">      return Math.min(getMin(root.left),getMin(root.right))+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.求二叉树中节点的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int numOfTreeNode(TreeNode root)&#123;</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; </span><br><span class="line">    int left=numOfNode(root.left);</span><br><span class="line">    int right=numOfNode(root.right);</span><br><span class="line">    return left+right+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.求二叉树中叶子节点的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int numsOfNodeTreeNode(TreeNode root)&#123;</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(root.left==null&amp;&amp;root.right==null)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return numsOfNodeTreeNode(root.left)+numsOfNodeTreeNode(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.求二叉树中第K层节点的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int numsOfLevelTreeNode(TreeNode node,int k)&#123;</span><br><span class="line"> if(root==null||k&lt;1)&#123;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line">  if(k=1)&#123;</span><br><span class="line">      return 1;</span><br><span class="line">  &#125;  </span><br><span class="line">  int numLeft=numsOfLevelTreeNode(root.left,k-1);</span><br><span class="line">  int numRight=numsOfLevelTreeNode(root.right,k-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平衡二叉树是其每个节点的左子数和右子树的高度最多差1的二叉查找树.</p><p>6.判断二叉树是否是平衡二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean isBalanced(TreeNode node)&#123;</span><br><span class="line">     return maxDeath(node)!=-1;//空树的高度为1</span><br><span class="line">&#125;</span><br><span class="line">   int maxDeath2(TreeNode node)&#123;</span><br><span class="line">        if(node==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">           &#125;   </span><br><span class="line">       int left=maxDeath(node.left);   </span><br><span class="line">       int right=maxDeath(node.right); </span><br><span class="line">       if(left==-1||right==-1||Math.abs(left-right)&gt;1)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">         return Math.max(left,right)+1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>7.判断两个二叉树是否完全相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">boolean isSameTreeNode(TreeNode t1,TreeNode t2)&#123;</span><br><span class="line">    if(t1==null&amp;&amp;t2==null)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else if(t1==null||t2==null)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(t1.val!=t2.val)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean left=isSameTreeNode(t1.left,t2.left);</span><br><span class="line">    boolean right=isSameTreeNode(t1.right,t2.right);</span><br><span class="line">    return left&amp;&amp;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.两个二叉树是否为镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean isMirror(TreeNode t1,TreeNode t2)&#123;</span><br><span class="line"> if(t1==null&amp;&amp;t2==null)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else if(t1==null||t2==null)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(t1.val!=t2.val)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return isMirror(t1.left,t2.right)&amp;&amp;isMirror(t1.right,t2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.二叉树的前序遍历</p><p>迭代解法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; preOrder(TreeNode root)&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt;  stack=new Stack&lt;TreeNode&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    while(!stack.empty)&#123;</span><br><span class="line">       TreeNode node=stack.pop();</span><br><span class="line">       list.add(node.val);</span><br><span class="line">       if(node.right!=null)&#123;</span><br><span class="line">           stack.push(node.right);</span><br><span class="line">       &#125;</span><br><span class="line">        if(node.left!=null)&#123;</span><br><span class="line">           stack.push(node.left);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归解法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; preOrder(TreeNode root)&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; result =new  ArrayList&lt;Integer&gt;();</span><br><span class="line">    preOrder2(root,result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">void preOrder2(TreeNode root,ArrayList&lt;Integer&gt; result)&#123;</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    result.add(root.val);</span><br><span class="line">    preOrder2(root.left,result);</span><br><span class="line">    preOrder2(root.right,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10.二叉树中的中序遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; inOrder(TreeNode root)&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt;  stack=new Stack&lt;TreeNode&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();</span><br><span class="line">    TreeNode current=root;</span><br><span class="line">   while(current！=null||!stack.empty())&#123;</span><br><span class="line">       while(current!=null)&#123;</span><br><span class="line">           stack.add(current);</span><br><span class="line">           current=current.left;</span><br><span class="line">       &#125;</span><br><span class="line">       current=stack.peek();</span><br><span class="line">       stack.pop();</span><br><span class="line">       list.add(current.val);</span><br><span class="line">       current=current.right;</span><br><span class="line">   &#125;</span><br><span class="line">   return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11.二叉树的后序遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; postOrder(TreeNode root)&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list=new ArrayList&gt;(Integer);</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    list.addAll(posrOrder(root.left));</span><br><span class="line">    list.addAll(posrOrder(root.right);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二叉树是数据结构最常见的一种应用。关于二叉树的很多问题都可以用递归和迭代来解决。&lt;/p&gt;
&lt;p&gt;二叉树是一颗树，其中每个节点都不能有对于两个儿子。用代码可以简单的表示为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
      <category term="二叉树" scheme="https://minminminzhang.github.io/categories/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="二叉树" scheme="https://minminminzhang.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>java中常用的注解总结 </title>
    <link href="https://minminminzhang.github.io/2018/cjqur6yqz000444nu9b9qyhp4/"/>
    <id>https://minminminzhang.github.io/2018/cjqur6yqz000444nu9b9qyhp4/</id>
    <published>2018-12-13T08:33:40.644Z</published>
    <updated>2018-12-13T13:23:41.955Z</updated>
    
    <content type="html"><![CDATA[<p>注解就是源代码的元数据。</p><p>1.声明bean的注解</p><p>@Conponent组件，当组件不好归类的时候，我们可以使用这个注解进行标注</p><p>@Service在业务逻辑层使用（service层）</p><p>@Reponsitory在数据访问层使用（dao层）</p><p>@Controller在展现层使用，控制器的声明，用来创建处理http请求的对象（Controller层）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController&#123;</span><br><span class="line">         @RequestMapping(&quot;/test&quot;)</span><br><span class="line">        public String test（String string）｛</span><br><span class="line">     return   &quot;hello&quot;;</span><br><span class="line">｝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.注入bean的注解</p><p>@Autowired：由Spring提供，可以用在字段上，或者方法上。默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired（required=false）</p><p>@Resource：作用相当于@Autowired，只不过@Autowired按byName自动注入，而@Resource默认按byName自动注入。</p><p>都可以注解在set方法和属性上</p><p>3.java配置类相关注解</p><p>@Configuration声明当前类为配置类，相当于xml形式的Spring配置（类上）</p><p>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）</p><p>@Component注解，表明这个类是一个bean（类上）</p><p>4.切面（AOP）相关注解</p><p>Spring支持AspectJ的注解式切面编程</p><p>@Aspect声明一个切面（类上）</p><p>使用@After、@Before、@Around定义advice，可直接将拦截规则（切点）作为参数</p><p>@After 在方法执行之后执行（方法上）</p><p>@Before 在方法执行之前执行（方法上）</p><p>@Around 在方法执行之前与之后执行（方法上）</p><p>@PointCut声明切点</p><p>5.@Bean的属性支持</p><p>@Scope用来配置 spring bean 的作用域，它标识 bean 的作用域。 </p><p>其设置的类型包括：</p><p>Singleton：单例，一个Spring容器中只有一个bean实例，默认模式</p><p>Protetype：每次调用新建一个bean</p><p>Request：web项目中，给每个http request新建一个bean</p><p>Session：web项目中，给每个http session新建一个bean</p><p>GlobalSession：给每一个global http session 新建一个Bean实例</p><p>6.@Value注解</p><p>@Value为属性注入值（属性上）</p><p>普通字符注入： @Value（”lisa”） String name</p><p>注入文件资源： @Value（”classpath:com/file/test.txt”）String source file</p><p>注入配置文件： @Value(“${book.name}”)Sring bookName</p><p>7.SpringMVC相关注解</p><p>@Controller：声明该类为SpringMVC中的Controller</p><p>@RequestMapping：用于映射Web请求，包括访问路径和参数（类或方法上）</p><p>具体的在类定义处：提供初步的请求映射信息，相对于WEB应用的根目录。</p><p>方法处：提供进一步的戏份映射信息，相对于类定义处的URL。</p><p>@RequestParam：用于将请求参数区数据映射到功能处理方法的参数上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class test(@RequestParam Integer id)&#123;</span><br><span class="line">    return  mailService.fetch(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个id就是要接收从接口传递过来的参数id的值的，如果接口传递过来的参数名和你接收的不一致，也可以如下 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class test(@RequestParam(value=&quot;user_id&quot;) Integer id)&#123;</span><br><span class="line"> return  mailService.fetch(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中user_id就是接口传递的参数，id就是映射user_id的参数名</p><p>@ResponseBody：支持将返回值放在response内，而不是一个页面，通常用户返回json数据</p><p>注意：Spring4之后加的注解@RestController。原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController代替@Controller就不需要再配置@ResponseBody，默认返回json格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TestController&#123;</span><br><span class="line">         @RequestMapping(&quot;/test&quot;)</span><br><span class="line">        public String test（String string）｛</span><br><span class="line">     return   &quot;hello&quot;;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>} </p><p>@RequestBody：允许request的参数在request体中，而不是在直接连接在地址后面</p><p>@ModelAttribute：让全局的@RequestMapping都能获得在此设置的键值对</p><p>以上是我在学习中常见的和常用的java注解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注解就是源代码的元数据。&lt;/p&gt;
&lt;p&gt;1.声明bean的注解&lt;/p&gt;
&lt;p&gt;@Conponent组件，当组件不好归类的时候，我们可以使用这个注解进行标注&lt;/p&gt;
&lt;p&gt;@Service在业务逻辑层使用（service层）&lt;/p&gt;
&lt;p&gt;@Reponsitory在数据访问层
      
    
    </summary>
    
      <category term="开发注解应用" scheme="https://minminminzhang.github.io/categories/%E5%BC%80%E5%8F%91%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="注解应用" scheme="https://minminminzhang.github.io/tags/%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>时间典当厅项目之增加功能和上传</title>
    <link href="https://minminminzhang.github.io/2018/cjqur6yrh000h44nuz56vcpva/"/>
    <id>https://minminminzhang.github.io/2018/cjqur6yrh000h44nuz56vcpva/</id>
    <published>2018-12-02T08:49:04.879Z</published>
    <updated>2018-12-02T09:08:26.971Z</updated>
    
    <content type="html"><![CDATA[<p>在项目之上添加用户排序功能，上传到服务器。</p><h3 id="增加排序功能："><a href="#增加排序功能：" class="headerlink" title="增加排序功能："></a>增加排序功能：</h3><p>1.分别在dao，service，controller三层实现相应的后台代码。</p><p>​           dao层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;InfoUser&gt; userSort() &#123;</span><br><span class="line">        String sql = &quot;select * from t_user ORDER  by goldCoins desc &quot;;</span><br><span class="line">        return this.jdbcTemplate.query(sql, new InfoUser());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    service层 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;InfoUser&gt; userSort() &#123;</span><br><span class="line">    return this.userDao.userSort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller层 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@RequestMapping(&#123;&quot;userSort&quot;&#125;)</span><br><span class="line">@ApiOperation(</span><br><span class="line">    value = &quot;get user sort&quot;,</span><br><span class="line">    httpMethod = &quot;GET&quot;,</span><br><span class="line">    response = Result.class,</span><br><span class="line">    nickname = &quot;ALISURE&quot;</span><br><span class="line">)</span><br><span class="line">public Result getUserSort() &#123;</span><br><span class="line">    return new Result(this.userService.userSort());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在idea里面调试，访问<a href="https://localhost:8081/ddh/user/soetUser" target="_blank" rel="noopener">https://localhost:8081/ddh/user/soetUser</a>  本地测试正确。</p><p>3.上传服务器</p><p>​          （1）打开Xshell，输入项目名称和密码，连接到项目服务器。</p><p>​          （2）打开Xftp，连接成功。在路径下找到后台代码 </p><p>​                      （3）上传修改之后的新代码。服务器中的后台代码都是以.class结尾，编译之后的文件，不能直接修改。</p><p>​          应该先下载要修改的文件，在IDEA里面打开，修改要添加的代码，修改之后在IDEA里面进行单个文件的编译。找到编译之后的class文件（项目编译之后的class一般存储在项目下的target文件夹里面），直接拖进Xftp进行上传。</p><p>​          注意：编译项目里面的某个单个文件时直接在IDEA里面编辑，不要再cmd命令框里面编译，因为cmd默认实在当前目录查找class文件，会报找不到依赖包的错误。</p><p>​<br> 4.把项目上传服务器成功之后，重新启动tomcat.即可通过网址<a href="http://timeseller.fantasy512.cn/ddh/user/soetUser" target="_blank" rel="noopener">http://timeseller.fantasy512.cn/ddh/user/soetUser</a>    即可获取到用户数据，然后将获取到的用户数据和接口user/sortUser一并传给前端，实现前后端的交互。</p><p>​<br>5.确保无误的代码即可上传到github上保存完整的代码。</p><h3 id="补充：重启服务器的tomcat"><a href="#补充：重启服务器的tomcat" class="headerlink" title="补充：重启服务器的tomcat"></a>补充：重启服务器的tomcat</h3><p> （1）首先，进入tomcat下的bin目录  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd   usr/tomcat/bin</span><br></pre></td></tr></table></figure><p>（2）使用tomcat关闭命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shutdown.sh</span><br></pre></td></tr></table></figure><p> （3）查看tomcat是否已经关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep java</span><br></pre></td></tr></table></figure><p>​    如果显示以下相似信息，说明tomcat还没有关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root      7010     1  0 Apr19 ?        00:30:13 /usr/local/java/bin/java</span><br><span class="line"></span><br><span class="line">-Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties</span><br><span class="line">-Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms1024m -Xmx1024m</span><br><span class="line">-XX:NewSize=256m -XX:MaxNewSize=256m -XX:PermSize=256m -XX:MaxPermSize=256m</span><br><span class="line">-XX:+DisableExplicitGC -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.endorsed.dirs=/usr/local/tomcat/endorsed -classpath /usr/local/tomcat/bin/bootstrap.jar</span><br><span class="line">-Dcatalina.base=/usr/local/tomcat -Dcatalina.home=/usr/local/tomcat</span><br><span class="line">-Djava.io.tmpdir=/usr/local/tomcat/temp org.apache.catalina.startup.Bootstrap start</span><br></pre></td></tr></table></figure><p>（4）如果直接想杀死tomcat进程（进程号7010），可以使用kill命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9  7010</span><br></pre></td></tr></table></figure><p>（5）继续查看tomcat是否已经关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep java</span><br></pre></td></tr></table></figure><p>  如果出现以下信息，则表示tomcat已经关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root      7010     1  0 Apr19 ?        00:30:30 [java] &lt;defunct&gt;</span><br></pre></td></tr></table></figure><p>（6）最后，启动tomcat<br>./startup.sh</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目之上添加用户排序功能，上传到服务器。&lt;/p&gt;
&lt;h3 id=&quot;增加排序功能：&quot;&gt;&lt;a href=&quot;#增加排序功能：&quot; class=&quot;headerlink&quot; title=&quot;增加排序功能：&quot;&gt;&lt;/a&gt;增加排序功能：&lt;/h3&gt;&lt;p&gt;1.分别在dao，service，cont
      
    
    </summary>
    
      <category term="代码上传服务器 " scheme="https://minminminzhang.github.io/categories/%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="代码上传服务器" scheme="https://minminminzhang.github.io/tags/%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架总结 </title>
    <link href="https://minminminzhang.github.io/2018/cjqur6yqr000144nuyfjkqt5r/"/>
    <id>https://minminminzhang.github.io/2018/cjqur6yqr000144nuyfjkqt5r/</id>
    <published>2018-11-18T01:48:31.224Z</published>
    <updated>2018-12-02T08:33:16.386Z</updated>
    
    <content type="html"><![CDATA[<p>对于java程序员，Spring是做多使用，也必须掌握的框架之一。Spring是一站式的开源框架解决方案。</p><h3 id="1-Spring的核心：AOP-、IOC"><a href="#1-Spring的核心：AOP-、IOC" class="headerlink" title="1.Spring的核心：AOP    、IOC"></a>1.Spring的核心：AOP    、IOC</h3><p>（1）AOP：面向切面编程，扩展功能不是修改源代码实现。</p><p>（2）IOC：控制反转。IOC操作时把对象的创建交给Springl进行管理，IOC 操作包括IOC的配置文件文件方式和IOC的注解方式。</p><h3 id="2-Spring的bean管理（xml方式）"><a href="#2-Spring的bean管理（xml方式）" class="headerlink" title="2.Spring的bean管理（xml方式）"></a>2.Spring的bean管理（xml方式）</h3><p>（1）bean实例化的方式</p><p>  1）在Spring里面通过配置文件创建对象</p><p>  2）bean实例化的三种方式</p><p>①：使用类的无参数构造创建<br>  <bean id=" " class=" "></bean></p><p>注意：这样的前提是该类存在无参数的构造方法，如果类里面没有参数的构造，会出现异常：No default constructor found；</p><p>②：使用静态工厂创建，创建静态的方法，返回类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Bean1Factory&#123;</span><br><span class="line">  public static Bean1  getBean1( )&#123;</span><br><span class="line">                return new Bean1( );</span><br><span class="line">                &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><!-- 使用静态工厂创建对象--> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bean1&quot; class=&quot;cn.xidiaa.bean.Bean1Factory&quot; factory-method=&quot;&quot;getBean1&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>③：使用实例工厂创建 ，创建不是静态的方法，返回类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Bean2Factory&#123;</span><br><span class="line">     public Bean2 getBean2( )&#123;</span><br><span class="line">              return new Bean2( );</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p> (2)  Bean标签常用属性</p><p> 1）id属性：起名称，id属性值名称任意命名。</p><p>?       id属性值，不能包含特殊符号。根据id值得到配置对象。</p><p> 2）class属性：创建对象所在类的全路径。</p><p> 3）name属性：功能和id属性是一样的，id属性值不能包含特殊符号，但是在name属性值里面可以包含特殊符号。</p><p> 4）scope属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-singleton：默认值，单例   scope=“singleton”  cn.xidiaa.ioc.User@1be3a66</span><br><span class="line">                                             cn.xidiaa.ioc.User@1be3a66</span><br><span class="line">-prototype:多例  cn.xidiaa.ioc.User@e90eef</span><br><span class="line">                 cn.xidiaa.ioc.User@d381e4</span><br></pre></td></tr></table></figure><p>（3）属性注入介绍</p><p>1）创建对象的时候，像类里面属性里面设置值。</p><p>2）属性注入的方式介绍（三种方式）</p><p>​      三种方式包括：使用set方法注入，有参数构造注入，使用接口注入。<br>       在Spring框架里面，支持前两种方式：</p><p>①：使用有参数构造注入属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;demo&quot; class=&quot;cn.xidiaa.property.PropertyDemo1&quot;&gt;</span><br><span class="line">              &lt;constructor-arg name=&quot;username&quot; value=&quot;jery&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">       &lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private String username;</span><br><span class="line">   public PropertyDemo(String username)&#123;</span><br><span class="line">        this.username=username;</span><br><span class="line">   &#125;</span><br><span class="line">   public void test1()&#123;</span><br><span class="line">    System.out.println(&quot;demo......&quot;+username);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>②：使用set方法注入属性  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private String bookname;</span><br><span class="line">  public void setBookname(String bookname)&#123;</span><br><span class="line">       this.bookname=bookname;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;book&quot; class=&quot;cn.xidiaa.property.Book&quot;&gt;</span><br><span class="line">          &lt;property  name=&quot;bookname&quot; value=&quot;方漫图&quot;&gt;&lt;/property&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p> 3）注入对象类型属性：xml方式</p><p> ①：创建service类和dao类<br> 在service得到dao对象</p><p> ②：具体实现过程<br>     在service里面把dao作为类型属性，生成dao类型属性的set方法。     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">          private UserDao userDao;</span><br><span class="line">          public void setUserDao(UserDao uesrDao)&#123;</span><br><span class="line">                 this.userDao=userDao;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p> ③：配置文件中注入关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;cn.xidiaa.ioc.UserDao&quot;&gt;&lt;/bean&gt;</span><br><span class="line">        &lt;bean id=&quot;userDao&quot; class=&quot;cn.xidiaa.ioc.UserService&quot;&gt;        </span><br><span class="line">       &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p> 4)基于注解方式的bean创建以及注入<br> 因为Spring注解的实现是需要AOP的支持，因此在依赖方面需要注意，其次，要在XML中开启注解扫描：</p><pre><code>&lt;context:component-scan base-package=&quot;&quot; /&gt;</code></pre><p>实际上这个配置，会让Spring在指定包下扫描，把带有注解标志的bean实例化，并且会进行属性注入。  </p><p>创建对象的4个注解：</p><p>@Component/@Controller/@Service/@Repository<br>在这4个注解上，通过value属性来指定bean的id，通过@scope配合来声明单例OR多例。</p><p>注入属性：</p><p>@Autowired/@Resource/@Qualifier</p><p>注意：@Resource是javax包下的，就是J2EE提供的；而@Autowired是Spring提供的。（不必提供setter方法）</p><p>@Resource默认按照名称注入，如果找不到才按照类型注入。</p><p>@Autowired默认按照类型注入，可以结合@Qualifier进行名称注入。</p><p>注意：如果@Autowired进行类型注入，很可能类型会有多个满足（多态），那么到底注入哪个呢？所以说，如果按照@Autowired类型注入，一定注意结合@Qualifier。实际开发中，显然，注入应该是确定的，那么按照名称注入，应该是首选！ </p><h3 id="3-Spring事务管理"><a href="#3-Spring事务管理" class="headerlink" title="3.Spring事务管理"></a>3.Spring事务管理</h3><p>Spring的声明式事务管理，用的最多的就是基于注解的方式。首先我们得配置一个事务管理器，而事务管理器需要我们注入DataSource。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;tx:annotation-driven/&gt;</span><br></pre></td></tr></table></figure><p>  对于多个数据源，需要定义多个事务管理器，同时也得开启事务注解。过个事务管理器，可以通过Qualifier属性进行区分。</p><p>配置完毕后，直接在service层的类或者方法上，使用<br>@Transactional(value = “gcs”, rollbackFor = Exception.class)</p><h3 id="4-Spring整合web项目原理"><a href="#4-Spring整合web项目原理" class="headerlink" title="4.Spring整合web项目原理"></a>4.Spring整合web项目原理</h3><p>?1）加载Spring核心配置文件     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context=new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);</span><br></pre></td></tr></table></figure><p>  new对象，功能可以实现，效率很低。</p><p>  2）实现思想：把加载配置文件和创建对象过程，在服务器启动时候完成。</p><p>  3）实现原理：</p><p>   ①：ServletContext对象</p><p>   ②：监听器</p><p>   ③：具体使用</p><p>   ——在服务器启动的时候，为每个项目创建一个ServletContext对象</p><p>   ——在ServletContext对象创建的时候，使用监听器可以具体到ServletContext对象在什么时候创建</p><p>   ——使用监听器听到ServletContext对象创建的时候，加载spring配置文件，把配置文件配置对象创建</p><p>   ——把创建出来的对象放到ServletContext域对象里面（setAttribute方法）<br>   ——获取对象的时候，到ServletContext域里面得到（getAttribute方法）</p><h3 id="5-补充"><a href="#5-补充" class="headerlink" title="5.补充"></a>5.补充</h3><p>（1）.IOC和DI区别</p><p>1）IOC: 控制反转，把对象创建交给spring进行配置</p><p>2）DI: 依赖注入，向类里面的属性中设置值</p><p>3）关系：依赖注入不能单独存在，需要在ioc基础之上完成操作</p><p>（2）.关于AOP的几个重点概念：</p><p>1）AOP的实现，一种横向抽取机制，依赖于动态代理模式。</p><p>2）JoinPoint：连接点，说白了，就是可以被增强的方法；</p><p>3）PointCut：切入点，对哪些JoinPoint进行拦截；</p><p>4）Advice：通知，就是拦截后的动作；</p><p>5）Aspect：切面，把增强应用到具体方法的过程；</p><p>Spring的AOP需要借助aspectj来实现，可以通过XML，也可以通过注解来完成。</p><p>比如，采用XML方式的话，需要指明用A类的哪个方法对B类的哪些方法上进行增强，这里就涉及到execution表达式了；</p><p>比如，采用注解方式的话，就更加简单了，先在XML中开启AOP（&lt;aop:aspectj-autoproxy /&gt;），然后在增强方法上直接使用类似@Before(value=”execution(具体的表达式)”)就可以了；<br>其实在实际开发中，我们对于AOP最常用的就是事务了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于java程序员，Spring是做多使用，也必须掌握的框架之一。Spring是一站式的开源框架解决方案。&lt;/p&gt;
&lt;h3 id=&quot;1-Spring的核心：AOP-、IOC&quot;&gt;&lt;a href=&quot;#1-Spring的核心：AOP-、IOC&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Spring框架 " scheme="https://minminminzhang.github.io/categories/Spring%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Springl整合web项目" scheme="https://minminminzhang.github.io/tags/Springl%E6%95%B4%E5%90%88web%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>小顽童项目准备</title>
    <link href="https://minminminzhang.github.io/2018/cjqur6yrk000l44nunukliv89/"/>
    <id>https://minminminzhang.github.io/2018/cjqur6yrk000l44nunukliv89/</id>
    <published>2018-10-28T00:32:45.112Z</published>
    <updated>2018-12-13T13:12:59.845Z</updated>
    
    <content type="html"><![CDATA[<p>基于前期的学习，为了进一步用以实践，我们准备开发一个小网站—–小顽童。</p><p>涉及到：1.前端 2.后台 3.移动端</p><p>网站的内容：</p><p>1.板块（论坛，可以参考西电睿思），具体主题未定，大家均可以提出意见，然后进行业务开发。</p><p>2.工具，提供常用查询，如天气查询，列车时刻查询，远程查询 ，IP详情，电话详情，遥控等等。</p><p>3.自定义模块</p><p>涉及到的技术：</p><p>工具：IDEA,maven,git(github),wiki</p><p>容器：tomcat7及以上，推荐9</p><p>前端：html+css+js(Ajax)</p><p>前端框架：vue.js</p><p>后台：jsp/servlet</p><p>框架：spring/springmvc/mybatis</p><p>移动端：推荐webApp</p><p>数据库：mysql</p><p>美工：ps,图标尽量在阿里巴巴矢量图标库下载，美图秀秀也可以。</p><p>本次项目分工明确：我作为项目参与者，主要负责后台开发。</p><h4 id="一-首先，安装开发工具IDEA"><a href="#一-首先，安装开发工具IDEA" class="headerlink" title="一.首先，安装开发工具IDEA"></a>一.首先，安装开发工具IDEA</h4><p>IDEA的安装以及破解步骤：</p><p>1.从睿思或者官网下载最新的IDEA软件到本地。</p><p>2.双击安装，选择合适的下载路径。</p><p>3.安装完毕后，先不要打开。</p><p>4.开始破解：</p><p>5.首先更改hosts文件。（位置：C:\Windows\System32\drives\etc）。</p><p>6.使用文本编译器打开hosts</p><p>  在最后一行添加：0.0.0.0          account.jetbrains.com!1540689850659]</p><p>7.打开运行idea，会提示让你注册，有三种方式，下面就是注册码，copy进去确认即可。</p><p>K71U8DBPNE-eyJsaWNlbnNlSWQiOiJLNzFVOERCUE5FIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifV0sImhhc2giOiI4OTA4Mjg5LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-Owt3/+LdCpedvF0eQ8635yYt0+ZLtCfIHOKzSrx5hBtbKGYRPFDrdgQAK6lJjexl2emLBcUq729K1+ukY9Js0nx1NH09l9Rw4c7k9wUksLl6RWx7Hcdcma1AHolfSp79NynSMZzQQLFohNyjD+dXfXM5GYd2OTHya0zYjTNMmAJuuRsapJMP9F1z7UTpMpLMxS/JaCWdyX6qIs+funJdPF7bjzYAQBvtbz+6SANBgN36gG1B2xHhccTn6WE8vagwwSNuM70egpahcTktoHxI7uS1JGN9gKAr6nbp+8DbFz3a2wd+XoF3nSJb/d2f/6zJR8yJF8AOyb30kwg3zf5cWw==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==</p><h4 id="二-安装git，这里默认都是Windows系统。"><a href="#二-安装git，这里默认都是Windows系统。" class="headerlink" title="二.安装git，这里默认都是Windows系统。"></a>二.安装git，这里默认都是Windows系统。</h4><p>1.登陆git官网，下载windows版的进行安装，选择安装路径，其他均选择默认配置。</p><p>2.安装成功后，验证是否成功（打开git bash，输入git–version）。</p><p>3.检查用户名和邮箱是否配置（git config –global –list）</p><p>4.如果没有，进行配置。</p><p>设置用户名：git config –global user.name “xxx”</p><p>设置邮箱：git config –global user.email “xxxxx”</p><p>5.生成ssh-key（ssh-keygen -t rsa -C “你的email”）</p><p>整个过程一直回车，有需要yes/no,就yes。最后会生成一份ssh私钥和一份公钥。</p><p>6.打开公钥位置，发给项目管理人。</p><h4 id="三-申请github账号"><a href="#三-申请github账号" class="headerlink" title="三.申请github账号"></a>三.申请github账号</h4><p>申请成功后，将用户名一并发给项目管理人。</p><h4 id="四-用码云进行一个简单的前后端测试"><a href="#四-用码云进行一个简单的前后端测试" class="headerlink" title="四.用码云进行一个简单的前后端测试"></a>四.用码云进行一个简单的前后端测试</h4><p>1.进入：<a href="http://gitee.com/" target="_blank" rel="noopener">http://gitee.com/</a></p><p>搜索到urchin_board，然后进行fork。</p><p>2.切换到alpha分支上面，创建一个txt文件，进行PR操作，则成功进入到项目组织里面。</p><h4 id="五-安装tomcat9"><a href="#五-安装tomcat9" class="headerlink" title="五.安装tomcat9"></a>五.安装tomcat9</h4><p>   安装方式：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a></p><h4 id="六-安装maven"><a href="#六-安装maven" class="headerlink" title="六.安装maven"></a>六.安装maven</h4><p>安装教程为：<a href="https://blog.csdn.net/t_1025/article/details/70148793" target="_blank" rel="noopener">https://blog.csdn.net/t_1025/article/details/70148793</a></p><p>中央仓库建议用阿里巴巴，这样速度更快一些</p><h4 id="七-在idea上进行git操作"><a href="#七-在idea上进行git操作" class="headerlink" title="七.在idea上进行git操作"></a>七.在idea上进行git操作</h4><p>1.File-setting-Gitee，点击Install。</p><p>2.安装成功后，进行如下操作。</p><p>​    crtl+alt+s到界面：Version Control-Gitee-Creat API Token-输入码云的账号和密码-Test</p><p>3.接下来用git拉取项目</p><p>(1)File–New–Project from Version Control–Git</p><p>(2)复制仓库时：要求输入URL和Directory。</p><p>4，在码云中，切换到alpha，点击克隆/下载，复制链接到URL，进行克隆，克隆成功后就可以看到新建的文件了。</p><p>注意：当遇到URL没有错误，但克隆失败时，检查是否已经添加了ssh-key，如果没有则先进行添加之后再克隆代码。</p><p>5.点击同步之后，检查idea页面最下方是否存在Terminal和Git：master。</p><p>6.创建分支</p><p>git checkout -b “分支名-alpha”</p><p>创建成功之后，右下角出现分支名–Git：minminminzhang。</p><h4 id="八-接下来进行项目的同步操作。"><a href="#八-接下来进行项目的同步操作。" class="headerlink" title="八.接下来进行项目的同步操作。"></a>八.接下来进行项目的同步操作。</h4><h5 id="1-编写pom-xml-一人编写，其他人同步即可。"><a href="#1-编写pom-xml-一人编写，其他人同步即可。" class="headerlink" title="1.编写pom.xml,一人编写，其他人同步即可。"></a>1.编写pom.xml,一人编写，其他人同步即可。</h5><p>编写完成之后，进行pull操作。</p><p>pull操作可以用git命令：</p><p>git stash</p><p>git pull origin master</p><p>git stash pop</p><p>还有一种就是：右击项目-Git-Repository-Pull，始终选择origin/alpha.</p><p>就可以看到pom.xml进行更新了，更新完成之后有290行代码。</p><h5 id="2-整合SSM框架"><a href="#2-整合SSM框架" class="headerlink" title="2.整合SSM框架"></a>2.整合SSM框架</h5><p>  <a href="https://www.cnblogs.com/hackyo/p/6646051.html" target="_blank" rel="noopener">https://www.cnblogs.com/hackyo/p/6646051.html</a></p><h4 id="九-运行项目"><a href="#九-运行项目" class="headerlink" title="九.运行项目"></a>九.运行项目</h4><p>1，重新登录码云，有可能过期了。</p><p>Alt+Ctrl+s–Gitee–Create API Token–Test</p><p>2，再配置一下tomcat服务器</p><p> (1)点击项目urchin右边的倒三角Edit Configurations</p><p> (2)在Run/Debug Configurations页面：点击最上面的“+”号–Maven–选择项目urchin–在Command ling行选择tomact：run，应用保存。</p><p>3，测试，运行</p><p>在index.jsp页面简单的写一个程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        p&#123;</span><br><span class="line">            font-size: 50px;</span><br><span class="line">            color:aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello World!&lt;/h2</span><br><span class="line">    &lt;p&gt;小顽童项目开始了&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>点击运行：</p><p>下方出现一行[INFO]  Running war on <a href="http://localhost:9091/urchin" target="_blank" rel="noopener">http://localhost:9091/urchin</a></p><p>即访问此网址就可以看到运行结果。</p><p>以上准备工作完成之后，我们就可以进行项目的设计开发了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于前期的学习，为了进一步用以实践，我们准备开发一个小网站—–小顽童。&lt;/p&gt;
&lt;p&gt;涉及到：1.前端 2.后台 3.移动端&lt;/p&gt;
&lt;p&gt;网站的内容：&lt;/p&gt;
&lt;p&gt;1.板块（论坛，可以参考西电睿思），具体主题未定，大家均可以提出意见，然后进行业务开发。&lt;/p&gt;
&lt;p&gt;2
      
    
    </summary>
    
      <category term="开发项目准备工作" scheme="https://minminminzhang.github.io/categories/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="开发项目准备和相关技术" scheme="https://minminminzhang.github.io/tags/%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87%E5%92%8C%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java中常用设计模式的使用方法与区别</title>
    <link href="https://minminminzhang.github.io/2018/cjqur6yto001c44numz0iwkb4/"/>
    <id>https://minminminzhang.github.io/2018/cjqur6yto001c44numz0iwkb4/</id>
    <published>2018-10-08T12:10:59.041Z</published>
    <updated>2018-11-18T02:22:32.249Z</updated>
    
    <content type="html"><![CDATA[<p> 设计模式其实就是一套被反复使用的代码设计经验的总结。</p><p> 使用设计模式的优点就是：代码可以重用，更容易被他人理解，保证代码的可靠性。</p><p>Java中的设计模式以供有23种，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。</p><h2 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h2><p>​       我们在实例化对象的时候通常用new关键字，但是有了工厂，我们在声明对象的时候就可以用到工厂了，使得代码更加灵活。是由一个工厂对象决定创建出哪一种产品类的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//抽象产品</span><br><span class="line">public abstract class Car&#123;</span><br><span class="line">     public abstract  void Driver( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line">public class BenC&#123;</span><br><span class="line">       public void Driver( )&#123;</span><br><span class="line">            Console.WriteLine(&quot;奔驰&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line"></span><br><span class="line">public class BaoM&#123;</span><br><span class="line">       public void Driver( )&#123;</span><br><span class="line">            Console.WriteLine(&quot;宝马&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//简单工厂</span><br><span class="line"></span><br><span class="line">public class Driver( )&#123;</span><br><span class="line">      public static Car DriverCar (string carName)&#123;</span><br><span class="line">                Car car;</span><br><span class="line">           if(carName)==&quot;奔驰&quot;)&#123;</span><br><span class="line">              car=new BenC( );</span><br><span class="line">         &#125; </span><br><span class="line">          else&#123;</span><br><span class="line">                car=new BaoM( );</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//客户代码</span><br><span class="line">public class Boss&#123;</span><br><span class="line">    Car car1=Driver.DriverCar(&quot;奔驰&quot;);</span><br><span class="line">   car1.Driver();</span><br><span class="line">  Car car2=Driver.DriverCar(&quot;宝马&quot;);</span><br><span class="line">   car2.Driver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><p>（1）简单工厂包含必要的判断逻辑，实现了对象的创建和使用的分离。</p><p>（2）客户端无需知道所创建的具体产品类的类名，只需要具体产品类对应的参数即可。</p><p>（3）在不修改客户端代码的情况下更换和增加具体产品类，提高了系统的灵活性。</p><p>缺点：</p><p>当产品修改时，工厂类也需要做相应的修改，违反了开—闭原则。</p><p>简单工厂模式适用于业务简单或者具体产品很少增加的情况。而对于复杂的业务环境不太适应。因此提出工厂方法模式。</p><h2 id="二、工厂方法模式："><a href="#二、工厂方法模式：" class="headerlink" title="二、工厂方法模式："></a>二、工厂方法模式：</h2><p>​       工厂方法模式是简单工厂的进一步延伸，这样说是因为简单工厂违反了开—闭原则，而工厂方法可以完美的解决这个问题。工厂方法不在工厂类中进行逻辑判断，程序可以为不同产品类提供不同的工厂。当使用工厂方法设计模式时，对象调用者需要与具体的工厂类耦合。</p><p>​      工厂方法模式的各个角色：</p><p>​       抽象工厂角色：工厂方法模式的核心，它与应用程序无关。是具体工厂必须实现的接口或者必须继承的父类他由抽象类或者接口来实现。</p><p>​       具体工厂角色：它含有和具体逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。</p><p>​       抽象产品角色：他是具体产品继承的父类或者是实现的接口。一般由抽象类或者接口来实现。</p><p>​       具体产品角色：具体工厂角色所创建的对象就是此角色的实例。由具体类实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//抽象产品</span><br><span class="line">public abstract class Car&#123;</span><br><span class="line">     public abstract  void Driver( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line">public class BenC&#123;</span><br><span class="line">       public void Driver( )&#123;</span><br><span class="line">            Console.WriteLine(&quot;奔驰&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line"></span><br><span class="line">public class BaoM&#123;</span><br><span class="line">       public void Driver( )&#123;</span><br><span class="line">            Console.WriteLine(&quot;宝马&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//抽象工厂</span><br><span class="line">public  abstract class Driver&#123;</span><br><span class="line">   public abstract Car DriverCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体工厂</span><br><span class="line">public class DriverBenC( )&#123;</span><br><span class="line">      public  Car DriverCar ()</span><br><span class="line">             Car  car=new BenC( );</span><br><span class="line">           return car;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体工厂</span><br><span class="line">public class DriverBaoM( )&#123;</span><br><span class="line">      public  Car DriverCar ()</span><br><span class="line">             Car  car=new BaoM( );</span><br><span class="line">         return car;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//客户代码</span><br><span class="line">public class Boss&#123;</span><br><span class="line">Driver d=new DriverBenC( );    </span><br><span class="line">Car car=d.DriverCar( );</span><br><span class="line"> car.Driver();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>优点：</p><p>（1）工厂方法用来创建客户所需要的产品，同时隐藏了哪种产品具体类将被实例化的细节，用户只需要关注工厂，不需要关注创建的细节。</p><p>（2）当产品增加时，只需要增加对应的工厂就好，完全符合开放封闭性原则。</p><p>缺点：</p><p>抽象层的加入使得理解程度加大。</p><h2 id="三、抽象工厂模式："><a href="#三、抽象工厂模式：" class="headerlink" title="三、抽象工厂模式："></a>三、抽象工厂模式：</h2><p>抽象工厂模式与工厂方法模式的区别就在于需要创建对象的复杂程度上。抽象工厂模式是三个里面最为抽象，最具有一般性的。用意在于给客户端提供一个接口，可以创建多个产品中的产品对象。</p><p>使用抽象工厂模式还要满足以下条件：</p><p>（1）系统中有多个产品族，而系统一次只可能消费其中一族产品。</p><p>（2）同属于同属于同一产品族的产品一起使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//抽象产品</span><br><span class="line">public abstract class BenC&#123;</span><br><span class="line">     public abstract  void Driver( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line">public class BenCSportCar&#123;</span><br><span class="line">      public void Driver( )&#123;</span><br><span class="line">          Console.WriteLine(&quot;奔驰&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line">public class BenCBusinessCar&#123;</span><br><span class="line">       public void Driver( )&#123;</span><br><span class="line">           Console.WriteLine(&quot;奔驰&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//抽象产品</span><br><span class="line">public abstract class BaoM&#123;</span><br><span class="line">     public abstract  void Driver( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line">public class BaoMSportCar&#123;</span><br><span class="line">       public void Driver( )&#123;</span><br><span class="line">            Console.WriteLine(&quot;宝马&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line">public class BaoM&#123;SportCar&#123;</span><br><span class="line">      public void Driver( )&#123;</span><br><span class="line">           Console.WriteLine(&quot;宝马&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//抽象工厂</span><br><span class="line">public  abstract class Driver&#123;</span><br><span class="line">   public abstract BenCCar DriverBenCCar();</span><br><span class="line">   public abstract BaoMCar DriverBenCCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//具体工厂</span><br><span class="line">public class SportDriver( )&#123;</span><br><span class="line">       public BenCCar  DriverBenCCar()&#123;</span><br><span class="line">               BenCSportCar  bencSport=new  BenCSportCar();</span><br><span class="line">               return   bencSport;</span><br><span class="line">        &#125;</span><br><span class="line">         public BaoMCar  DriverBaoMCar()&#123;</span><br><span class="line">             BaoMSportCar  baomSport=new  BaoMSportCar();</span><br><span class="line">                 return   baomSport;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//具体工厂</span><br><span class="line">public class BusinessDriver( )&#123;</span><br><span class="line">        public BenCCar  DriverBenCCar()&#123;</span><br><span class="line">       BenCSportCar  bencSport=new  BenCSportCar();</span><br><span class="line">        return   bencSport;</span><br><span class="line">         &#125;</span><br><span class="line">      public BaoMCar  DriverBaoMCar()&#123;</span><br><span class="line">       BaoMSportCar  baomSport=new  BaoMSportCar();</span><br><span class="line">       return   baomSport;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//客户代码</span><br><span class="line">public class Boss&#123;</span><br><span class="line">Driver d=new DriverBenC( );    </span><br><span class="line">Car car=d.DriverCar( );</span><br><span class="line"> car.Driver();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上可以发现，增加一个产品族很简单，而增加一个新的产品会很复杂。抽象工厂模式一般用于具有产品树和产品族的场景下。</p><p>补充：</p><p>1.单例模式，一个类只有一个实例存在。存在两种不同形式的单例：</p><p>第一种形式：饿汉式单例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">       private Singleton()&#123; &#125;</span><br><span class="line">       //在内部定义一个实例，private，只供内部使用。</span><br><span class="line">       private static Singleton instance =new Singleton();</span><br><span class="line">       //提供了一个供外部访问本class的静态方法，可以直接访问。</span><br><span class="line">       public static Singleton getInstance()&#123;</span><br><span class="line">                       return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：懒汉式单例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">       private  static  Singleton instace=null;</span><br><span class="line">       private Singleton()&#123;&#125;</span><br><span class="line">       public static  synchronized Singleton getInstance()&#123;</span><br><span class="line">       //比上面的方法有所改进，不用每次都进行声称对象，只是第一次使用时生成实例，提高了效率!</span><br><span class="line">              if(instance==null)  </span><br><span class="line">               instance =newSingleton();</span><br><span class="line">              return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例的特点：外界无法通过构造器来创建对象，该类必须提供一个静态方法向外界提供该类的唯一实例。</p><p>2.在开发中常用的设计模式</p><p>（1）工厂模式：工厂类可以根据条件生成不同的子类对象，这些子类有一个公共的抽象父类并且实现的相同的方法，但这些方法针对不同的数据进行了不同的操作。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。</p><p>（2）代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可分为：远程代理、虚拟代理、保护代理、Cache 代理、防火墙代理、同步化代理、智能引用代理。</p><p>（3）适配器模式：把一个类的接口变成客户所期待的另一种接口，从而使原本因接口不匹配而无法一起使用的类能够一起工作。</p><p>（4）模板方式模式：提供一个抽象类，将部分逻辑以具体方式或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 设计模式其实就是一套被反复使用的代码设计经验的总结。&lt;/p&gt;
&lt;p&gt; 使用设计模式的优点就是：代码可以重用，更容易被他人理解，保证代码的可靠性。&lt;/p&gt;
&lt;p&gt;Java中的设计模式以供有23种，包括：Abstract Factory（抽象工厂模式），Builder（建造者
      
    
    </summary>
    
      <category term="设计模式" scheme="https://minminminzhang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://minminminzhang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>关于RESTful的理解</title>
    <link href="https://minminminzhang.github.io/2018/cjqur6yqg000044nu64xv6sk4/"/>
    <id>https://minminminzhang.github.io/2018/cjqur6yqg000044nu64xv6sk4/</id>
    <published>2018-09-07T13:20:07.497Z</published>
    <updated>2018-12-13T13:12:20.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解RESTful的起因"><a href="#了解RESTful的起因" class="headerlink" title="了解RESTful的起因"></a>了解RESTful的起因</h1><p>学习springmvc的时候，在配置前端控制器<url-pattern></url-pattern>中时有三种方式：</p><p>第一种：*.action，访问一、以.action结尾由DispatcherServlet进行解析。</p><p>第二种：/，所有访问的地址由DispatcherServlet进行解析，对于静态文件的解析需要配置不让DispatcherServlet进行解析，使用此种方法可以实现RESTful风格的url。</p><p>第三种：/*，这样配置不对使用此种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错。</p><p>由此了解到Resultful架构。</p><h1 id="RESTful的介绍"><a href="#RESTful的介绍" class="headerlink" title="RESTful的介绍"></a>RESTful的介绍</h1><p>RESTful架构，就是目前最流行的一种互联网软件架构。具有结构清晰，符合标准，易于理解，扩展方便的优点。</p><h2 id="RESTful的起源"><a href="#RESTful的起源" class="headerlink" title="RESTful的起源"></a>RESTful的起源</h2><p>Roy Thomas Fielding 在2000年的博士论文提出来的。他在文中写到：“长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观评估不同的设计选择对系统行为的影响。而相反的，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽略的一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我写这篇问猴子那个的目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、事宜通信的架构。”</p><p>Roy Thomas Fielding 将他对互联网软件的架构原则，命名为REST，，即Representational State Transfer的缩写。可翻译 为“表现层状态转化”。要理解RESTful的架构，最好的方法就是去理解Representational State Transfer词组的意思。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>REST翻译为“表现层状态转化”，省略的主语，“表现层”其实指的是“资源”的“表现层”。</p><p>“资源”就是网络上的一个实体，或者说就是网络上的一个具体信息。可以是一短文本、一张图片、一首歌曲，总之就是一个具体的存在实体。可以用一个URI访问它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以。上网就是与互联网上一系列的“资源”互动，调用它的URI。</p><h2 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h2><p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把“资源”具体呈现出来的形式，叫做它的“表现层”。</p><p>比如：文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JSP格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。严格的说，有些网址最后的“.html”后缀名是不必要的，因为这个后缀名表示格式，属于“表现层”范围，而URL只代表“资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Context-Type字段指定，这两个字段才是对“表现层”的描述。</p><h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器发生“状态转换”。而这种转换你是建立在表现层之上的，所以就是“表现层状态转换”。</p><p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表现操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种操作：GET用来获取资源，POST用来新建资源（也可用来更新资源），PUT用来更新资源，DELETE用来删除资源。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综合以上学习，总结RESTful架构：</p><p>（1）每一个URI代表一种资源</p><p>（2）客户端和服务器之间，传递这种资源的表现层。</p><p>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现“表现层状态转换”。</p><h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><p>（1）URI不能包含动词</p><p>​     因为“资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p><p>例如：网上汇款，从账户1向账户2汇款200元</p><p>​                  POST /accounts/1/transfer/200/to/2/</p><p>正确的写法应该是：POST  /transaction  HTTP/1.1</p><p>​                                 Host: 127.0.0.1</p><p>​                                from=1&amp;to=2&amp;account=200.00</p><p>（2）在URI中不能加入版本号</p><p>​      <a href="http://www.example.com/app/1.0/foo" target="_blank" rel="noopener">http://www.example.com/app/1.0/foo</a></p><p>​     <a href="http://www.example.com/app/1.1/foo" target="_blank" rel="noopener">http://www.example.com/app/1.1/foo</a></p><p>​     <a href="http://www.example.com/app/2.0/foo" target="_blank" rel="noopener">http://www.example.com/app/2.0/foo</a></p><p>不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头的Accept字段中进行区分</p><p>Accept: vnd.example-com.foo+json; version=1.0</p><p>Accept: vnd.example-com.foo+json; version=1.1</p><p>Accept: vnd.example-com.foo+json; version=2.0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;了解RESTful的起因&quot;&gt;&lt;a href=&quot;#了解RESTful的起因&quot; class=&quot;headerlink&quot; title=&quot;了解RESTful的起因&quot;&gt;&lt;/a&gt;了解RESTful的起因&lt;/h1&gt;&lt;p&gt;学习springmvc的时候，在配置前端控制器&lt;url-pa
      
    
    </summary>
    
      <category term="RESTful架构" scheme="https://minminminzhang.github.io/categories/RESTful%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="RESTful架构和URI资源" scheme="https://minminminzhang.github.io/tags/RESTful%E6%9E%B6%E6%9E%84%E5%92%8CURI%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客</title>
    <link href="https://minminminzhang.github.io/2018/cjqur6ytr001g44nupaez5xbp/"/>
    <id>https://minminminzhang.github.io/2018/cjqur6ytr001g44nupaez5xbp/</id>
    <published>2018-09-07T07:09:45.688Z</published>
    <updated>2018-12-13T13:12:06.431Z</updated>
    
    <content type="html"><![CDATA[<p>​    对于一个认真的程序员，在学习过程中总要写Blog来记录学习过程中的点点滴滴。踩过的坑终将变成成功道路上的跳板。<br>    Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。经过搜索资料，不断学习，请教别人，最终搭建好了我的个人博客框架，在此写下整个过程分享。博文包括三个部分：构建基本框架、不断优化、补充内容。</p><p>​    </p><p>构建基本框架：从最简单的相关软件介绍到搭建完成属于自己的独立博客。不断优化：在完成简单的搭建之后，不断美化自己的页面展示。补充内容包括了Hexo的语法以及。。。。。。。</p><h1 id="构建基本框架："><a href="#构建基本框架：" class="headerlink" title="构建基本框架："></a>构建基本框架：</h1><hr><h2 id="基础准备："><a href="#基础准备：" class="headerlink" title="基础准备："></a>基础准备：</h2><p>&nbsp; &nbsp; &nbsp; &nbsp;<em>安装Git<br>&nbsp; &nbsp; &nbsp; &nbsp;将本地的Hexo提交到GitHub上进行管理<br>&nbsp; &nbsp; &nbsp; &nbsp;安装步骤：<br>&nbsp; &nbsp; &nbsp; &nbsp;1.在Git官网上(<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a>) 下载Windows版本。<br>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;2.下载完成后，双击.msi文件安装至G:\blogresoft\git。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>安装NodeJs<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hexo是基于NodeJs环境的静态博客，里面的npm工具很有用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装步骤：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.在Node.js官网(<a href="https://nodejs.org/en" target="_blank" rel="noopener">https://nodejs.org/en</a>) 下载最新版本。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      2.点击最新64位的8.11.4LTS版本下载到G盘新建的blogresoft文件夹下。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       3：双击.msi文件安装，不断点击next即可安装成功至G:\blogresoft\nodejs<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     <em>GitHub账号<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       没有GitHub账号的情况下,在官网页面注册一个新的即可。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    </em>配置SSH Keys<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       配置SSH Keys 之后,每次对自己的博客改动之后，提交的时候,不再需要重新输入GitHub的账号的密码了。<br>       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置步骤:在 G:\blogresoft\git文件夹下点击git-bash.exe，输入以下命令检查.ssh文件是否已经存在：     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure><p>不存在会出现提示：<br>       ls: cannot access ‘/c/User/Administrator/ .ssh’:No such file or directory</p><p>接着执行如下代码，生成.ssh文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir .ssh</span><br></pre></td></tr></table></figure><p>进入.ssh文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd  .ssh</span><br></pre></td></tr></table></figure><p>输入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C&quot;GitHub登陆邮箱&quot;</span><br><span class="line"></span><br><span class="line">$ id_rsa</span><br></pre></td></tr></table></figure><p>按回车键，提示是否使用长密码，按回车，继续按回车，不使用<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将ssh公钥部分添加到GitHub，.ssh文件夹下后缀名为.pub的文件是公钥，右键打开方式选择写字板打开，复制其中所有的内容。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在GitHub网站右上角点击setting。点击左侧SSH and GPG keys，点击右上角New SSH key，在Key中粘贴.ssh文件夹下后缀名为.pub的文件的所有内容，点击Add SSH key添加公钥，此时公钥状态为黑色。</p><p>在G:\blogresoft\git文件夹下双击git-bash.exe，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;usename&quot;</span><br><span class="line"></span><br><span class="line">$ git config --global user.email &quot;email&quot;</span><br></pre></td></tr></table></figure><p>其中usename为注册GitHub时的账户名，email为注册GitHub时的邮箱。<br>       输入如下命令，测试SSH是否配置成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>出现提示，输入yes回车，出现欢迎提示:<br>       Hi minminminzhang! Your’ve successfully authenticated,but GitHub does not provide shell access.</p><p>此时回到SSH and GPG keys处，公钥状态变为绿色。</p><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>​        在Git上新建一个仓库<br>        在GitHub上新建一个仓库，并取名为your_username.github.io，其中your_username是您自己的GitHub账号名。<br>        在本地写博客<br>        在G:/blogresoft/git文件夹下新建一个index.html文件，并输入一下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;</span><br><span class="line">            &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">      &lt;/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">            &lt;p&gt;你好！这是我的第一篇博客&lt;/p&gt;</span><br><span class="line">      &lt;/body&gt;          </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p> 用Git把index.html提交到GitHub上，在cmd中输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git init </span><br><span class="line"></span><br><span class="line">$ git add index.html</span><br><span class="line">   </span><br><span class="line">$ git commit  -m &quot;我的第一篇博客&quot;</span><br><span class="line"></span><br><span class="line">$ git remote add originhttps://github.com/your_username/your_username.github</span><br><span class="line"></span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p>在浏览器中输入your_username.github.io即可访问文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。</p><h2 id="hexo安装配置："><a href="#hexo安装配置：" class="headerlink" title="hexo安装配置："></a>hexo安装配置：</h2><p>*下载Hexo<br>         下载官网： <a href="http://hexo.io" target="_blank" rel="noopener">http://hexo.io</a><br>          github: <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a><br>          在G:/blogresoft/git文件夹下双击git-bash.exe</p><p> 输入以下命令进行安装Hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><p>在G:/blogresoft/git下安装文件夹hexo，并切换至Hexo工作目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd hexo</span><br></pre></td></tr></table></figure><p>初始化文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>安装hexo的扩展插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>安装其他插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git -save</span><br><span class="line">$ npm install hexo-renderer-ejs -save</span><br><span class="line">$ npm install hexo-renderer-stylus -save</span><br><span class="line">$ npm install hexo-render-marked -save</span><br></pre></td></tr></table></figure><p>生成静态页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>开启本地服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  hexo s</span><br></pre></td></tr></table></figure><p>会出现提示：<br>        INFO  Start processing<br>        INFO  Hexo is running at <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> . Press Ctrl+C to stop</p><p>此时：访问<a href="http://localhost:4000就可以看到刚刚创建的博客了。" target="_blank" rel="noopener">http://localhost:4000就可以看到刚刚创建的博客了。</a><br><strong>注意</strong>：若是无法访问，说明端口4000被占用了。可以输入如下的命令换端口试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s -p 5000</span><br></pre></td></tr></table></figure><p>更换后，访问<a href="http://localhost:5000进行查看。" target="_blank" rel="noopener">http://localhost:5000进行查看。</a><br> *部署Hexo：<br>         修改配置<br>         修改站点配置文件G:/blogresoft/git/hexo/_config.yml,修改deploy项的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo:  git@github.com:username/username.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p> <strong>注意</strong>：1.hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，称为站点配置文件，一个是各个theme下的，称为主题配置文件；<br>    2.type: repo: branch:分别和后面的内容之间有分隔<br>输入下面的命令将Hexo博客部署到GitHub中：<br>    清空静态页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p> 生成静态页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line"></span><br><span class="line">$ npm install hexo -deployer-git  -save</span><br></pre></td></tr></table></figure><p> 部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>在完成之后就可以访问<a href="https://minminminzhang.github.io,出现Hexo安装成功的页面提示。">https://minminminzhang.github.io,出现Hexo安装成功的页面提示。</a><br><strong>注意</strong>：我在最后一部配置的时候出现了仓库不存在的提示：<br>出现这种错误，有两种原因：<br>    1.修改站点文件时：仓库名输入有误<br>    2.在部署之前没有执行$ npm install hexo -deployer-git  -save<br>还有一种错误的情况由G:/blogresoft/git/hexo下的.deploy_git隐藏文件所致,删除这个隐藏文件即可。<br>完成之后进行重新部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line"></span><br><span class="line">$ hexo g</span><br><span class="line"></span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>重新访问进行验证。</p><h1 id="不断优化"><a href="#不断优化" class="headerlink" title="不断优化"></a>不断优化</h1><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p> Hexo中G:/blogresoft/git/hexo/themes/landscape默认的主题很简陋，我们可以换成更美观的。本博客选择Next主题，简单美观，好配置。<br>     下载主题：<br>      在Next发布页面(<a href="https://github.com/iissnan/hexo-theme-next/releases" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next/releases</a>) 下载最新版本hexo-theme-next-5.1.4。放在G:/blogresoft/git/hexo/themes文件夹下并改名为next。<br>启用主题<br>打开站点配置文件，在theme字段更改如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme： next</span><br></pre></td></tr></table></figure><p>主题安装完成，在切换之前，用hexo clean来清除hexo的缓存。</p><p>验证主题：<br>    启动Hexo本地站点，并开启调试模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo  s -debug</span><br></pre></td></tr></table></figure><p>出现提示：INFO Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>. Press Ctrl+C to stop </p><p>此时使用浏览器访问<a href="http://localhost:4000，检查Next安装是否成功。" target="_blank" rel="noopener">http://localhost:4000，检查Next安装是否成功。</a><br>Next安装成功之后的页面设置参考： <a href="https://blog.csdn.net/u012195214/article/details/79204088" target="_blank" rel="noopener">https://blog.csdn.net/u012195214/article/details/79204088</a></p><h2 id="写博客："><a href="#写博客：" class="headerlink" title="写博客："></a>写博客：</h2><p>定位到hexo根目录，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &apos;my first-blog&apos;</span><br></pre></td></tr></table></figure><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hexo会帮我们在 G:/blogresoft/git/hexo/source/_posts 下生成相关文件，我们只需要打开这个文件就可以开始写博客了。<br> 当然也可以在G:/blogresoft/git/hexo/source/_posts 直接创建后缀为.md的文件。使用命令的好处是帮我们自动生成了时间。</p><p> &nbsp;&nbsp;&nbsp;&nbsp;打开文件，除了在文章开头部分的一些参数，比如标题(title:) 、创建时间(date:) 等，正文部分使用Markdown格式书写:<br> <strong>注意：</strong>NexT默认主页显示文章的全部内容，这对于有些很长的文章来说非常不美观，建议主页仅显示文章的摘要。<br> 在合适的位置插入以下内容作为分隔符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ &lt;!--is more--&gt;</span><br></pre></td></tr></table></figure><p>分隔符以前的内容将会在索引页上显示为摘要。</p><h1 id="补充内容："><a href="#补充内容：" class="headerlink" title="补充内容："></a>补充内容：</h1><p> Hexo常用命令：  </p><p>npm install hexo -g #安装<br>npm update hexo -g #更新<br>hexo init #初始化<br>hexo publish [layout] <title> #发表草稿。<br>hexo n “name” #新建文章<br>hexo g #生成静态网页<br>hexo p #发表草稿。</title></p><p>hexo s #启动服务<br>hexo d #部署网站 参数：-g 部署之前先生成静态文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    对于一个认真的程序员，在学习过程中总要写Blog来记录学习过程中的点点滴滴。踩过的坑终将变成成功道路上的跳板。&lt;br&gt;    Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。经过搜索资料，不
      
    
    </summary>
    
      <category term="搭建个人博客" scheme="https://minminminzhang.github.io/categories/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="搭建个人博客相关技术" scheme="https://minminminzhang.github.io/tags/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
