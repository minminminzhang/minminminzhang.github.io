<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术博客</title>
  
  <subtitle>学习的点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://minminminzhang.github.io/"/>
  <updated>2019-08-16T11:34:00.057Z</updated>
  <id>https://minminminzhang.github.io/</id>
  
  <author>
    <name>张敏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>百度一面总结与分享</title>
    <link href="https://minminminzhang.github.io/2019/cjze1fwy20007cwnujwus9u3q/"/>
    <id>https://minminminzhang.github.io/2019/cjze1fwy20007cwnujwus9u3q/</id>
    <published>2019-08-16T09:41:47.769Z</published>
    <updated>2019-08-16T11:34:00.057Z</updated>
    
    <content type="html"><![CDATA[<p>面试岗位：基础平台开发<br>面试流程：自我介绍，最拿手的项目介绍，技术问答，面试官解疑</p><p>1.自我介绍<br>    自我介绍说了自己在校期间的学业成绩，参与的活动，项目和实习经历。完了之后面试官提问是否在校期间担任班干部职务，问的相对很详细。</p><p>2.最拿手的项目介绍<br>    我介绍了一个我自认为很了解参与最多的项目，面试官问了很多问题，虽然你都回答上来了，但我觉得他对个别问题的满意度不是很高，主要原因在于还是自己实践和企业应用之间的差别吧。</p><p>3.最重要的就是第三个环节：技术提问</p><p>(1).描述一下计算机的开机过程。<br>    1）当电源开关按下时，电源开始向主板和其他设备供电，电压不稳定时，主板会向CPU发出复位信号。稳定后,跳转到BIOS的启动代码处。<br>    2）BIOS进行加电自检，检测关键设备（如电源，CPU芯片，BIOS芯片，基本内存电路）供电情况是否良好。如果自检出了问题，系统喇叭会发出警报声。（根据警报声的长短和次数判断出现了什么问题）<br>    3）如果自检通过，BIOS会查找显卡BIOS，找到后会调用显卡BIOS的初始化代码，此时显示器就开始显示了（这就是为什么自检失败只能靠发声进行提醒了）。显卡BIOS会在屏幕上显示显卡的相关信息。<br>    4）显卡检测成功后会进行其他设备的检测，通过后系统BIOS重新执行自己的代码，并显示自己的启动画面，将相关信息显示在屏幕上，然后内存测试，短暂出现系统BIOS设置页面。设置后，会重新启动。<br>    5）BIOS检测系统的标准硬件，检测完成后会接着检测即插即用设备，如果有的话就为该设备分配中断、DMA通道和I/O端口等资源。到这里所有的设备检测就完成了，BIOS进行清屏并显示一个系统配置表。<br>    6）当上述所有的步骤都顺利进行以后，BIOS执行最后一项任务：按照用户指定的顺序进行启动（一般默认是硬盘，如果哦需要安装系统，还会设置为光驱或USB设备）。</p><p>(2).页面请求的工作流程。<br>    1）用户通过浏览器输入链接地址来请求所需的资源<br>    2）浏览器接收用户的请求，并把该请求组装成指定的格式发给服务器端，客户端与服务器端之间通过HTTP来完成具体的交互。其中请求的数据流主要包含HTTP，请求方法，请求的网址以及请求的一些参数信息。<br>    3）服务器接收到客户端发来的请求，并查找用户所需的资源。<br>    4）服务器查找到用户所需的资源，把该资源返回给客户端。<br>    5）服务器通过把响应消息组装成待定的消息格式后返回给客户端，这个过程通过HTTP完成。响应的数据流主要包括状态编码（代表请求成功或失败），Content-type（例如text，picture，HTML），响应消息的内容（图片或HTML格式的内容）。<br>    6）浏览器对HTML进行解析，并把响应结果展示给用户。</p><p>(3).说一下你对Java中GC的理解<br>   在java 中，垃圾回收主要的作用是会搜程序中不再使用的内存。在C/C++中，开发人员负责内存的分配和释放。Java语言提供了垃圾回收起来自动检测对象的作用域，可自动地把不再被使用的存储空间释放掉。<br>具体而言，主要完成3项任务：分配内存，确保被引用对象的内存不被错误的回收，回收不再被引用的对象的内存空间。</p><p><em>优点:减轻开发人员管理内存的负担，避免开发人员错误的操作内存导致应用程序的崩溃。<br>不足：为了实现垃圾回收，垃圾回收器必须跟踪内存的使用情况，释放没用的对象，在完成内存释放后还需要处理堆中的碎片，这些操作会增加JVM的负担，降低程序的执行效率。</em></p><p>如何确定一个对象是垃圾信息：没有任何变量去引用，不可能被程序访问。<br>对于垃圾回收器，它使用有向图记录和管理内存中的所有对象，通过这个有向图就可以识别哪些对象是可达的，（有引用变量引用它就是可达的），不可达的都是可被回收的。<br>垃圾回收都是依据一定的算法回收的：引用计数法，追踪回收算法，压缩回收算法，复制回收算法，按代回收算法。<br>具体的介绍两种：<br>①：引用计数法是一种简单但是效率低的方法，主要原理如下：在堆中对每一个对象都有一个引用计数器；对象被引用时，计数器加1；引用被置为空或离开作用域，减1。由于无法解决相互引用的问题，Jvm没有采取这个算法。<br>②：复制回收算法：把堆分成大小相同的区域，任何时刻只有其中的一个区域被使用，直到这个区域被消耗完为止，此时垃圾回收器会中断程序的执行，通过遍历的方式把所有活动的对象复制到另外一个区域中，在复制的过程中它们是紧挨着布置的，从而可以消除内存碎片。但复制过程结束后程序会接着运行，直到这块区域被使用完，然后再采取上面的方法继续进行垃圾回收。<br>优点是在进行垃圾回收的同时对对象的布置也进行了安排，从而消除了内存碎片。但也付出了很高的代价：对于指定大小的堆来说，需要两倍大小的内存空间；同时由于在内存调整的过程中要中断当前的执行程序，从而降低了程序的执行效率。<br>由于垃圾回收器的存在，Java没有给开发人员提供显式释放内存的方法，因此不能实时的调用垃圾回收器对某个对象进行回收。但可以通过调用System.gc（）方法通知回收，但是JVM也不会立马保证垃圾回收器运行，因为System.gc（）方法的执行会停止所有的程序响应，对程序的正常运行造成极大影响。因此不推荐频繁使用。</p><p>（4）.Xshell中删除一个文件夹，此内部包含很多不为空的文件夹。</p><pre><code>rm –rf </code></pre><p>（5）.K8s和docker之间的关系：<br>k8s：Kubernets是基于容器技术的分布式架构领先方案，docker是容器技术之一，核心在于实现应用与运行环境整体打包以及打包格式统一。k8s提供命令行和Rest API两种方式管理容器，命令行工具是Kubectl。具体来说：传统的虚拟技术，在将物理硬件虚拟成多套硬件后，需要在每套硬件上都部署一个操作系统，接着在这些操作系统上运行相应的应用程序。而Docker容器内的应用程序进程直接运行在宿主机(真实物理机)的内核上，Docker引擎将一些各自独立的应用程序和它们各自的依赖打包，相互独立直接运行于未经虚拟化的宿主机硬件上，同时各个容器也没有自己的内核，显然比传统虚拟机更轻便。每个集群有多个节点，每个节点可，我们的kuberbete就是管理这些应用程序所在的小运行环境而生。</p><p>4.面试官解疑<br>     在最后的环节我像他提问了两个问题：<br>     （1）基础平台开发和后台开发岗位之间的区别<br>     （2）今天提问环节的考查重点</p><pre><code>总结：百度的面试官态度还是很好的，回答不上来的问题他会进行不断的引导和提示，技术面感觉还是很爱提问网络基础相关的知识，问题（5）是基于个人的实习经历提问的，一面总的来说没有问到特别难的问题，如果基础扎实回答这些问题都很容易。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面试岗位：基础平台开发&lt;br&gt;面试流程：自我介绍，最拿手的项目介绍，技术问答，面试官解疑&lt;/p&gt;
&lt;p&gt;1.自我介绍&lt;br&gt;    自我介绍说了自己在校期间的学业成绩，参与的活动，项目和实习经历。完了之后面试官提问是否在校期间担任班干部职务，问的相对很详细。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="面试分享" scheme="https://minminminzhang.github.io/categories/%E9%9D%A2%E8%AF%95%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="经验分析" scheme="https://minminminzhang.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>实习总结与分享</title>
    <link href="https://minminminzhang.github.io/2019/cjze1fwy00006cwnu31kshnh3/"/>
    <id>https://minminminzhang.github.io/2019/cjze1fwy00006cwnu31kshnh3/</id>
    <published>2019-08-16T09:05:08.259Z</published>
    <updated>2019-08-16T11:43:05.116Z</updated>
    
    <content type="html"><![CDATA[<p>结束了为期四个月的实习，收获颇丰，现将经历总结如下。</p><p>实习岗位：开发工程师助理<br>实习部门：cloud &amp; AI产品与服务部门<br>实习主要内容：作为模块的第二接口负责人，参与基于PaaS平台的基础运维监控，主要是在K8S，Docker层面的项目开发。负责平台的运维监控模块，总结整理监控模块的代码和功能资料，后期进行PaaS平台运维监控模块的问题定位和解决，参与问题单处理，新需求开发等。</p><p>一，实习内容总结：<br>1.云计算基础了解和PaaS平台介绍<br>      云计算是指通过云共享分布式的资源。分为三层：顶端是SaaS（software-as-a-service）软件即服务；中间是PaaS（platForm-as-a-service）平台即服务，低端是IasS（Infrastructure-as-a-service）。<br>      Paas平台是研发团队和运维团队之间的桥梁，使得研发团队无需处理应用基础设施站，运维团队无需关注细节。<br>      主要作用是将一个开发和运行平台作为服务提供给客户，Iass的主要作用是提供虚拟机或者其他资源作为服务提供给用户。Saas大多只通过网页浏览器来接入的。</p><p>2.K8s和docker之间的关系：<br>    k8s：Kubernets是基于容器技术的分布式架构领先方案，docker是容器技术之一，核心在于实现应用与运行环境整体打包以及打包格式统一。k8s提供命令行和Rest API两种方式管理容器，命令行工具是Kubectl。具体来说：传统的虚拟技术，在将物理硬件虚拟成多套硬件后，需要在每套硬件上都部署一个操作系统，接着在这些操作系统上运行相应的应用程序。而Docker容器内的应用程序进程直接运行在宿主机(真实物理机)的内核上，Docker引擎将一些各自独立的应用程序和它们各自的依赖打包，相互独立直接运行于未经虚拟化的宿主机硬件上，同时各个容器也没有自己的内核，显然比传统虚拟机更轻便。每个集群有多个节点，每个节点可，我们的kuberbete就是管理这些应用程序所在的小运行环境而生。</p><p>二，实现体验<br>    1.实习单位离学校很远，每天早6：40就要起床赶公交，早起的习惯使得晚上不得不早睡。这样良好的作息习惯使我每天都精力充沛，果然自律的生活很重要。<br>    2.刚去公司的时候几乎什么都不懂，感觉学校和企业的差距还是很大的。要将在学校所学的只是应用到实践中去还要进一步的学习好多东西，只有不断学习才能保持进步。<br>     3.很多不懂的事情都需要向同事请教，刚开始我担心会打扰旁边同事的工作，于是碰到问题都是自己一直的探索，但是有的时候某个问题一天都解决不了，工作效率很低。于是后来，碰到问题的时候，设定一个思考的时间界限，要是到点了实在是想不出，就去请教。这样就会在思考的基础上多一些深刻的理解。有时候，处理问题不仅需要善于思考更需要一点前人的经验指导。</p><p>三，实习总结<br>    1.规范性和严谨性很重要。在处理业务时，不仅要符合代码的基本规范，更要遵守公司相关的规范标准。部门是一个大团队，在这个团队里每个人可能只需要负责一部分。如果因为自己负责的模块不规范，就会影响到整个团队。<br>    2.及时沟通交流。预估在规定时间不能完成的任务，要及时和模块负责人进行沟通协调，不能影响到整个团队的任务交付。<br>    3.善于总结。工作上处理的问题要及时总结输出为文档和博客，可以进行团队内分享，学习借鉴。<br>    4.工作中没有小事，都是大事。举一个例子，我刚开始去实习的时候，模块负责人走给我一个单子，是界面单词拼写错误，从表面看，我只需要找到相应的单词进行修改就OK了。但是如何去找这个问题，需要一步步进行定位，在定位的过程中需要进一步去熟悉我们的业务流程。这种小的错误就是会给客户带来不好的体验感，所以需要及时去改正。</p><pre><code>为期四个月的学习，不仅让我熟悉了公司的业务流程，锻炼了自己的能力，更是学到了有益的学习方法和为人处世的学问。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;结束了为期四个月的实习，收获颇丰，现将经历总结如下。&lt;/p&gt;
&lt;p&gt;实习岗位：开发工程师助理&lt;br&gt;实习部门：cloud &amp;amp; AI产品与服务部门&lt;br&gt;实习主要内容：作为模块的第二接口负责人，参与基于PaaS平台的基础运维监控，主要是在K8S，Docker层面的项目
      
    
    </summary>
    
      <category term="实习分享" scheme="https://minminminzhang.github.io/categories/%E5%AE%9E%E4%B9%A0%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="经验分享" scheme="https://minminminzhang.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>关于java多线程</title>
    <link href="https://minminminzhang.github.io/2019/cjze1fwxe0000cwnuadyb81be/"/>
    <id>https://minminminzhang.github.io/2019/cjze1fwxe0000cwnuadyb81be/</id>
    <published>2019-07-23T09:25:19.079Z</published>
    <updated>2019-07-23T10:34:20.635Z</updated>
    
    <content type="html"><![CDATA[<p>一.定义线程常用的两种方法：Thread类和Runnable接口</p><p>1.继承Thread类：定义一个线程继承Thread类。在Thread类中具有一个run方法，在定义的线程中需要重写这个方法。在重写的run方法，可以定义该线程所执行的语句。当线程启动时，run方法中的程序就成为一条独立的执行代码。</p><pre><code>public class XianCheng1 extends Thread{        public void run(){           System.out.println(&quot;通过继承Thread定义线程&quot;);         }}</code></pre><p>其中run方法可以被其他线程调用.run；但不能启动新线程。<br>创建线程：XianCheng1 xc = new XianCheng1();</p><p>2.实现Runnable接口：在Runnable接口中具有一个抽象的run方法，在实现Runnable接口时，需要实现该run方法。该run方法就作为一个执行线程的方法。</p><pre><code>public class XianCheng2 implements Runnable{       public void run(){          System.out.println(&quot;通过实现Runnable接口定义线程&quot;);       }   }  </code></pre><p>创建线程：XianCheng2 xc = new XianCheng2();<br>         Thread t=new Thread(xc);</p><p>一个正确启动的线程通过start启动。该线程和main并行。同时运行多个线程时，运行结果不是唯一的，因为有很多不确定元素。首先执行哪个线程就是不确定的，线程间交替也是不确定的。但是确定的是每一个线程都将启动，每一个线程都执行结束。</p><pre><code>注意：线程只能被启动一次，也就是只能调用一次start方法，多次调用就会发生异常。</code></pre><p>二.线程的生命周期分为五种不同状态：新建状态，准备状态，运行状态，等待/阻塞状态和死亡状态。</p><p>新建状态：当线程对象被创建<br>准备状态：启动start<br>运行状态：不可能再进入到新建状态<br>等待/阻塞状态：被解除后不可能进入运行状态，首先进入准备状态，让系统来选择。<br>死亡状态：线程中的run执行结束或程序发生异常终止运行后，进入死亡。处于死亡状态的线程不能再使用start启动线程。</p><p>单核cpu，同一时刻只有一个线程在运行。</p><p>三.线程调度方法</p><p>睡眠方法，设置优先级，让步方法<br>（1）睡眠方法：线程处于运行状态时，调用sleep，进入等待/阻塞状态，停止运行。sleep可以设置时间。当线程调用睡眠方法后，要想回到运行状态，需要的时间比长。</p><p>sleep方法重载，存在两种形式：</p><pre><code>public static void sleep(long millis) throws InterruptedException;(long millis,int nanos) 其中millis是睡眠的毫秒数，nanos是睡眠的纳秒数。</code></pre><p> sleep方法是一个静态方法，所以不依赖于某一对象，位置随意，执行sleep，不是调用sleep。sleep方法是可能发生捕获异常的，所以使用时必须进行异常处理。</p><pre><code>注意：sleep方法只是给线程一个调度建议，是否调度成功是不能确定的。</code></pre><p> （2）Java的优先级从1到10表示，数字越大表示优先级越高。如果没有设置则默认为5，但对于子线程来说，它的优先级和其父优先级相同。<br> 当对线程设置时，调用setPriority方法来设置。</p><pre><code>public final void setPriority(int i);</code></pre><p>i表示等级，1~10.还可以用MAX_PRIORITY表示最高级，NORM_PRIORITY默认优先级，MIN_PRIORITY表示低优先级。</p><p>（3）Java有两种线程让步方法。</p><p>1）yield方法。让线程让出当前的cpu，至于让给谁由系统决定。线程从运行状态进入到准备状态。yield方法可能不成功，线程进入准备状态后，但是线程有可能再次选择该线程进入运行状态。</p><pre><code>public static void yield();</code></pre><p>2)join方法让步给指定线程。</p><pre><code>public final void join() throws InterruptedException;                      (long millis)                    (long millis,int nanos)</code></pre><p>没有参数表示指定的线程执行完成后再执行其他线程，参数表示在参数的时间内执行让步给的执行线程。join可能发生捕获异常，要进行异常处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一.定义线程常用的两种方法：Thread类和Runnable接口&lt;/p&gt;
&lt;p&gt;1.继承Thread类：定义一个线程继承Thread类。在Thread类中具有一个run方法，在定义的线程中需要重写这个方法。在重写的run方法，可以定义该线程所执行的语句。当线程启动时，run
      
    
    </summary>
    
      <category term="java多线程" scheme="https://minminminzhang.github.io/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="学习总结" scheme="https://minminminzhang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>内部类及其和外部类之间的访问</title>
    <link href="https://minminminzhang.github.io/2019/cjze1fwxx0005cwnubs51qmec/"/>
    <id>https://minminminzhang.github.io/2019/cjze1fwxx0005cwnubs51qmec/</id>
    <published>2019-07-23T07:50:45.336Z</published>
    <updated>2019-07-23T09:01:50.409Z</updated>
    
    <content type="html"><![CDATA[<p> 一.内部类<br> 当一个类作为另一个类的非静态成员，则这个类就是一个非静态内部类。</p><pre><code>class Wai{       class Nei {           //内部成员类       }  //外部成员类      }</code></pre><p>   1.在内部类程序中，外部类访问内部类，只要把内部类看成一个类，然后创建该类的对象，使用对象调用内部类成员就好。但是不能直接创建内部类对象的，因为内部类只是外部类的一个成员。</p><pre><code>class Wai{    class Nei {        int i=5;    }    public void myVoid(){        Nei n =new Nei();        int j=n.i;        System.out.print(j);    }    public static void main(String args[]) {        Wai w=new Wai();        w.myVoid();    }}</code></pre><p>   外部类访问内部类语法：</p><pre><code>Wai.Nei wn= new Wai().new Nei();或 Wai w=new Wai();Wai.Nei wn=w.new Nei();</code></pre><p>2.在内部类中访问外部类，就像同一个类中成员互相访问一样，这样时没有限制的，包括将成员声明为private私有。</p><pre><code>class Wai{    int i=8;    class Nei {        public void myVoid(){            System.out.print(&quot;外部类中的成员变量为：&quot;+i);        }    }    blic static void main(String args[]) {        Wai w=new Wai();//创建外部类对象        Wai.Nei wn2=w.new Nei();//创建内部类对象        wn2.myVoid();  //调用内部类成员       }   }</code></pre><p>一个在内部类和外部类中具有同名称变量访问的程序。在内部类直接访问时，将访问的是内部类的成员变量。要想访问外部类成员变量，就需要创建一个外部类对象，然后使用该对象调用外部类成员变量。</p><p>二.局部内部类<br>1.将局部内部类定义在非静态方法中<br>  (1)局部内部类，只在局部中起作用。<br>  (2)在局部内部类中访问外部类成员变量，可以直接调用外部类的成员变量。<br>  (3)在局部内部类中访问外部类的局部成员变量，是不能直接访问的。必须将该外部类的局部成员变量必须声明为final。</p><p>2.将局部内部类定义在静态方法中<br>  (1)在静态方法中定义的局部内部类想要访问外部类中的成员，该程序必须是静态的。静态成员和非静态成员之间的访问是不变的。<br>  (2)在外部类中访问静态内部类和在外部类中访问非静态内部类是一样的。</p><pre><code>注意：因为静态内部类是外部类的静态成员，静态成员是不需要外部类对象而存在的。所以在外部类外，对静态内部类进行访问时是不需要创建外部类对象的。</code></pre><p>三.匿名内部类<br>匿名内部类没有名字，所以创建匿名内部类时同时创建匿名内部类的对象。</p><pre><code>new NeiFather{        //匿名内部类   }</code></pre><p>new NeiFather是匿名内部类继承的父类的类名，使用new同时创建匿名内部类对象。在匿名内部类中可以重写父类中的方法，自定义。</p><p>匿名内部类的初始化：匿名内部类没有名称，所以匿名内部类也不可能具有构造器。但有时在匿名内部类要定义成员变量，解决方法是创建一个非静态语句块，将所有的初始化的成员变量都放在该静态语句块中。这样在匿名内部类中的方法中就可以调用这样成员变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 一.内部类&lt;br&gt; 当一个类作为另一个类的非静态成员，则这个类就是一个非静态内部类。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Wai{
       class Nei {
           //内部成员类
       }
  //外部成员类
      }
&lt;/
      
    
    </summary>
    
      <category term="内部类及其和外部类之间的访问" scheme="https://minminminzhang.github.io/categories/%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%92%8C%E5%A4%96%E9%83%A8%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AE%BF%E9%97%AE/"/>
    
    
      <category term="学习总结" scheme="https://minminminzhang.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>实习之java如何简洁判空 </title>
    <link href="https://minminminzhang.github.io/2019/cjze1fwxo0002cwnu1m47qbyj/"/>
    <id>https://minminminzhang.github.io/2019/cjze1fwxo0002cwnu1m47qbyj/</id>
    <published>2019-03-10T01:25:19.957Z</published>
    <updated>2019-03-10T03:10:36.716Z</updated>
    
    <content type="html"><![CDATA[<p> 对于一个java程序员来说，对判空再熟悉不过了。为了避免出现“空指针异常”，我们会经常进行如下操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ( data!=null)&#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如果一个类中多次使用某个对象，就要操作多个像这样的判空语句。对于项目中无数次的判空，对代码质量整洁度产生了十分恶劣的影响，对于这种现象，我们称为“判空灾难”。</p><h3 id="1-NullObject模式"><a href="#1-NullObject模式" class="headerlink" title="1.NullObject模式"></a>1.NullObject模式</h3><p>在面向对象语言中，对对象的调用前需要使用判空检查，来判断这些对象是否为空，因为在空引用上无法调用所需方法。Nullable是空对象的相关操作接口，用于确定对象是否为空，因为在空对象模式中，对象为空会被包装成一个Object，称为Null Object，该对象会对所有的方法进行空实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Nullable&#123;</span><br><span class="line">     boolean isNull();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口定义了业务对象的行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface DependencyBase extends Nullable&#123;</span><br><span class="line">    void Operation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该对象的真实类，实现了业务行为接口DepandencyBase与空对象操作接口Nullable。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Dependency implements DependencyBase,Nullable&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void Operation()&#123;</span><br><span class="line">   System.out.print(&quot;Test!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override </span><br><span class="line">public boolean isNull()&#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是空对象，队员有对象的行为进行了空实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class NullObject implements DependencyBase&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void Operation()&#123;</span><br><span class="line">  // do nothing </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isNull()&#123;</span><br><span class="line"> return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用时，可以通过工厂调用方式来进行空对象的调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Factory&#123;</span><br><span class="line"> public static DependencyBase get(Nullable dependencyBase)&#123;</span><br><span class="line"></span><br><span class="line">   if(dependencyBase == null)&#123;</span><br><span class="line">    return new NullObject();</span><br><span class="line">   &#125;</span><br><span class="line">    return new Dependency();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种模式，我们不再需要进行对象的判空操作，而是可以直接使用对象，不必担心空指针异常的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Client&#123;</span><br><span class="line">       public void test(DependencyBase dependencyBase)&#123;</span><br><span class="line">           Factory.get(dependencyBase).Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-NR-Null-Object"><a href="#2-NR-Null-Object" class="headerlink" title="2.NR Null Object"></a>2.NR Null Object</h3><p>它是一款适用于IDEA的Intellij插件。其可以根据现有现象，便捷快速生成其空对象模式需要的组成成分，功能包括：分析所选类可声明为接口的方法；抽象出公有接口；创建控对象， 自动实现公有接口；对部分函数进行可为空声明；可追加汉书进行再次生成；自动的函数命名规范。</p><p>只需要在原有需要进行多次判空的对象中，右击弹出菜单，选择Generate，并选择NR Null Object即可自动生成相应的空对象组件。</p><p>获得这款插件的安装方式：可以直接通过IDEA的Preferences中的Plugins仓库进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 选择 Preferences → Plugins → Browse repositories</span><br><span class="line">&gt; 搜索“NR Null Oject”，点击右侧的Install，restart IDEA即可。</span><br></pre></td></tr></table></figure><h3 id="3-Optional"><a href="#3-Optional" class="headerlink" title="3.Optional"></a>3.Optional</h3><p>还有一种方式是使用Java8特性中的Optional来进行简洁判空，它是一个可能包含也可能不包含非null值的容器对象。 如果存在值，isPresent（）将返回true，get（）将返回该值。</p><p>举个例子，我们需要获得Test2中的Info信息，但是参数为Test4，我们要一层层的申请，每一层都获得的对象都可能是空，最后的代码看起来就像这样。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public String testSimple(Test4 test) &#123;</span><br><span class="line">       if (test == null) &#123;</span><br><span class="line">           return &quot;&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       if (test.getTest3() == null) &#123;</span><br><span class="line">           return &quot;&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       if (test.getTest3().getTest2() == null) &#123;</span><br><span class="line">           return &quot;&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       if (test.getTest3().getTest2().getInfo() == null) &#123;</span><br><span class="line">           return &quot;&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       return test.getTest3().getTest2().getInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是使用Optional后，整个就都不一样了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public String testOptional(Test test) &#123;</span><br><span class="line">       return Optional.ofNullable(test).flatMap(Test::getTest3)</span><br><span class="line">               .flatMap(Test3::getTest2)</span><br><span class="line">               .map(Test2::getInfo)</span><br><span class="line">               .orElse(&quot;&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>(1) Optional.ofNullable(test)，如果test为空，则返回一个单例空Optional对象，如果非空则返回一个Optional包装对象，Optional将test包装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123;</span><br><span class="line">     return value == null ? empty() : of(value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>(2) flatMap(Test::getTest3)判断test是否为空，如果为空，继续返回第一步中的单例Optional对象，否则调用Test的getTest3方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper) &#123;</span><br><span class="line">     Objects.requireNonNull(mapper);</span><br><span class="line">     if (!isPresent())</span><br><span class="line">         return empty();</span><br><span class="line">     else &#123;</span><br><span class="line">         return Objects.requireNonNull(mapper.apply(value));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>(3) flatMap(Test3::getTest2)同上调用Test3的getTest2方法</p><p>(4) map(Test2::getInfo)同flatMap类似，但是flatMap要求Test3::getTest2返回值为Optional类型，而map不需要，flatMap不会多层包装，map返回会再次包装Optional</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123;</span><br><span class="line">     Objects.requireNonNull(mapper);</span><br><span class="line">     if (!isPresent())</span><br><span class="line">         return empty();</span><br><span class="line">     else &#123;</span><br><span class="line">         return Optional.ofNullable(mapper.apply(value));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>(5)orElse(“”);获得map中的value，不为空则直接返回value，为空则返回传入的参数作为默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  public T orElse(T other) &#123;</span><br><span class="line">    return value != null ? value : other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Optional后我们的代码瞬间变得非常整洁，针对复杂的一长串判空，Optional有它的优势，但是对于简单的判空使用Optional也会增加代码的阅读成本、编码量以及学习成本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 对于一个java程序员来说，对判空再熟悉不过了。为了避免出现“空指针异常”，我们会经常进行如下操作。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;l
      
    
    </summary>
    
      <category term="java简洁判空" scheme="https://minminminzhang.github.io/categories/java%E7%AE%80%E6%B4%81%E5%88%A4%E7%A9%BA/"/>
    
    
      <category term="实习学习" scheme="https://minminminzhang.github.io/tags/%E5%AE%9E%E4%B9%A0%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>linux系统命令(3)</title>
    <link href="https://minminminzhang.github.io/2019/cjze1fwz1000ucwnunv3mxyct/"/>
    <id>https://minminminzhang.github.io/2019/cjze1fwz1000ucwnunv3mxyct/</id>
    <published>2019-01-22T09:52:42.717Z</published>
    <updated>2019-01-22T12:50:02.520Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统是多用户的，因此可能有多人同时使用这台主机来进行工作，为了考虑每个人的隐私权以及每个人喜好的工作环境，因此，“文件所有者”的角色就显得重要了。</p><h3 id="1-Linux文件属性"><a href="#1-Linux文件属性" class="headerlink" title="1.Linux文件属性"></a>1.Linux文件属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # ls -al</span><br><span class="line">drwx------   3   root   root    4096   Sep 5 10:37   .gconf</span><br><span class="line">-rw-r--r--   1   root   root   42304   Sep 4 18:26   install.log</span><br><span class="line">[    1   ]  [2]  [ 3 ]  [ 4 ]  [ 5 ]  [    6    ]   [    7     ]</span><br><span class="line">[  权限 ] [连接][ 所有者 ][ 用户组 ][ 文件容量 ][   修改日期  ][   文件名     ]</span><br></pre></td></tr></table></figure><h4 id="1-第一列代表这个文件的类型与权限"><a href="#1-第一列代表这个文件的类型与权限" class="headerlink" title="(1)第一列代表这个文件的类型与权限"></a>(1)第一列代表这个文件的类型与权限</h4><p>一共有10个字符，第一个字符代表这个文件是“目录，文件或链接文件等”。[d]  代表目录，[-]代表文件。接下来的字符串中，以3个为一组，且均为“rwx”的3个参数的组合，其中[r]代表可读，[w]代表可写，[x]代表可执行。要注意的是，这3个权限的位置不会改变，如果没有权限，就会出现减号[-]。</p><p>第一组为“文件所有者的权限”。</p><p>第二组为“同用户组的权限”。</p><p>第三组为“其他非本地用户的权限”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">- [r w x ][r - x ][r - -] </span><br><span class="line">1   2 3 4   5 6 7  8 9 0</span><br><span class="line">1:代表为文件</span><br><span class="line">234:拥有者的权限，可读可写可执行</span><br><span class="line">567:同用户组的权限，可读可执行不可写</span><br><span class="line">890:其他非本地用户的权限，不可读不可写不可执行</span><br></pre></td></tr></table></figure><h4 id="2-第二列表示有多少文件名连接到此节点"><a href="#2-第二列表示有多少文件名连接到此节点" class="headerlink" title="(2)第二列表示有多少文件名连接到此节点"></a>(2)第二列表示有多少文件名连接到此节点</h4><h4 id="3-第三列表示这个文件-或目录-的“所有着账号”"><a href="#3-第三列表示这个文件-或目录-的“所有着账号”" class="headerlink" title="(3)第三列表示这个文件(或目录)的“所有着账号”"></a>(3)第三列表示这个文件(或目录)的“所有着账号”</h4><h4 id="4-第四列表示这个文件所属的用户组"><a href="#4-第四列表示这个文件所属的用户组" class="headerlink" title="(4)第四列表示这个文件所属的用户组"></a>(4)第四列表示这个文件所属的用户组</h4><h4 id="5-第五列为这个文件的容量大小，默认单位为B"><a href="#5-第五列为这个文件的容量大小，默认单位为B" class="headerlink" title="(5)第五列为这个文件的容量大小，默认单位为B"></a>(5)第五列为这个文件的容量大小，默认单位为B</h4><h4 id="6-第六列为这个文件的创建日期或者最近修改的日期。"><a href="#6-第六列为这个文件的创建日期或者最近修改的日期。" class="headerlink" title="(6)第六列为这个文件的创建日期或者最近修改的日期。"></a>(6)第六列为这个文件的创建日期或者最近修改的日期。</h4><h4 id="7-第七列为改文件名。"><a href="#7-第七列为改文件名。" class="headerlink" title="(7)第七列为改文件名。"></a>(7)第七列为改文件名。</h4><h3 id="2-改变文件属性与权限"><a href="#2-改变文件属性与权限" class="headerlink" title="2.改变文件属性与权限"></a>2.改变文件属性与权限</h3><p>chgrp:改变文件所属用户组</p><p>chown:改变文件所有者</p><p>chmod:改变文件的权限</p><h4 id="1-改变所属用户组：chgrp"><a href="#1-改变所属用户组：chgrp" class="headerlink" title="(1)改变所属用户组：chgrp"></a>(1)改变所属用户组：chgrp</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # chgrp [-R] dirname/filename</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">[root@www ~] # chgrp users install.log   &gt;==install.log 所属用户组改为test</span><br><span class="line">[root@www ~] # chgrp testing install.log  &gt;==找不到用户组testing，不能改变。</span><br></pre></td></tr></table></figure><h4 id="2-chown-改变文件所有者"><a href="#2-chown-改变文件所有者" class="headerlink" title="(2)chown:改变文件所有者"></a>(2)chown:改变文件所有者</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例1：将install.log 的所有者改为bin</span><br><span class="line">[root@www ~] # chown bin install.log </span><br><span class="line"></span><br><span class="line">例2：将install.log 的所有者与用户组改为root</span><br><span class="line">[root@www ~] # chown root:root install.log</span><br></pre></td></tr></table></figure><h4 id="3-chmod-改变文件的权限"><a href="#3-chmod-改变文件的权限" class="headerlink" title="(3)chmod:改变文件的权限"></a>(3)chmod:改变文件的权限</h4><p>权限的设置方法有两种，数字或者符号。</p><h5 id="①数字类型改变文件权限"><a href="#①数字类型改变文件权限" class="headerlink" title="①数字类型改变文件权限"></a>①数字类型改变文件权限</h5><p>各权限的分数对照:               r:4, w:2,x:1</p><p>每种身份(owner,group,others)各自的权限是需要累加的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如当权限为[-rwxrwx---]</span><br><span class="line">owner=4+2+1=7</span><br><span class="line">group=4+2+1=7</span><br><span class="line">others=0+0+0=0</span><br><span class="line">因此设置权限更改时，该文件的权限数字就是770。</span><br><span class="line"></span><br><span class="line">例：将文件.bashrc的所有权限启用</span><br><span class="line">[root@www ~] # chmod 777 .bashrc</span><br></pre></td></tr></table></figure><h5 id="②符号类型改变文件权限"><a href="#②符号类型改变文件权限" class="headerlink" title="②符号类型改变文件权限"></a>②符号类型改变文件权限</h5><p>u,g,o分别代表三种身份(owner,group,others)，a代表all，也即全部的身份。读写权限可以写成r,w,x</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例1：</span><br><span class="line">[root@www ~] # chmod u=rwx,go=rx  .bashrc</span><br><span class="line">[root@www ~] # ls -al .bashrc</span><br><span class="line">-rwxr-xr-x  1 root root 395 Jul 4 11 :45 .bashrc</span><br><span class="line"></span><br><span class="line">例2：不知道原先文件的属性，现在增加.bashrc这个文件每个人均可写入的权限</span><br><span class="line">[root@www ~] # chmod a+w .bashrc</span><br><span class="line"></span><br><span class="line">例3：去掉全部人可执行的属性</span><br><span class="line">[root@www ~] # chmod a-x .bashrc</span><br></pre></td></tr></table></figure><h3 id="3-目录与文件的权限意义"><a href="#3-目录与文件的权限意义" class="headerlink" title="3.目录与文件的权限意义"></a>3.目录与文件的权限意义</h3><h4 id="1-权限对文件的重要性"><a href="#1-权限对文件的重要性" class="headerlink" title="(1)权限对文件的重要性"></a>(1)权限对文件的重要性</h4><p>文件是实际含有数据的地方，包括一般文件、数据库内容文件、二进制可执行文件等。因此权限对于文件来说，它的意义如下：</p><p>r(read)：可读取文件的实际内容，如读取文本文件的文字内容等。</p><p>w(write)：可以编辑、修改、新增文件的内容（但不包括删除该文件）。</p><p>x(execute)：该文件具有可以被执行的权限。在Windows下面，一个文件是否具有被执行的能力是通过“扩展名”来判断的，例如.exe,.bat,.com等，但在linxu里面文件能否执行则是由是否具有“x”这个权限来决定的，和文件名没有绝对的关系。</p><p>对于文件的r,w,x来说，主要是针对“文件的内容”而言，与文件名的存在与否没有关系的。</p><h4 id="2-权限对目录的重要性"><a href="#2-权限对目录的重要性" class="headerlink" title="(2)权限对目录的重要性"></a>(2)权限对目录的重要性</h4><p>目录主要的内容是记录文件名列表，文件名与目录有强烈的关联。</p><p>r(read contents in directory)：表示具有读取目录结构列表的权限，可以查询该目录下的文件名数据，可以利用ls这个命令将该目录的内容列表显示出来。</p><p>w(modify contents of directory)：具有更改目录结构列表的权限，具体如下：</p><p>​①新建新的文件与目录</p><p>②删除已经存在的文件与目录（不论该文件的权限如何）</p><p>③将已经存在的文档或者目录重命名</p><p>④转移该目录内的文件，目录位置。</p><p> 总之，目录的w权限就与该目录下的文件名变动有关。</p><p>x(access directory)：目录不可以被执行，目录的x代表的是用户能否进入该目录成为工作目录的用途，所谓的工作目录就是目前所在的目录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux系统是多用户的，因此可能有多人同时使用这台主机来进行工作，为了考虑每个人的隐私权以及每个人喜好的工作环境，因此，“文件所有者”的角色就显得重要了。&lt;/p&gt;
&lt;h3 id=&quot;1-Linux文件属性&quot;&gt;&lt;a href=&quot;#1-Linux文件属性&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="linux系统应用命令 " scheme="https://minminminzhang.github.io/categories/linux%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="应用命令" scheme="https://minminminzhang.github.io/tags/%E5%BA%94%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>linux系统进一步了解</title>
    <link href="https://minminminzhang.github.io/2019/cjze1fx8h002pcwnupg9ee62z/"/>
    <id>https://minminminzhang.github.io/2019/cjze1fx8h002pcwnupg9ee62z/</id>
    <published>2019-01-22T06:59:09.728Z</published>
    <updated>2019-01-22T12:45:14.652Z</updated>
    
    <content type="html"><![CDATA[<p>在学习了linux的基础和简单命令后，开始学习linux系统的目录与路径相关知识。我们之前学过切换目录的命令cd，以此进入文件路径。文件路径分为绝对路径和相对路径。</p><p>绝对路径：路径的写法一定是由根目录/泄气，例如/usr/share/doc这个目录。</p><p>相对路径：路径的写法不是由/写起，例如路径/usr/share/doc到路径/usr/share/man下面时，可以写成”cd../man”。相对路径指的是相对目前的工作目录。</p><h3 id="1-常见的处理目录命令"><a href="#1-常见的处理目录命令" class="headerlink" title="1.常见的处理目录命令"></a>1.常见的处理目录命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd:切换目录</span><br><span class="line">pwd:显示当前目录</span><br><span class="line">mkdir:新建一个新的目录</span><br><span class="line">rmdir:删除一个空的目录</span><br></pre></td></tr></table></figure><h4 id="1-cd-Change-Directory-切换目录"><a href="#1-cd-Change-Directory-切换目录" class="headerlink" title="(1)cd(Change Directory,切换目录)"></a>(1)cd(Change Directory,切换目录)</h4><p>在CentOS中创建的minner账号的主文件夹是/home/minner/,而root的主文件夹则是/root/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # cd</span><br><span class="line"># 进入相对路径或绝对路径</span><br><span class="line">[root@www ~] # cd ~minner</span><br><span class="line"># 去到minner用户的主文件夹，即/home/minner</span><br><span class="line">[root@www minner] # cd ~</span><br><span class="line"># 表示回到自己的文件夹，即/root这个目录</span><br><span class="line">[root@www ~] # cd</span><br><span class="line"># 没有加上任何路径，也代表回到自己主文件夹的意思</span><br><span class="line">[root@www ~] # cd ..</span><br><span class="line"># 表示去到上层目录，即/root的上层目录</span><br><span class="line">[root@www /] # cd -</span><br><span class="line"># 表示回到刚才的目录，即/root</span><br><span class="line">[root@www ~] # cd /var/spool/mail</span><br><span class="line"># 去到指定的绝对路径</span><br><span class="line">[root@www mail] # cd ../mqueue</span><br><span class="line"># 相对路径，从路径/var/spool/mail到路径/var/spool/mqueue</span><br></pre></td></tr></table></figure><p>注意:cd命令和目录名称之间存在一个空格。</p><h4 id="2-pwd（Print-Working-Directory-显示目前所在的目录）"><a href="#2-pwd（Print-Working-Directory-显示目前所在的目录）" class="headerlink" title="(2)pwd（Print Working Directory,显示目前所在的目录）"></a>(2)pwd（Print Working Directory,显示目前所在的目录）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # pwd [-p]</span><br><span class="line">参数：</span><br><span class="line">-p：显示当前路径</span><br><span class="line"></span><br><span class="line">例如：只显示当前的工作目录</span><br><span class="line">[root@www ~] # pwd</span><br><span class="line">/root   &lt;==显示出目录</span><br><span class="line"></span><br><span class="line">例：显示出实际的工作目录</span><br><span class="line">[root@www ~] # cd /var/mail</span><br><span class="line">[root@www ~] # pwd</span><br><span class="line">/var/mail       &lt;==列出目前的工作目录</span><br></pre></td></tr></table></figure><h4 id="3-mkdir-make-directory-新建新目录"><a href="#3-mkdir-make-directory-新建新目录" class="headerlink" title="(3)mkdir(make directory,新建新目录)"></a>(3)mkdir(make directory,新建新目录)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # cd /tmp</span><br><span class="line">[root@www ~] # mkdir test    &lt;==创建名为test的新目录</span><br><span class="line">[root@www ~] # mkdir test1/test2/test3    &lt;==无法直接创建多级目录</span><br><span class="line">[root@www ~] # mkdir -p test1/test2/test3   &lt;==利用-p，可以直接创建多级目录</span><br><span class="line">[root@www ~] # mkdir -m 711 test2  &lt;==利用-m，可以强制设置属性。如果没有m，则为默认属性</span><br></pre></td></tr></table></figure><h4 id="4-rmdir-删除空目录"><a href="#4-rmdir-删除空目录" class="headerlink" title="(4)rmdir(删除空目录)"></a>(4)rmdir(删除空目录)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # test   &lt;==可以直接删掉</span><br><span class="line">[root@www ~] # test1  &lt;==不能直接删掉，因为里面有内容</span><br><span class="line">[root@www ~] # -p test1/test2/test3  &lt;==加上参数-p，可以一次性删除</span><br></pre></td></tr></table></figure><h3 id="2-关于执行路径的变量：-PATH"><a href="#2-关于执行路径的变量：-PATH" class="headerlink" title="2.关于执行路径的变量：$PATH"></a>2.关于执行路径的变量：$PATH</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # echo $PATH   &lt;==以root身份列出查询的路径</span><br><span class="line">[root@www ~] # su - minner</span><br><span class="line">[minner@www ~] # echo $PATH   &lt;==以minner身份列出查询的路径</span><br></pre></td></tr></table></figure><h3 id="3-查看文件与目录"><a href="#3-查看文件与目录" class="headerlink" title="3.查看文件与目录"></a>3.查看文件与目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # ls [-aAdfFhilnrRSt] 目录名称</span><br><span class="line">[root@www ~] # ls [--color=&#123;never,auto,always&#125;] 目录名称</span><br><span class="line">[root@www ~] # ls [--full-time] 名称目录</span><br><span class="line">参数：</span><br><span class="line">-a：全部的文件，连用隐藏文件一同列出来</span><br><span class="line">-d：仅列出目录本身，而不是目录内的文件数据</span><br><span class="line">-l：列出长数据串，包含文件的属性与权限等数据</span><br><span class="line">--color=never        ：不要依据文件特性给予颜色显示</span><br><span class="line">--color=always       ：显示颜色</span><br><span class="line">--color=auto         ：让系统自行依据设置来判断是否给予颜色</span><br><span class="line">--full-time          ：以完整时间（包括年月日时分）模式输出</span><br><span class="line">--time=&#123;atime,ctime&#125; ：输出访问时间或改变权限属性时间而非内容更改时间</span><br><span class="line"></span><br><span class="line">[root@www ~] # ls -al ~    &lt;==目录文件都是以深蓝色显示</span><br><span class="line">[root@www ~] # ls -alF --color=never ~   &lt;==不显示颜色，但在文件夹名未显示出该文件夹代表的类型</span><br><span class="line">[root@www ~] # ls -al  --full-time ~   &lt;==完整呈现文件的修改时间</span><br></pre></td></tr></table></figure><h3 id="4-复制、删除与移动：cp-rm-mv"><a href="#4-复制、删除与移动：cp-rm-mv" class="headerlink" title="4.复制、删除与移动：cp,rm,mv"></a>4.复制、删除与移动：cp,rm,mv</h3><h4 id="1-cp-复制文件或目录"><a href="#1-cp-复制文件或目录" class="headerlink" title="(1) cp (复制文件或目录)"></a>(1) cp (复制文件或目录)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # cp [-adfilprsu] 源文件(source) 目标文件(destination) </span><br><span class="line"></span><br><span class="line">例1：</span><br><span class="line">[root@www ~] # cp ~/.bashrc /tmp/bashrc</span><br><span class="line">[root@www ~] # cp -i ~/.bashrc /tmp/bashrc</span><br><span class="line">cp: overwrite &apos;/tmp/bashrc&apos;?n &lt;==n 不覆盖，y为覆盖</span><br><span class="line"># 重复做两次操作，由于/tmp下面已经存在bashc了，加上-i参数后</span><br><span class="line"># 则在覆盖前会询问用户是否确定，可以按下n或者y来二次确认</span><br><span class="line"></span><br><span class="line">例2：切换目录到/tmp，并将/var/log/wtmp 复制到/tmp且查看属性:</span><br><span class="line">[root@www ~] # cd /tmp</span><br><span class="line">[root@www ~] # cp /var/log/wtmp . &lt;==想要复制到当前目录，最后的“.”不要忘记</span><br><span class="line">[root@www ~] # ls -l  /var/log/wtmp  wtmp</span><br><span class="line"></span><br><span class="line">例3：复制 /etc/ 这个目录下的所有内容复制到 /tmp下面</span><br><span class="line">[root@www ~] # cp /etc/ /tmp</span><br><span class="line">[root@www ~] # cp  -r /etc/ /tmp   &lt;==如果是目录不能直接复制，要加上-r参数</span><br></pre></td></tr></table></figure><h4 id="2-rm-移除文件"><a href="#2-rm-移除文件" class="headerlink" title="(2) rm(移除文件)"></a>(2) rm(移除文件)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # rm [-fir]文件或目录</span><br><span class="line"></span><br><span class="line">例1：将刚才在cp的范例中创建的bashrc删除掉</span><br><span class="line">[root@www ~] # cd /tmp</span><br><span class="line">[root@www tmp] # rm -i bashrc   &lt;==如果加上-i的参数就会主动询问，避免删除错误的文件名</span><br><span class="line"></span><br><span class="line">例2：通过*，将/tmp下面开头为bashrc的文件名全部删除</span><br><span class="line">[root@www tmp] # rm -i bashrc*    &lt;==*代表0到无穷多个任意字符</span><br><span class="line"></span><br><span class="line">例3：将cp范例中所创建的/tmp/etc/这个目录删除掉</span><br><span class="line">[root@www tmp] #  rmdir /tmp/etc     &lt;==删不掉，因为不是空目录</span><br><span class="line">[root@www tmp] #  rm -r  /tmp/etc    &lt;==加r删除</span><br><span class="line"></span><br><span class="line">例4：删除一个带有 - 开头的文件</span><br><span class="line">[root@www tmp] #  touch ./-aaa- &lt;==touch这个命令可以创建空文件</span><br><span class="line">[root@www tmp] #  rm -aaa-   &lt;==系统会误判</span><br><span class="line">[root@www tmp] #  rm ./-aaa-</span><br></pre></td></tr></table></figure><h4 id="3-mv-移动文件与目录，或更名"><a href="#3-mv-移动文件与目录，或更名" class="headerlink" title="(3)mv(移动文件与目录，或更名)"></a>(3)mv(移动文件与目录，或更名)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] mv  source destination</span><br><span class="line"></span><br><span class="line">例1：复制一个文件，创建一个目录，将文件移动到目录</span><br><span class="line">[root@www ~] # cd /tmp</span><br><span class="line">[root@www tmp] # cp ~/.bashrc bashrc </span><br><span class="line">[root@www tmp] # mkdir mvtest</span><br><span class="line">[root@www tmp] # mv bashrc mvtest</span><br><span class="line">#将文件移动到某个目录去</span><br><span class="line"></span><br><span class="line">例2：将刚才的目录名称重命名为mvtest2</span><br><span class="line">[root@www tmp] # mv mvtest mvtset2</span><br><span class="line"></span><br><span class="line">例3：再创建两个文件，再全部移动到/tmp/mvtest2当中</span><br><span class="line">[root@www tmp] # cp ~/.bashrc bashrc1</span><br><span class="line">[root@www tmp] # cp ~/.bashrc bashrc2</span><br><span class="line">[root@www tmp] # mv bashrc1 bashrc2 mvtest2</span><br><span class="line"># 注意，如果有多个源文件或目录，则最后一个一定是“目录”，将所有的数据移动到该目录</span><br></pre></td></tr></table></figure><h3 id="5-取得路径的文件名与目录名称"><a href="#5-取得路径的文件名与目录名称" class="headerlink" title="5.取得路径的文件名与目录名称"></a>5.取得路径的文件名与目录名称</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # basename /etc/sysconfig/network</span><br><span class="line">network      &lt;==取得最后的文件名</span><br><span class="line">[root@www ~] # dirname /etc/sysconfig/network</span><br><span class="line">/etc/sysconfig   &lt;==取得目录名</span><br></pre></td></tr></table></figure><h3 id="6-文件内容查询"><a href="#6-文件内容查询" class="headerlink" title="6.文件内容查询"></a>6.文件内容查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat: 由第一行开始显示文件内容</span><br><span class="line">tac: 从最后一行开始显示，可以看出tac是cat的倒写形式。</span><br><span class="line">nl: 显示的时候，顺便输出行号</span><br><span class="line">more: 一页一页地显示文件内容</span><br><span class="line">less: 与more类似，但是比more更好的是， 它可以往前翻页。</span><br><span class="line">head: 只看头几行</span><br><span class="line">tail: 只看结尾几行</span><br><span class="line">od: 以二进制的方式读取文件内容</span><br></pre></td></tr></table></figure><h4 id="1-cat-concatenate"><a href="#1-cat-concatenate" class="headerlink" title="(1)cat(concatenate)"></a>(1)cat(concatenate)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # cat [-AbEnTv]</span><br><span class="line">参数：</span><br><span class="line">-b： 列出行号，仅针对非空白部分</span><br><span class="line">-n： 打印出行号，连同空白处也会有行号</span><br><span class="line"></span><br><span class="line">例1:查看/etc/issue这个文件的内容</span><br><span class="line">[root@www ~] # cat /etc/issue</span><br><span class="line">[root@www ~] # cat -n /etc/issue    &lt;==加上行号</span><br><span class="line">[root@www ~] # cat -A /etc/issue    &lt;==将/etc/issue的内容完整的显示出来</span><br></pre></td></tr></table></figure><h4 id="2-tac-反向列示"><a href="#2-tac-反向列示" class="headerlink" title="(2) tac(反向列示)"></a>(2) tac(反向列示)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # tac  /etc/issue</span><br></pre></td></tr></table></figure><h4 id="3-nl-添加行号打印"><a href="#3-nl-添加行号打印" class="headerlink" title="(3)nl(添加行号打印)"></a>(3)nl(添加行号打印)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # nl [-bnw] 文件</span><br><span class="line"></span><br><span class="line">例1：</span><br><span class="line">[root@www ~] # nl /etc/issue   &lt;==空白处不显示行号</span><br><span class="line"></span><br><span class="line">[root@www ~] # nl --b /etc/issue  &lt;==空白处显示行号</span><br></pre></td></tr></table></figure><h4 id="4-可翻页查看"><a href="#4-可翻页查看" class="headerlink" title="(4)可翻页查看"></a>(4)可翻页查看</h4><p>more(一页一页翻动)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # more /etc/man.config</span><br></pre></td></tr></table></figure><p>more后面接的文件内容行数大于屏幕输出的行数时，可以一页一页的查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">空格键(Space)：代表向下翻一页</span><br><span class="line">enter        ： 代表向下滚动一行</span><br><span class="line">/字符串       ： 代表在这个显示的内容当中，相信爱查询“字符串”这个关键字</span><br><span class="line">:f           ： 立刻显示出文件名以及目前显示的行数</span><br><span class="line">q            ：代表离开more，不再显示该文件内容</span><br></pre></td></tr></table></figure><p>less(一页一页翻动)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # more /etc/man.config</span><br></pre></td></tr></table></figure><p>less比more更有弹性。在使用more的时候，并没有办法向前面翻，只能往后面看。但使用less的时候，可以向前和向后看。</p><h3 id="7-数据选取"><a href="#7-数据选取" class="headerlink" title="7.数据选取"></a>7.数据选取</h3><p>head和tail都是以“行”为单位来选取数据的。</p><h4 id="1-head-取出前面几行"><a href="#1-head-取出前面几行" class="headerlink" title="(1)head(取出前面几行)"></a>(1)head(取出前面几行)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # head [-n number] 文件</span><br><span class="line">参数：</span><br><span class="line">-n：后面接数字，代表显示几行的意思</span><br><span class="line"></span><br><span class="line">[root@www ~] # head /etc/man.config</span><br><span class="line"># 默认的情况中，显示前10行，若要显示前20行，就要如下执行命令：</span><br><span class="line">[root@www ~] # head -n 20 /etc/man.config</span><br><span class="line"></span><br><span class="line">例：如果后面100行数据都不打印，只打印 /etc/man.config的前面几行</span><br><span class="line">[root@www ~] # head -n -100 /etc/man.config</span><br></pre></td></tr></table></figure><h4 id="2-tail-取出后面几行"><a href="#2-tail-取出后面几行" class="headerlink" title="(2)tail (取出后面几行)"></a>(2)tail (取出后面几行)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # tail /etc/man.config</span><br><span class="line"># 默认的情况中，显示前10行，若要显示后20行，就要如下执行命令：</span><br><span class="line">[root@www ~] # tail -n 20 /etc/man.config</span><br><span class="line"></span><br><span class="line">例1：列出100行以后的数据</span><br><span class="line">[root@www ~] # tail -n +100 /etc/man.config</span><br><span class="line"></span><br><span class="line">例2：取出/etc/man.config的第11-20行</span><br><span class="line">[root@www ~] # head -n 20  /etc/man.config | tail -n 10</span><br></pre></td></tr></table></figure><p>补充：从自己创建的文件夹到root的主文件夹还可以用命令su</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习了linux的基础和简单命令后，开始学习linux系统的目录与路径相关知识。我们之前学过切换目录的命令cd，以此进入文件路径。文件路径分为绝对路径和相对路径。&lt;/p&gt;
&lt;p&gt;绝对路径：路径的写法一定是由根目录/泄气，例如/usr/share/doc这个目录。&lt;/p&gt;

      
    
    </summary>
    
      <category term="linux系统应用命令 " scheme="https://minminminzhang.github.io/categories/linux%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="应用命令" scheme="https://minminminzhang.github.io/tags/%E5%BA%94%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>接口本地测试正确 线上测试发生错误</title>
    <link href="https://minminminzhang.github.io/2019/cjze1fwy7000bcwnufud2e1pj/"/>
    <id>https://minminminzhang.github.io/2019/cjze1fwy7000bcwnufud2e1pj/</id>
    <published>2019-01-18T09:43:05.939Z</published>
    <updated>2019-01-19T02:20:20.752Z</updated>
    
    <content type="html"><![CDATA[<p>完成代码之后，在本地接口测试正确，但是发布到线上之后总是测试有问题。经过再三查找，总结如下：</p><h3 id="1-代码书写不严谨"><a href="#1-代码书写不严谨" class="headerlink" title="1.代码书写不严谨"></a>1.代码书写不严谨</h3><p>例如我在写邮件功能模块时的，根据id查询邮件记录的Controller层。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping (value = &quot;/getEmailRecordById&quot;,method = RequestMethod.POST)</span><br><span class="line">public  Object getEmailRecordById(</span><br><span class="line">        @RequestParam(value=&quot;id&quot;,required =false) Integer id</span><br><span class="line">)&#123;</span><br><span class="line">        String mailModel= String.valueOf(mailService.getEmailRecordById(id));</span><br><span class="line">        if(mailModel!=null)&#123;</span><br><span class="line">            return new AJAXResult(MsgCode.success);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return new AJAXResult(MsgCode.notexsit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试的时候发现，无论id为何值，每次返回的结果都是success。于是，在第五行之后加上打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;mailModel=&quot;+mailModel)</span><br></pre></td></tr></table></figure><p>输入id为数据库中不存在id时，发现mailModel并不等于null，而是等于”[ ]”，是一个空的数组。</p><p>因此要将判断条件改为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(mailModel!=&quot;[]&quot;)&#123;</span><br><span class="line">            return new AJAXResult(MsgCode.success);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return new AJAXResult(MsgCode.notexsit);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这样测试之后便得到正确结果。</p><h3 id="2-忽略临界条件"><a href="#2-忽略临界条件" class="headerlink" title="2.忽略临界条件"></a>2.忽略临界条件</h3><p>在写员工模块部分，根据员工名查找员工密码时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value=&quot;/getPasswordByName&quot;,method = RequestMethod.POST)</span><br><span class="line">  public Object getPasswordByName(</span><br><span class="line">          @RequestParam(value=&quot;name&quot;,required = false) String name</span><br><span class="line">          )&#123;</span><br><span class="line">          String employModel=employeeService.getPasswordByName(name);</span><br><span class="line">          if(employModel!=null)&#123;</span><br><span class="line">              return new AJAXResult(MsgCode.success);</span><br><span class="line">          &#125;else</span><br><span class="line">              return  new AJAXResult(MsgCode.notexsit);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当输入不存在的name时结果返回notexsit，输入正确的name时返回success。但是，忽略了未输入参数的情况。因此，可以将name的required改为true，这样name参数就是必须要传入的了。或者在判断条件else处再加上判断name是否为空。</p><h3 id="3-代码测试和数据库不一致"><a href="#3-代码测试和数据库不一致" class="headerlink" title="3.代码测试和数据库不一致"></a>3.代码测试和数据库不一致</h3><p>我在移植数据库的时候，出现了错误，导致数据库的好多存储值为null，因此导致了测试结果总是返回不存在。晚上线上数据库之后，发现测试正确了。因此在测试代码接口的时候，一定确保线上环境和数据库的一致性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;完成代码之后，在本地接口测试正确，但是发布到线上之后总是测试有问题。经过再三查找，总结如下：&lt;/p&gt;
&lt;h3 id=&quot;1-代码书写不严谨&quot;&gt;&lt;a href=&quot;#1-代码书写不严谨&quot; class=&quot;headerlink&quot; title=&quot;1.代码书写不严谨&quot;&gt;&lt;/a&gt;1.代码书
      
    
    </summary>
    
      <category term="线上 测试" scheme="https://minminminzhang.github.io/categories/%E7%BA%BF%E4%B8%8A-%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="接口发布测试" scheme="https://minminminzhang.github.io/tags/%E6%8E%A5%E5%8F%A3%E5%8F%91%E5%B8%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句优化</title>
    <link href="https://minminminzhang.github.io/2019/cjze1fwza0011cwnuiv46becs/"/>
    <id>https://minminminzhang.github.io/2019/cjze1fwza0011cwnuiv46becs/</id>
    <published>2019-01-18T08:30:14.973Z</published>
    <updated>2019-01-19T02:14:35.541Z</updated>
    
    <content type="html"><![CDATA[<p>当写代码初期的时候，SQL语句基本都关注正确性就可以了。但是随着将代码不断的应用，在这个过程中，SQL语句的优化就变的很重要，因为它关乎到程序执行的效率。因此，我们在Mapper中写sql语句时，要使用优质的SQL语句。以下是我在实践中学到的一些sql语句优化改进。</p><p>1.SQL语句中的in包含的值不应该过多</p><p>MySQL将in中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，运行的时候产生的消耗会很大。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num in(1,2,3)</span><br></pre></td></tr></table></figure><p>对于这种连续的数值，尽量用between，不要用in。</p><p>2、区分in和exists、not in和not exists</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表A where id in (select id from 表B)</span><br></pre></td></tr></table></figure><p>上面SQL语句相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表A where exists(select * from 表B where 表B.id=表A.id)</span><br></pre></td></tr></table></figure><p>区分in和exists主要是造成了驱动顺序的改变，如果是exists，那么以外层表为驱动表，先被访问，如果是in，那么先执行子查询。所以in适合于外表大而内表小的情况；exists适合于外表小而内表大的情况。关于not in和not exists，尽量使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select colname … from A表 where a.id not in (select b.id from B表)</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select colname … from A表 Left join B表 on where a.id = b.id where b.id is null</span><br></pre></td></tr></table></figure><p>3.is null或is not null操作（判断字符段是否为空）</p><p>索引不索引空值，因此判断字符段是否为空不会应用索引。任何包含null值的列都将不会被包含在索引中。当一个索引有多列时，但是只要这些列中有一列含有null，该列就会从索引中排除，即使对该列建索引也不会提高性能。 因此可以采用其它相同功能的操作运算代替，如：a is not null 改为 a&gt;0 等其他对等的条件。</p><p>4、尽量用union all代替union</p><p>union和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。当然，union all的前提条件是两个结果集没有重复数据</p><p>5、尽量不要使用%前缀模糊查询</p><p>例如LIKE“%name”或者LIKE“%name%”，这种查询会导致索引失效而进行全表扫描。但是可以使用LIKE “name%”。</p><p>6、避免在where子句中对字段进行表达式操作</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user_id,user_project from user_base where age*2=36;</span><br></pre></td></tr></table></figure><p>可以改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user_id,user_project from user_base where age=36/2;</span><br></pre></td></tr></table></figure><p>7.避免隐式类型转换</p><p>where子句中出现column字段的类型和传入的参数类型不一致的时候发生的类型转换，应该尽量确保一致。</p><p>8.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=10 or num=20</span><br></pre></td></tr></table></figure><p>可以这样查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=10 union all select id from t where num=20</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当写代码初期的时候，SQL语句基本都关注正确性就可以了。但是随着将代码不断的应用，在这个过程中，SQL语句的优化就变的很重要，因为它关乎到程序执行的效率。因此，我们在Mapper中写sql语句时，要使用优质的SQL语句。以下是我在实践中学到的一些sql语句优化改进。&lt;/p&gt;
      
    
    </summary>
    
      <category term="SQL语句优化 " scheme="https://minminminzhang.github.io/categories/SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="SQL语句优化" scheme="https://minminminzhang.github.io/tags/SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>linux系统初步了解</title>
    <link href="https://minminminzhang.github.io/2019/cjze1fwyz000scwnu5p4mt0yh/"/>
    <id>https://minminminzhang.github.io/2019/cjze1fwyz000scwnu5p4mt0yh/</id>
    <published>2019-01-13T08:27:42.514Z</published>
    <updated>2019-01-22T12:54:07.124Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习了有关于linux操作系统的基础以及相关指令，接下来做一介绍。linux系统是“多任务，多用户”，即主机上可以同时允许多人上线来工作，并且资源的分配较为公平。这也将存在一个问题：关机问题。在Windows系统中，由于是单用户，所以即使计算机关机，对于别人也不会有影响。但在Linux系统中，由于每个程序都是在后台执行的，因此，在你看不到的屏幕背后其实可能有很多人同时在你的主机上面工作，例如浏览网页，传送信件等，如果直接按下电源开关来关机，则其他人的数据可能就此终端了。</p><p>1.Linux登陆纯文本界面</p><p>Linux默认的情况下会提供6个Terminal来让用户登录，切换的方式为使用【Ctrl】+【Alt】+【F1】~【F6】的组合按钮。</p><p>系统将【F1】~【F6】命名为tty1~tty6的操作界面环境。按下【Ctrl】+【Alt】+【F7】转换到图形界面桌面。</p><p>按下【Ctrl】+【Alt】+【F1】来到tty1的登陆界面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CentOS release 5.3 (Final)</span><br><span class="line">Kernel 2.6.18-128.el5 on an i686</span><br><span class="line"></span><br><span class="line">www login: vbird</span><br><span class="line">Password:</span><br><span class="line">[minner@www~] $_</span><br></pre></td></tr></table></figure><p>(1).CentOS release 5.3 (Final)</p><p>显示Linux distribution的名称与版本</p><p>(2).Kernel 2.6.18-128.el5 on an i686</p><p>显示内核版本</p><p>(3).www login</p><p>主机名</p><p>(4).Password</p><p>密码，输入后不会显示</p><p>(5).[minner@www~] $_</p><p>登陆后，显示的正确信息。最左边的vbird显示的是当前用户的账号，而@之后接的www则是主机名。最右边的~则指的是“当前所在的目录”，那个$是提示符。</p><p>这样就已登陆主机了。</p><p>2.基本命令操作</p><p>(1)显示日期与时间：date</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[minner@www~] $ date</span><br><span class="line">Sun Jan 13 17:34:52 CST 2019</span><br></pre></td></tr></table></figure><p>上面显示为：星期天，1月13日，时间为17:34:52，在2019年的CTS时区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[minner@www~] $ date  +%Y/%m/%d</span><br><span class="line">2019/1/13</span><br><span class="line">[minner@www~] $ date  +%H:%M</span><br><span class="line">17:34</span><br></pre></td></tr></table></figure><p>(2)显示日历的命令：cal</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[minner@www~] $ cal</span><br><span class="line">January 2019</span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">      1  2  3  4  5</span><br><span class="line">6  7  8  9 10 11  12  </span><br><span class="line">13 14 15 16 17 18 19 </span><br><span class="line">20 21 22 23 24 25 26 </span><br><span class="line">27 28 29 30 31</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>[vbird@www~] $ cal [[month] year]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[minner@www~] $ cal 2019</span><br><span class="line">查询2019年所有日历</span><br></pre></td></tr></table></figure><p>基本的cal语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[minner@www~] $ cal [[month] year]</span><br></pre></td></tr></table></figure><p>(3)计算器：bc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[minner@www~] $ bc</span><br><span class="line">1+4+3    </span><br><span class="line">8</span><br><span class="line">10%3    </span><br><span class="line">1</span><br><span class="line">10/100 </span><br><span class="line">0</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><p>quit:离开计算器</p><p>在上文中10/100结果为0，因为bc默认输出整数，如果要输出全部小数，就要执行scale=number,number代表小数点后的位数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[minner@www~] $ bc</span><br><span class="line">scale=3     </span><br><span class="line">1/3</span><br><span class="line">.333</span><br><span class="line">34/100</span><br><span class="line">0.340</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><p>(2)改变支持语言</p><p>①显示目前所支持的语言</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[minner@www~] $ echo   $LANG  </span><br><span class="line">zh_CN.UTF-8</span><br></pre></td></tr></table></figure><p>上面的意思是目前的语言(LANG)为zh_CN.UTF-8</p><p>②修改语言为英文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[minner@www~] $ LANG=en__US</span><br><span class="line">[minner@www~] $ echo   $LANG  </span><br><span class="line">en__US</span><br></pre></td></tr></table></figure><p>再次确认，支持语言由汉语改成英语</p><p>3.正确关机</p><p>若不正常关机，则可能造成文件系统的毁损。</p><p>在正常情况下，关机要注意下面几件事：</p><p>(1)查看系统的使用状态</p><p>如果要谁在线，执行命令”who”。查看网络的联机状态，执行命令”netstat -a”。查看后台执行的程序，用命令“ps-aux”。</p><p>(2)通知在线用户关机的时刻</p><p>用shutdown这个命令来实现</p><p>Linux，除了以tty7图形界面来登陆系统，无论以什么身份都能够关机外，只有root有权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # /sbin/shutdown [-t秒]      时间 [警告消息]</span><br><span class="line">参数：</span><br><span class="line">-t sec:-t后面加秒数，表示几秒后关机</span><br><span class="line">-k    :不是真的关机，只是发送警告消息出去</span><br><span class="line">-r    :在将系统的服务停掉之后就重启</span><br><span class="line">-h    :将系统的服务停掉之后，立即关机</span><br><span class="line">-n    :不经过init程序，直接以shutdown来关机</span><br><span class="line">-f    :关机并开机之后，强制略过fsck的磁盘检查</span><br><span class="line">-F    :系统重启之后，强制进行fsck的磁盘检查</span><br><span class="line">-c    :取消已经在进行的shutdown命令内容</span><br><span class="line">时间  ：一定要加入的参数，指定系统关机的时间。</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~] # shutdown -h now</span><br><span class="line">立刻关机</span><br><span class="line"></span><br><span class="line">[root@www ~] # shutdown -h 20：25</span><br><span class="line">系统在今天的20：25关机。如果在超过20：25执行此命令，则隔天的20：25关机。</span><br><span class="line"></span><br><span class="line">[root@www ~] # shutdown -h +10</span><br><span class="line">十分钟后关机</span><br><span class="line"></span><br><span class="line">[root@www ~] # shutdown -r now</span><br><span class="line">系统立刻重启</span><br><span class="line"></span><br><span class="line">[root@www ~] # shutdown -r +30 &apos;The system will reboot&apos;</span><br><span class="line">再过三十分钟系统重启，将后面消息显示给所有用户</span><br><span class="line"></span><br><span class="line">[root@www ~] # shutdown -k now &apos;The system will reboot&apos;</span><br><span class="line">仅发出警告信件的参数，系统并不会关机</span><br></pre></td></tr></table></figure><p>4.补充</p><p>(1)[Tab]键具有命令补全和文件补齐功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[minner@www~] $ ca [Tab][Tab]</span><br><span class="line">执行这个命令以后，所有以ca开头的命令都被显示出来。</span><br><span class="line">[minner@www~] $ ls -al ~/.bash[Tab][Tab]</span><br><span class="line">所有以.bash开头的文件名都会被显示出来</span><br><span class="line">[Tab]接在一串命令的第一个命令之后，则为“命令补全”</span><br><span class="line">[Tab]接在一串命令的第二个命令之后，则为“文件补齐”</span><br></pre></td></tr></table></figure><p>(2)[Ctrl]-c可以停止运行，让程序停下来。</p><p>(3)[Ctrl]-d代表键盘输入结束。</p><p>(4)man page</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[minner@www~] $ man date</span><br><span class="line">执行这个命令查询到关于date命令的使用方法</span><br></pre></td></tr></table></figure><p>(5) man -f  man</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[minner@www~] $ man -f man</span><br><span class="line">执行这个命令后，输出的数据包括两部分。左部分是命令以及该命令代表的意义。右半部份是这个命令的简易说明。</span><br><span class="line">[minner@www~] $ man -f </span><br><span class="line">执行这个命令后，只会找到命令以及该命令代表的意义</span><br></pre></td></tr></table></figure><p>(6) man -k  man</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[minner@www~] $ man -k man</span><br><span class="line">只要有man的关键字都会列出来</span><br></pre></td></tr></table></figure><p>我们知道Linux中有很多的命令，但不用挨个去背。</p><p>一般遇到记不清楚的命令，可以这样查找：</p><p>首先：man+模糊命令，找相关的说明。然后：模糊命令+两次[Tab]键，查找以模糊命令开头的命令，查找到以后再去man查询命令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近学习了有关于linux操作系统的基础以及相关指令，接下来做一介绍。linux系统是“多任务，多用户”，即主机上可以同时允许多人上线来工作，并且资源的分配较为公平。这也将存在一个问题：关机问题。在Windows系统中，由于是单用户，所以即使计算机关机，对于别人也不会有影响
      
    
    </summary>
    
      <category term="linux系统应用命令 " scheme="https://minminminzhang.github.io/categories/linux%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="应用命令" scheme="https://minminminzhang.github.io/tags/%E5%BA%94%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>小顽童OA项目之邮件功能模块 </title>
    <link href="https://minminminzhang.github.io/2019/cjze1fx87002jcwnu3ntlonke/"/>
    <id>https://minminminzhang.github.io/2019/cjze1fx87002jcwnu3ntlonke/</id>
    <published>2019-01-05T07:40:54.611Z</published>
    <updated>2019-01-05T08:13:02.538Z</updated>
    
    <content type="html"><![CDATA[<p>我开发的第一部分是实现发送邮件的业务：实现简单邮件的发送，以及带图片，带附件的邮件发送。将每次发送邮件的记录进行保存，并且可以通过id，或者其他字段进行查询，修改，删除。</p><p>首先，第一步是实现邮件发送业务并保存记录：</p><p>在pom.xml中写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在application.properties进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.host=smtp.163.com</span><br><span class="line">spring.mail.username=minzhang1534781927@163.com</span><br><span class="line">spring.mail.password=468975520zm</span><br><span class="line">spring.mail.default-encoding=UTF-8</span><br><span class="line">spring.mail.port=25</span><br><span class="line">spring.mail.properties.mail.smtp.auth=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.enable=true</span><br><span class="line">spring.mail.properties.mail.smtp.starttls.required=true</span><br></pre></td></tr></table></figure><p>在Mapper层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package org.ppcirgo.oa.mapper;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.annotations.*;</span><br><span class="line">import org.ppcirgo.oa.beans.model.MailModel;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line">@Repository</span><br><span class="line">public interface MailMapper &#123;</span><br><span class="line"></span><br><span class="line">    //保存发邮件记录</span><br><span class="line">    @Insert(value=&quot;insert into emailRecord (sender,receiver,time,subject,status,content,password)  values(#&#123;sender&#125;,#&#123;receiver&#125;,#&#123;time&#125;,#&#123;subject&#125;,#&#123;status&#125;,#&#123;content&#125;,#&#123;password&#125;)&quot;)</span><br><span class="line">    int saveEmailRecord(MailModel mailModel);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在Service层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package org.ppcirgo.oa.service;</span><br><span class="line">import org.ppcirgo.oa.beans.model.MailModel;</span><br><span class="line"></span><br><span class="line">public interface MailService &#123;</span><br><span class="line"></span><br><span class="line">  //发送简单邮件</span><br><span class="line">  public MailModel sendSimpleMail(String from, String to, String subject, String content);</span><br><span class="line">  </span><br><span class="line">//发送带图片的邮件</span><br><span class="line">  public MailModel sendInilneMail(String from,String to, String subject, String content,String resPath,String resId);</span><br><span class="line">  </span><br><span class="line">  //发送带附件的邮件</span><br><span class="line">  public MailModel sendAttachmentMail(String from,String to,String subject,String content,String filePath);</span><br><span class="line">  </span><br><span class="line">  //保存发邮件记录</span><br><span class="line">  int saveEmailRecord(MailModel mailModel);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在ServiceImpl层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">package org.ppcirgo.oa.service.impl;</span><br><span class="line"></span><br><span class="line">import org.ppcirgo.oa.beans.model.MailModel;</span><br><span class="line">import org.ppcirgo.oa.mapper.MailMapper;</span><br><span class="line">import org.ppcirgo.oa.service.MailService;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.core.io.FileSystemResource;</span><br><span class="line">import org.springframework.mail.SimpleMailMessage;</span><br><span class="line">import org.springframework.mail.javamail.JavaMailSender;</span><br><span class="line">import org.springframework.mail.javamail.MimeMessageHelper;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import javax.mail.MessagingException;</span><br><span class="line">import javax.mail.internet.MimeMessage;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">@Service</span><br><span class="line">public class MailServiceImpl  implements MailService &#123;</span><br><span class="line"></span><br><span class="line">    private final Logger logger = LoggerFactory.getLogger(this.getClass());</span><br><span class="line">    @Autowired</span><br><span class="line">    private JavaMailSender mailSender;</span><br><span class="line">    @Autowired</span><br><span class="line">    private MailMapper mailMapper;</span><br><span class="line"></span><br><span class="line">    MailModel emailModel=new MailModel();</span><br><span class="line"></span><br><span class="line"> /*   </span><br><span class="line">     * 发送简单邮件</span><br><span class="line">     * @Param sender     邮件发送者</span><br><span class="line">     * @Param receiver   邮件接收者</span><br><span class="line">     * @Param content    邮件内容</span><br><span class="line">     */</span><br><span class="line">    public MailModel sendSimpleMail(String sender, String receiver, String subject, String content) &#123;</span><br><span class="line">        SimpleMailMessage message = new SimpleMailMessage();</span><br><span class="line">        message.setFrom(sender);</span><br><span class="line">        message.setTo(receiver);</span><br><span class="line">        message.setSubject(subject);</span><br><span class="line">        message.setText(content);</span><br><span class="line">        try &#123;</span><br><span class="line">            mailSender.send(message);</span><br><span class="line">            logger.info(&quot;简单邮件已经发送&quot;);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;发送邮件发生异常&quot;,e);</span><br><span class="line">        &#125;</span><br><span class="line">        return  emailModel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> /*   </span><br><span class="line">     * 发送嵌入静态资源（一般是图片）的邮件</span><br><span class="line">     * @Param sender     邮件发送者</span><br><span class="line">     * @Param receiver   邮件接收者</span><br><span class="line">     * @Param content    邮件内容，需要包括一个静态资源id，比如：&lt;img src=\&quot;cid:resId01\&quot;&gt;</span><br><span class="line">     * @Param resPath    静态资源路径和文件名</span><br><span class="line">     * @Param resId      静态资源id</span><br><span class="line">     */</span><br><span class="line">    public MailModel  sendInilneMail(String sender,String receiver, String subject, String content,String resPath,String resId)&#123;</span><br><span class="line">        MimeMessage message= mailSender.createMimeMessage();</span><br><span class="line">        try &#123;</span><br><span class="line">            //true表示需要创建一个multipart message</span><br><span class="line">            MimeMessageHelper helper=new MimeMessageHelper(message,true);</span><br><span class="line">            helper.setFrom(sender);</span><br><span class="line">            helper.setTo(receiver);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            helper.setText(content,true);</span><br><span class="line">            FileSystemResource res=new FileSystemResource(new File(resPath));</span><br><span class="line">            helper.addInline(resId,res);</span><br><span class="line">            mailSender.send(message);</span><br><span class="line">            logger.info(&quot;嵌入静态资源的邮件已经发送&quot;);</span><br><span class="line">        &#125; catch (MessagingException e) &#123;</span><br><span class="line">            logger.error(&quot;发送嵌入静态资源的邮件已经发生异常&quot;,e);</span><br><span class="line">        &#125;</span><br><span class="line">        return  emailModel;</span><br><span class="line">    &#125;</span><br><span class="line">   /*   </span><br><span class="line">     * 发送带附件的邮件</span><br><span class="line">     * @Param sender     邮件发送者</span><br><span class="line">     * @Param receiver   邮件接收者</span><br><span class="line">     * @Param content    邮件内容</span><br><span class="line">     * @Param filePath   附件路径</span><br><span class="line">     */</span><br><span class="line">   public MailModel  sendAttachmentMail(String sender,String receiver,String subject,String content,String filePath)&#123;</span><br><span class="line"></span><br><span class="line">        MimeMessage message=mailSender.createMimeMessage();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //true表示需要创建一个multipart message</span><br><span class="line">            MimeMessageHelper helper=new MimeMessageHelper(message,true);</span><br><span class="line">            helper.setFrom(sender);</span><br><span class="line">            helper.setTo(receiver);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            helper.setText(content,true);</span><br><span class="line">            FileSystemResource file=new FileSystemResource(new File(filePath));</span><br><span class="line">            String fileName=filePath.substring(filePath.lastIndexOf(File.separator));</span><br><span class="line">            helper.addAttachment(fileName,file);</span><br><span class="line">            mailSender.send(message);</span><br><span class="line">            logger.info(&quot;带附件的邮件已经发送&quot;);</span><br><span class="line">        &#125; catch (MessagingException e) &#123;</span><br><span class="line">            logger.error(&quot;发送带附件的邮件时发生异常&quot;,e);</span><br><span class="line">        &#125;</span><br><span class="line">          return  emailModel;</span><br><span class="line">    &#125;</span><br><span class="line">       @Override</span><br><span class="line">    public int saveEmailRecord(MailModel mailModel) &#123;</span><br><span class="line">        return  mailMapper.saveEmailRecord(mailModel);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在Controller层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package org.ppcirgo.oa.controller;</span><br><span class="line">import org.ppcirgo.oa.AJAXResult;</span><br><span class="line">import org.ppcirgo.oa.beans.model.MailModel;</span><br><span class="line">import org.ppcirgo.oa.service.MailService;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.mail.SimpleMailMessage;</span><br><span class="line">import org.springframework.mail.javamail.JavaMailSender;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class MailController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MailService mailService;</span><br><span class="line">    private String defaultStatus=&quot;1&quot;;//默认的发邮件状态</span><br><span class="line">   </span><br><span class="line"> //    简单邮件发送,并保存记录    </span><br><span class="line">    @RequestMapping(value=&quot;/sendSimpleEmail&quot;,method = RequestMethod.GET)</span><br><span class="line">    public Object sendSimpleMail(</span><br><span class="line">            @RequestParam(value=&quot;sender&quot;,required = false) String sender,</span><br><span class="line">            @RequestParam(value=&quot;receiver&quot;,required = false )String receiver,</span><br><span class="line">            @RequestParam(value=&quot;subject&quot;,required = false)  String subject,</span><br><span class="line">            @RequestParam(value=&quot;content&quot;,required = false)  String content</span><br><span class="line">    ) &#123;</span><br><span class="line">            MailModel mailModel=mailService.sendSimpleMail(sender,receiver,subject,content);</span><br><span class="line">            mailModel.setTime(DateUtlis.currentTime((System.currentTimeMillis())));</span><br><span class="line">            mailModel.setStatus(defaultStatus);</span><br><span class="line">         if(mailService.saveEmailRecord(mailModel)&gt;0)</span><br><span class="line">            return new AJAXResult(MsgCode.success);</span><br><span class="line">         else</span><br><span class="line">            return new AJAXResult(MsgCode.error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      //    带有附件的邮件</span><br><span class="line">    @RequestMapping(value=&quot;/sendInlineMail&quot;,method =RequestMethod.GET)</span><br><span class="line">    public Object sendInilneMail(</span><br><span class="line">            @RequestParam(value=&quot;sender&quot;,required = false) String sender,</span><br><span class="line">            @RequestParam(value=&quot;receiver&quot;,required = false )String receiver,</span><br><span class="line">            @RequestParam(value=&quot;subject&quot;,required = false)  String subject,</span><br><span class="line">            @RequestParam(value=&quot;content&quot;,required = false)  String content,</span><br><span class="line">            @RequestParam(value=&quot;resPath&quot;,required = false)  String resPath,</span><br><span class="line">           @RequestParam(value=&quot;resId&quot;,required = false)  String resId</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">        MailModel mailModel=mailService.sendInilneMail(sender, receiver, subject, content,resPath,resId);</span><br><span class="line">            mailModel.setTime(DateUtlis.currentTime((System.currentTimeMillis())));</span><br><span class="line">            mailModel.setStatus(defaultStatus);</span><br><span class="line"></span><br><span class="line">        if(mailService.saveEmailRecord(mailModel)&gt;0)</span><br><span class="line">            return new AJAXResult(MsgCode.success);</span><br><span class="line">        else</span><br><span class="line">            return new AJAXResult(MsgCode.error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 带有附件的邮件    </span><br><span class="line">    @RequestMapping(value=&quot;/sendAttachmentMail&quot;,method =RequestMethod.GET)</span><br><span class="line">    public Object sendAttachmentMail(</span><br><span class="line">            @RequestParam(value=&quot;sender&quot;,required = false) String sender,</span><br><span class="line">            @RequestParam(value=&quot;receiver&quot;,required = false )String receiver,</span><br><span class="line">            @RequestParam(value=&quot;subject&quot;,required = false)  String subject,</span><br><span class="line">            @RequestParam(value=&quot;content&quot;,required = false)  String content,</span><br><span class="line">            @RequestParam(value=&quot;filePath&quot;,required = false)  String filePath</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">        MailModel mailModel=mailService.sendAttachmentMail(sender, receiver, subject, content,filePath);</span><br><span class="line">        mailModel.setTime(DateUtlis.currentTime((System.currentTimeMillis())));</span><br><span class="line">        mailModel.setStatus(defaultStatus);</span><br><span class="line">        if(mailService.saveEmailRecord(mailModel)&gt;0)</span><br><span class="line">            return new AJAXResult(MsgCode.success);</span><br><span class="line">        else</span><br><span class="line">            return new AJAXResult(MsgCode.error);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在model中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package org.ppcirgo.oa.beans.model;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.ToString;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@ToString</span><br><span class="line">public class MailModel &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String sender;   //邮件发送者</span><br><span class="line">    private  String receiver;  //邮件接收者</span><br><span class="line">    private String time;      //邮件发送时间</span><br><span class="line">    private  String  subject;   //邮件主题</span><br><span class="line">    private String status;      //邮件发送状态  1：发送成功  0：发送失败</span><br><span class="line">    private String content;     //邮件内容</span><br><span class="line">    private  String password;   //找回密码时，系统产生的随机密码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了第一步，则通过id，或者其他字段进行查询，修改，删除邮件记录，将变得很简单。在Mapper层写Sql语句，Service层写接口，ServiceImpl层写实现Service层接口的类，最后在Controller进行Service的调用。</p><p>在Mapper层添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//根据发送者查找邮件内容</span><br><span class="line">@Select(value=&quot;select * from emailRecord where id=#&#123;id&#125;&quot;)</span><br><span class="line"> List&lt;MailModel&gt;  getEmailRecordById(@Param(&quot;id&quot;) Integer id);</span><br><span class="line"></span><br><span class="line">//根据标题查询邮件内容</span><br><span class="line">@Select(value=&quot;select * from emailRecord where subject  like  &apos;%$&#123;subject&#125;%&apos;&quot;)</span><br><span class="line"> List&lt;MailModel&gt; getEmailRecordBySubject(@Param(&quot;subject&quot;) String subject);</span><br><span class="line"></span><br><span class="line">//根据发送者修改邮件主题</span><br><span class="line">@Update(value = &quot; update emailRecord set subject=#&#123;subject&#125; where id=#&#123;sender&#125; &quot;)</span><br><span class="line">int updateEmailRecordBySender(@Param(&quot;subject&quot;) String subject, @Param(&quot;sender&quot;) String sender);</span><br><span class="line"></span><br><span class="line">//根据发送者改变发送邮件的state</span><br><span class="line">@Update(value=&quot; update emailRecord set status=#&#123;status&#125; where sender=#&#123;sender&#125;&quot;)</span><br><span class="line">int updateStatusById(@Param(&quot;status&quot;) String status  ,@Param(&quot;sender&quot;) String sender);</span><br><span class="line"></span><br><span class="line">//根据发送者删除邮件</span><br><span class="line">@Delete(value=&quot;delete from emailRecord where sender=#&#123;sender&#125;&quot;)</span><br><span class="line">int  deleteEmailRecordBySender(@Param(&quot;sender&quot;) String sender);</span><br></pre></td></tr></table></figure><p>其他层按照此格式书写代码。</p><p>这样就实现了一个OA项目完整的邮件功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我开发的第一部分是实现发送邮件的业务：实现简单邮件的发送，以及带图片，带附件的邮件发送。将每次发送邮件的记录进行保存，并且可以通过id，或者其他字段进行查询，修改，删除。&lt;/p&gt;
&lt;p&gt;首先，第一步是实现邮件发送业务并保存记录：&lt;/p&gt;
&lt;p&gt;在pom.xml中写入：&lt;/p
      
    
    </summary>
    
      <category term="邮件功能开发" scheme="https://minminminzhang.github.io/categories/%E9%82%AE%E4%BB%B6%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Springboot" scheme="https://minminminzhang.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>小顽童OA项目介绍 </title>
    <link href="https://minminminzhang.github.io/2019/cjze1fwz70010cwnug26kgwce/"/>
    <id>https://minminminzhang.github.io/2019/cjze1fwz70010cwnug26kgwce/</id>
    <published>2019-01-05T03:12:49.408Z</published>
    <updated>2019-01-19T02:33:54.127Z</updated>
    
    <content type="html"><![CDATA[<p>小顽童之OA项目介绍：基于一个员工在50-100的小型公司的背景，实现简洁办公自动化。具体要实现的功能有：</p><p>1.周计划（编辑/展示给某组或者部门）</p><p>2.月计划（编辑/展示给某组或者部门，计划书的完成进度跟踪，以及提醒及任务安排）</p><p>3.考勤管理（移动app考勤+人脸识别+定位+照片），考勤查询（矿工，请假，休假，正常，迟到）。</p><p>4.自动统计里程与绩效。</p><p>5.加盟管理（创建/编辑/删除某部门的方案，以及活动效果反馈）</p><p>6.导出相关表单为excel文件（如消费者的详细信息）</p><p>7.公司事物通知</p><p>8.公司邮件</p><p>9.移动办公支持</p><p>10.会展示一个页面给商家，进行反馈，以及提交需求和建议。同时可以展示公司近期的活动安排。</p><p>11.提供管理小顽童项目的接口（上架下架产品）</p><p>小顽童之OA项目使用了Springboot轻量级框架，这也是现在企业较为常用的框架。Springboot是Spring框架的集成，相比于Spring框架，Springboot框架除了拥有Spring框架的功能外，配置很简单。只要在pom.xml文件中添加相关依赖，maven可以自动下载。不用担心jar包版本之间的依赖冲突了。开发效率很高。</p><p>搭建Springboot框架所需要的前提</p><p>①jdk8-jdk11  ②Maven3.3  ③Tomcat9.0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;小顽童之OA项目介绍：基于一个员工在50-100的小型公司的背景，实现简洁办公自动化。具体要实现的功能有：&lt;/p&gt;
&lt;p&gt;1.周计划（编辑/展示给某组或者部门）&lt;/p&gt;
&lt;p&gt;2.月计划（编辑/展示给某组或者部门，计划书的完成进度跟踪，以及提醒及任务安排）&lt;/p&gt;
&lt;p&gt;3
      
    
    </summary>
    
      <category term="相关技术" scheme="https://minminminzhang.github.io/categories/%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Springboot" scheme="https://minminminzhang.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>一道关于顺时针打印矩阵的常见算法题</title>
    <link href="https://minminminzhang.github.io/2018/cjze1fwz4000xcwnu9ok33cof/"/>
    <id>https://minminminzhang.github.io/2018/cjze1fwz4000xcwnu9ok33cof/</id>
    <published>2018-12-21T13:28:29.079Z</published>
    <updated>2019-01-19T02:33:38.837Z</updated>
    
    <content type="html"><![CDATA[<p>描述如下：</p><p>假设有一个4*4的矩阵，具体为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1        2       3       4  </span><br><span class="line"></span><br><span class="line">5        6       7       8  </span><br><span class="line"></span><br><span class="line">9       10       11      12</span><br><span class="line"></span><br><span class="line">13      14       15      16</span><br></pre></td></tr></table></figure><pre><code>需要顺时针打印这个矩阵，上面输出的结果应该为：【1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10】。</code></pre><p>考虑将函数的输入当作是一个二维数组（表示矩阵），返回值是矩阵的打印顺序集合。顺时针打印需要明确以下两点：</p><p>（1）知道当前打印到哪一行和哪一列了</p><p>（2）不能出现越界和重复打印</p><p> 对于第一点，定义两个变量row和col指向当前打印的行和列即可；第二点，顺时针打印其实是一圈一圈的打印，打印过程中的任何一次顺时针打印圈都可以用四个变量唯一确定。当前圈的第一行和最后一行，当前圈的最左一列和最右一列。越界问题其实就是要限定row和col变量的取值范围。</p><p>具体的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"> /**</span><br><span class="line">  *top：当前打印圈的第一行；left：当前打印圈的最左列；bottom：当前打印圈的最后一行；right：当前打印圈的最</span><br><span class="line">  *右边一列。top和bottom是用来限定row的取值范围；left和right是用来限定col的取值范围。</span><br><span class="line">  * @param matric</span><br><span class="line">  */</span><br><span class="line">public class printMatric &#123; </span><br><span class="line">    public printMatric(int[][] matric) &#123;</span><br><span class="line">        if (matric == null) &#123;</span><br><span class="line">            System.out.print(&quot;矩阵为空！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //获取矩阵的行和列</span><br><span class="line">        int row = matric.length;</span><br><span class="line">        int col = matric.length;</span><br><span class="line"></span><br><span class="line">        //保存待返回的结果集</span><br><span class="line">        ArrayList&lt;Integer&gt; res = new ArrayList(row * col);</span><br><span class="line">        </span><br><span class="line">        int top = 0, left = 0, bottom = row - 1, right = col - 1;</span><br><span class="line">        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">        </span><br><span class="line">            //从左到右</span><br><span class="line">            for (int m = left; m &lt;= right; m++) &#123;</span><br><span class="line">                res.add(matric[top][m]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">           //从上到下</span><br><span class="line">            for (int m = top + 1; m &lt;=bottom; m++) &#123;</span><br><span class="line">                res.add(matric[m][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            //从右到左</span><br><span class="line">            //只剩一行时，从左到右和从右到左打印的是同一行</span><br><span class="line">            if (top != bottom) &#123;</span><br><span class="line">                for (int m = right - 1; m &gt;= left; m--) &#123;</span><br><span class="line">                    res.add(matric[bottom][m]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           //从下到上</span><br><span class="line">            if (right != left) &#123;</span><br><span class="line">                for (int m = bottom - 1; m &gt; top; m--) &#123;</span><br><span class="line">                    res.add(matric[m][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //为下一圈打印做准备</span><br><span class="line">            top++;</span><br><span class="line">            left++;</span><br><span class="line">            bottom--;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">            System.out.print(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">       int[][] matric = new int[][]&#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125;, &#123;13, 14, 15, 16&#125;&#125;;</span><br><span class="line">        printMatric printMatric = new printMatric(matric);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试之后得到的打印结果是：【1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10】。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;描述如下：&lt;/p&gt;
&lt;p&gt;假设有一个4*4的矩阵，具体为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span
      
    
    </summary>
    
      <category term="算法应用" scheme="https://minminminzhang.github.io/categories/%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="算法应用" scheme="https://minminminzhang.github.io/tags/%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>用迭代算法解决汉诺塔问题</title>
    <link href="https://minminminzhang.github.io/2018/cjze1fwyv000ocwnuui02x30e/"/>
    <id>https://minminminzhang.github.io/2018/cjze1fwyv000ocwnuui02x30e/</id>
    <published>2018-12-13T13:34:16.437Z</published>
    <updated>2018-12-13T13:35:47.249Z</updated>
    
    <content type="html"><![CDATA[<p>   汉诺塔游戏可以简单描述为：n个盘子和3根柱子：A(起始柱子)、B(过渡柱子)、C(目的柱子)，盘子的大小不同且中间有一孔，可以将盘子“串”在柱子上，每个盘子只能放在比它大的盘子上面。起初，所有盘子在A柱上，问题是将盘子一个一个地从A柱子移动到C柱子。移动过程中，可以使用B柱，但盘子也只能放在比它大的盘子上面。</p><p>因此我们得出汉诺塔问题的以下几个限制条件：</p><p>1.在小圆盘上不能放大圆盘。</p><p>2.在三根柱子之间一回只能移动一个圆盘。</p><p>3.只能移动在最顶端的圆盘。</p><p>首先，我们从简单的例子开始分析，然后再总结出一般规律：</p><p>1.当n=1的时候，即此时只有一个盘子，那么直接将其移动至C即可。移动过程就是 A -&gt; C</p><p>2.当n=2的时候，这时候有两个盘子，那么在一开始移动的时候，我们需要借助B柱作为过渡的柱子，即将A柱最上面的那个小圆盘移至B柱，然后将A柱底下的圆盘移至C柱，最后将B柱的圆盘移至C柱即可。那么完整移动过程就是A -&gt; B , A -&gt; C , B -&gt; C</p><p>3.当n=3的时候，那么此时从上到下依次摆放着从小到大的三个圆盘，根据题目的限制条件：在小圆盘上不能放大圆盘，而且把圆盘从A柱移至C柱后，C柱圆盘的摆放情况和刚开始A柱的是一模一样的。所以呢，我们每次移至C柱的圆盘（移至C柱后不再移到其他柱子上去），必须是从大到小的，即一开始的时候，我们应该想办法把最大的圆盘移至C柱，然后再想办法将第二大的圆盘移至C柱……然后重复这样的过程，直到所有的圆盘都按照原来A柱摆放的样子移动到了C柱。</p><p>那么根据这样的思路，思考如何才能够将最大的盘子移至C柱？</p><p>要将最大的盘子移至C柱，那么必然要先搬掉A柱上面的n-1个盘子，而C柱一开始的时候是作为目标柱的，所以我们可以用B柱作为”暂存”这n-1个盘子的过渡柱，当把这n-1的盘子移至B柱后，我们就可以把A柱最底下的盘子移至C柱了。</p><p>我们来看看现在各个柱子上盘子的情况，A柱上无盘子，而B柱从上到下依次摆放着从小到大的n-1个盘子，C柱上摆放着最大的那个盘子。</p><p>所以接下来那就是要把B柱这剩下的n-1个盘子移至C柱，那么我们需要借助A柱，将A柱作为新的”过渡”柱，B柱为初始柱，将这n-1个盘子移至目标C柱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HanoiTower&#123;</span><br><span class="line">    topN：移动的盘子数</span><br><span class="line">    from：初始柱子</span><br><span class="line">    to：目的柱子</span><br><span class="line">    inter：过渡柱子</span><br><span class="line">    public static void  doTower(int topN,char from,char inter ,char to)&#123;</span><br><span class="line">          if(topN==1)&#123;</span><br><span class="line">               System.out.println(&quot;盘子1，从”+from+“柱子到”+to+&quot;柱子&quot;);</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">               doTower(topN-1,from,to ,inter);</span><br><span class="line">               System.out.println(&quot;盘子&quot;+topN+&quot;，从&quot;+from+“柱子到”+to+&quot;柱子&quot;);</span><br><span class="line">                doTower(topN-1,inter,from ,to);</span><br><span class="line">          &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TestHanoiTower&#123;</span><br><span class="line">        public class void main(String [] args)&#123;</span><br><span class="line">                 HanoiTower.doTower(3,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>​    程序结果为：盘子1，从A柱子到C柱子</p><pre><code>盘子2，从A柱子到B柱子盘子1，从C柱子到B柱子盘子3，从A柱子到C柱子盘子1，从B柱子到A柱子盘子2，从B柱子到C柱子盘子1，从A柱子到C柱子</code></pre><p>即我们用迭代算法解决了汉诺塔问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   汉诺塔游戏可以简单描述为：n个盘子和3根柱子：A(起始柱子)、B(过渡柱子)、C(目的柱子)，盘子的大小不同且中间有一孔，可以将盘子“串”在柱子上，每个盘子只能放在比它大的盘子上面。起初，所有盘子在A柱上，问题是将盘子一个一个地从A柱子移动到C柱子。移动过程中，可以使
      
    
    </summary>
    
      <category term="迭代算法" scheme="https://minminminzhang.github.io/categories/%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="汉诺塔" scheme="https://minminminzhang.github.io/tags/%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    
  </entry>
  
  <entry>
    <title>java中常用的注解总结 </title>
    <link href="https://minminminzhang.github.io/2018/cjze1fwym000icwnuiwwbipr1/"/>
    <id>https://minminminzhang.github.io/2018/cjze1fwym000icwnuiwwbipr1/</id>
    <published>2018-12-13T08:33:40.644Z</published>
    <updated>2018-12-13T13:23:41.955Z</updated>
    
    <content type="html"><![CDATA[<p>注解就是源代码的元数据。</p><p>1.声明bean的注解</p><p>@Conponent组件，当组件不好归类的时候，我们可以使用这个注解进行标注</p><p>@Service在业务逻辑层使用（service层）</p><p>@Reponsitory在数据访问层使用（dao层）</p><p>@Controller在展现层使用，控制器的声明，用来创建处理http请求的对象（Controller层）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController&#123;</span><br><span class="line">         @RequestMapping(&quot;/test&quot;)</span><br><span class="line">        public String test（String string）｛</span><br><span class="line">     return   &quot;hello&quot;;</span><br><span class="line">｝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.注入bean的注解</p><p>@Autowired：由Spring提供，可以用在字段上，或者方法上。默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired（required=false）</p><p>@Resource：作用相当于@Autowired，只不过@Autowired按byName自动注入，而@Resource默认按byName自动注入。</p><p>都可以注解在set方法和属性上</p><p>3.java配置类相关注解</p><p>@Configuration声明当前类为配置类，相当于xml形式的Spring配置（类上）</p><p>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）</p><p>@Component注解，表明这个类是一个bean（类上）</p><p>4.切面（AOP）相关注解</p><p>Spring支持AspectJ的注解式切面编程</p><p>@Aspect声明一个切面（类上）</p><p>使用@After、@Before、@Around定义advice，可直接将拦截规则（切点）作为参数</p><p>@After 在方法执行之后执行（方法上）</p><p>@Before 在方法执行之前执行（方法上）</p><p>@Around 在方法执行之前与之后执行（方法上）</p><p>@PointCut声明切点</p><p>5.@Bean的属性支持</p><p>@Scope用来配置 spring bean 的作用域，它标识 bean 的作用域。 </p><p>其设置的类型包括：</p><p>Singleton：单例，一个Spring容器中只有一个bean实例，默认模式</p><p>Protetype：每次调用新建一个bean</p><p>Request：web项目中，给每个http request新建一个bean</p><p>Session：web项目中，给每个http session新建一个bean</p><p>GlobalSession：给每一个global http session 新建一个Bean实例</p><p>6.@Value注解</p><p>@Value为属性注入值（属性上）</p><p>普通字符注入： @Value（”lisa”） String name</p><p>注入文件资源： @Value（”classpath:com/file/test.txt”）String source file</p><p>注入配置文件： @Value(“${book.name}”)Sring bookName</p><p>7.SpringMVC相关注解</p><p>@Controller：声明该类为SpringMVC中的Controller</p><p>@RequestMapping：用于映射Web请求，包括访问路径和参数（类或方法上）</p><p>具体的在类定义处：提供初步的请求映射信息，相对于WEB应用的根目录。</p><p>方法处：提供进一步的戏份映射信息，相对于类定义处的URL。</p><p>@RequestParam：用于将请求参数区数据映射到功能处理方法的参数上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class test(@RequestParam Integer id)&#123;</span><br><span class="line">    return  mailService.fetch(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个id就是要接收从接口传递过来的参数id的值的，如果接口传递过来的参数名和你接收的不一致，也可以如下 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class test(@RequestParam(value=&quot;user_id&quot;) Integer id)&#123;</span><br><span class="line"> return  mailService.fetch(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中user_id就是接口传递的参数，id就是映射user_id的参数名</p><p>@ResponseBody：支持将返回值放在response内，而不是一个页面，通常用户返回json数据</p><p>注意：Spring4之后加的注解@RestController。原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController代替@Controller就不需要再配置@ResponseBody，默认返回json格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TestController&#123;</span><br><span class="line">         @RequestMapping(&quot;/test&quot;)</span><br><span class="line">        public String test（String string）｛</span><br><span class="line">     return   &quot;hello&quot;;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>} </p><p>@RequestBody：允许request的参数在request体中，而不是在直接连接在地址后面</p><p>@ModelAttribute：让全局的@RequestMapping都能获得在此设置的键值对</p><p>以上是我在学习中常见的和常用的java注解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注解就是源代码的元数据。&lt;/p&gt;
&lt;p&gt;1.声明bean的注解&lt;/p&gt;
&lt;p&gt;@Conponent组件，当组件不好归类的时候，我们可以使用这个注解进行标注&lt;/p&gt;
&lt;p&gt;@Service在业务逻辑层使用（service层）&lt;/p&gt;
&lt;p&gt;@Reponsitory在数据访问层
      
    
    </summary>
    
      <category term="开发注解应用" scheme="https://minminminzhang.github.io/categories/%E5%BC%80%E5%8F%91%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="注解应用" scheme="https://minminminzhang.github.io/tags/%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>用递归和迭代解决二叉树问题 </title>
    <link href="https://minminminzhang.github.io/2018/cjze1fwys000mcwnu0x67vf1w/"/>
    <id>https://minminminzhang.github.io/2018/cjze1fwys000mcwnu0x67vf1w/</id>
    <published>2018-12-13T08:33:40.644Z</published>
    <updated>2019-01-19T02:31:24.798Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树是数据结构最常见的一种应用。关于二叉树的很多问题都可以用递归和迭代来解决。</p><p>二叉树是一颗树，其中每个节点都不能有对于两个儿子。用代码可以简单的表示为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode&#123;</span><br><span class="line">   int val;</span><br><span class="line">   //左孩子</span><br><span class="line">   TreeNode left;</span><br><span class="line">   //右孩子</span><br><span class="line">   TreeNode left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.求二叉树的最大深度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int maxDeath(TreeNode node)&#123;</span><br><span class="line">    if(node==null)&#123;</span><br><span class="line">       return 0;</span><br><span class="line">&#125; </span><br><span class="line"> int left=maxDeath(node.left);</span><br><span class="line"> int right=maxDeath(node.right);</span><br><span class="line"> return Math.max(left,right)+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.求二叉树的最小深度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int getMinDepth()&#123;</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return getMin(root);</span><br><span class="line">&#125;</span><br><span class="line">int getMin(TreeNode root)&#123;</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    if（root.left==null&amp;&amp;root.right==null）&#123;</span><br><span class="line">      return 1;</span><br><span class="line">      &#125;</span><br><span class="line">      return Math.min(getMin(root.left),getMin(root.right))+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.求二叉树中节点的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int numOfTreeNode(TreeNode root)&#123;</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; </span><br><span class="line">    int left=numOfNode(root.left);</span><br><span class="line">    int right=numOfNode(root.right);</span><br><span class="line">    return left+right+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.求二叉树中叶子节点的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int numsOfNodeTreeNode(TreeNode root)&#123;</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(root.left==null&amp;&amp;root.right==null)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return numsOfNodeTreeNode(root.left)+numsOfNodeTreeNode(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.求二叉树中第K层节点的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int numsOfLevelTreeNode(TreeNode node,int k)&#123;</span><br><span class="line"> if(root==null||k&lt;1)&#123;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line">  if(k=1)&#123;</span><br><span class="line">      return 1;</span><br><span class="line">  &#125;  </span><br><span class="line">  int numLeft=numsOfLevelTreeNode(root.left,k-1);</span><br><span class="line">  int numRight=numsOfLevelTreeNode(root.right,k-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平衡二叉树是其每个节点的左子数和右子树的高度最多差1的二叉查找树.</p><p>6.判断二叉树是否是平衡二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean isBalanced(TreeNode node)&#123;</span><br><span class="line">     return maxDeath(node)!=-1;//空树的高度为1</span><br><span class="line">&#125;</span><br><span class="line">   int maxDeath2(TreeNode node)&#123;</span><br><span class="line">        if(node==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">           &#125;   </span><br><span class="line">       int left=maxDeath(node.left);   </span><br><span class="line">       int right=maxDeath(node.right); </span><br><span class="line">       if(left==-1||right==-1||Math.abs(left-right)&gt;1)&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">         return Math.max(left,right)+1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>7.判断两个二叉树是否完全相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">boolean isSameTreeNode(TreeNode t1,TreeNode t2)&#123;</span><br><span class="line">    if(t1==null&amp;&amp;t2==null)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else if(t1==null||t2==null)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(t1.val!=t2.val)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean left=isSameTreeNode(t1.left,t2.left);</span><br><span class="line">    boolean right=isSameTreeNode(t1.right,t2.right);</span><br><span class="line">    return left&amp;&amp;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.两个二叉树是否为镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean isMirror(TreeNode t1,TreeNode t2)&#123;</span><br><span class="line"> if(t1==null&amp;&amp;t2==null)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else if(t1==null||t2==null)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(t1.val!=t2.val)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return isMirror(t1.left,t2.right)&amp;&amp;isMirror(t1.right,t2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.二叉树的前序遍历</p><p>迭代解法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; preOrder(TreeNode root)&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt;  stack=new Stack&lt;TreeNode&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    while(!stack.empty)&#123;</span><br><span class="line">       TreeNode node=stack.pop();</span><br><span class="line">       list.add(node.val);</span><br><span class="line">       if(node.right!=null)&#123;</span><br><span class="line">           stack.push(node.right);</span><br><span class="line">       &#125;</span><br><span class="line">        if(node.left!=null)&#123;</span><br><span class="line">           stack.push(node.left);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归解法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; preOrder(TreeNode root)&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; result =new  ArrayList&lt;Integer&gt;();</span><br><span class="line">    preOrder2(root,result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">void preOrder2(TreeNode root,ArrayList&lt;Integer&gt; result)&#123;</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    result.add(root.val);</span><br><span class="line">    preOrder2(root.left,result);</span><br><span class="line">    preOrder2(root.right,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10.二叉树中的中序遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; inOrder(TreeNode root)&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt;  stack=new Stack&lt;TreeNode&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();</span><br><span class="line">    TreeNode current=root;</span><br><span class="line">   while(current！=null||!stack.empty())&#123;</span><br><span class="line">       while(current!=null)&#123;</span><br><span class="line">           stack.add(current);</span><br><span class="line">           current=current.left;</span><br><span class="line">       &#125;</span><br><span class="line">       current=stack.peek();</span><br><span class="line">       stack.pop();</span><br><span class="line">       list.add(current.val);</span><br><span class="line">       current=current.right;</span><br><span class="line">   &#125;</span><br><span class="line">   return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11.二叉树的后序遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; postOrder(TreeNode root)&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list=new ArrayList&gt;(Integer);</span><br><span class="line">    if(root==null)&#123;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    list.addAll(posrOrder(root.left));</span><br><span class="line">    list.addAll(posrOrder(root.right);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二叉树是数据结构最常见的一种应用。关于二叉树的很多问题都可以用递归和迭代来解决。&lt;/p&gt;
&lt;p&gt;二叉树是一颗树，其中每个节点都不能有对于两个儿子。用代码可以简单的表示为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
      <category term="算法应用" scheme="https://minminminzhang.github.io/categories/%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="二叉树" scheme="https://minminminzhang.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>时间典当厅项目之增加功能和上传</title>
    <link href="https://minminminzhang.github.io/2018/cjze1fwzg0017cwnucp9lmo4k/"/>
    <id>https://minminminzhang.github.io/2018/cjze1fwzg0017cwnucp9lmo4k/</id>
    <published>2018-12-02T08:49:04.879Z</published>
    <updated>2018-12-02T09:08:26.971Z</updated>
    
    <content type="html"><![CDATA[<p>在项目之上添加用户排序功能，上传到服务器。</p><h3 id="增加排序功能："><a href="#增加排序功能：" class="headerlink" title="增加排序功能："></a>增加排序功能：</h3><p>1.分别在dao，service，controller三层实现相应的后台代码。</p><p>​           dao层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;InfoUser&gt; userSort() &#123;</span><br><span class="line">        String sql = &quot;select * from t_user ORDER  by goldCoins desc &quot;;</span><br><span class="line">        return this.jdbcTemplate.query(sql, new InfoUser());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    service层 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;InfoUser&gt; userSort() &#123;</span><br><span class="line">    return this.userDao.userSort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller层 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@RequestMapping(&#123;&quot;userSort&quot;&#125;)</span><br><span class="line">@ApiOperation(</span><br><span class="line">    value = &quot;get user sort&quot;,</span><br><span class="line">    httpMethod = &quot;GET&quot;,</span><br><span class="line">    response = Result.class,</span><br><span class="line">    nickname = &quot;ALISURE&quot;</span><br><span class="line">)</span><br><span class="line">public Result getUserSort() &#123;</span><br><span class="line">    return new Result(this.userService.userSort());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在idea里面调试，访问<a href="https://localhost:8081/ddh/user/soetUser" target="_blank" rel="noopener">https://localhost:8081/ddh/user/soetUser</a>  本地测试正确。</p><p>3.上传服务器</p><p>​          （1）打开Xshell，输入项目名称和密码，连接到项目服务器。</p><p>​          （2）打开Xftp，连接成功。在路径下找到后台代码 </p><p>​                      （3）上传修改之后的新代码。服务器中的后台代码都是以.class结尾，编译之后的文件，不能直接修改。</p><p>​          应该先下载要修改的文件，在IDEA里面打开，修改要添加的代码，修改之后在IDEA里面进行单个文件的编译。找到编译之后的class文件（项目编译之后的class一般存储在项目下的target文件夹里面），直接拖进Xftp进行上传。</p><p>​          注意：编译项目里面的某个单个文件时直接在IDEA里面编辑，不要再cmd命令框里面编译，因为cmd默认实在当前目录查找class文件，会报找不到依赖包的错误。</p><p>​<br> 4.把项目上传服务器成功之后，重新启动tomcat.即可通过网址<a href="http://timeseller.fantasy512.cn/ddh/user/soetUser" target="_blank" rel="noopener">http://timeseller.fantasy512.cn/ddh/user/soetUser</a>    即可获取到用户数据，然后将获取到的用户数据和接口user/sortUser一并传给前端，实现前后端的交互。</p><p>​<br>5.确保无误的代码即可上传到github上保存完整的代码。</p><h3 id="补充：重启服务器的tomcat"><a href="#补充：重启服务器的tomcat" class="headerlink" title="补充：重启服务器的tomcat"></a>补充：重启服务器的tomcat</h3><p> （1）首先，进入tomcat下的bin目录  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd   usr/tomcat/bin</span><br></pre></td></tr></table></figure><p>（2）使用tomcat关闭命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shutdown.sh</span><br></pre></td></tr></table></figure><p> （3）查看tomcat是否已经关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep java</span><br></pre></td></tr></table></figure><p>​    如果显示以下相似信息，说明tomcat还没有关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root      7010     1  0 Apr19 ?        00:30:13 /usr/local/java/bin/java</span><br><span class="line"></span><br><span class="line">-Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties</span><br><span class="line">-Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms1024m -Xmx1024m</span><br><span class="line">-XX:NewSize=256m -XX:MaxNewSize=256m -XX:PermSize=256m -XX:MaxPermSize=256m</span><br><span class="line">-XX:+DisableExplicitGC -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.endorsed.dirs=/usr/local/tomcat/endorsed -classpath /usr/local/tomcat/bin/bootstrap.jar</span><br><span class="line">-Dcatalina.base=/usr/local/tomcat -Dcatalina.home=/usr/local/tomcat</span><br><span class="line">-Djava.io.tmpdir=/usr/local/tomcat/temp org.apache.catalina.startup.Bootstrap start</span><br></pre></td></tr></table></figure><p>（4）如果直接想杀死tomcat进程（进程号7010），可以使用kill命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9  7010</span><br></pre></td></tr></table></figure><p>（5）继续查看tomcat是否已经关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep java</span><br></pre></td></tr></table></figure><p>  如果出现以下信息，则表示tomcat已经关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root      7010     1  0 Apr19 ?        00:30:30 [java] &lt;defunct&gt;</span><br></pre></td></tr></table></figure><p>（6）最后，启动tomcat<br>./startup.sh</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目之上添加用户排序功能，上传到服务器。&lt;/p&gt;
&lt;h3 id=&quot;增加排序功能：&quot;&gt;&lt;a href=&quot;#增加排序功能：&quot; class=&quot;headerlink&quot; title=&quot;增加排序功能：&quot;&gt;&lt;/a&gt;增加排序功能：&lt;/h3&gt;&lt;p&gt;1.分别在dao，service，cont
      
    
    </summary>
    
      <category term="代码上传服务器 " scheme="https://minminminzhang.github.io/categories/%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="代码上传服务器" scheme="https://minminminzhang.github.io/tags/%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架总结 </title>
    <link href="https://minminminzhang.github.io/2018/cjze1fwyh000gcwnun8mfxiyy/"/>
    <id>https://minminminzhang.github.io/2018/cjze1fwyh000gcwnun8mfxiyy/</id>
    <published>2018-11-18T01:48:31.224Z</published>
    <updated>2019-01-19T02:34:16.101Z</updated>
    
    <content type="html"><![CDATA[<p>对于java程序员，Spring是做多使用，也必须掌握的框架之一。Spring是一站式的开源框架解决方案。</p><h3 id="1-Spring的核心：AOP-、IOC"><a href="#1-Spring的核心：AOP-、IOC" class="headerlink" title="1.Spring的核心：AOP    、IOC"></a>1.Spring的核心：AOP    、IOC</h3><p>（1）AOP：面向切面编程，扩展功能不是修改源代码实现。</p><p>（2）IOC：控制反转。IOC操作时把对象的创建交给Springl进行管理，IOC 操作包括IOC的配置文件文件方式和IOC的注解方式。</p><h3 id="2-Spring的bean管理（xml方式）"><a href="#2-Spring的bean管理（xml方式）" class="headerlink" title="2.Spring的bean管理（xml方式）"></a>2.Spring的bean管理（xml方式）</h3><p>（1）bean实例化的方式</p><p>  1）在Spring里面通过配置文件创建对象</p><p>  2）bean实例化的三种方式</p><p>①：使用类的无参数构造创建<br>  <bean id=" " class=" "></bean></p><p>注意：这样的前提是该类存在无参数的构造方法，如果类里面没有参数的构造，会出现异常：No default constructor found；</p><p>②：使用静态工厂创建，创建静态的方法，返回类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Bean1Factory&#123;</span><br><span class="line">  public static Bean1  getBean1( )&#123;</span><br><span class="line">                return new Bean1( );</span><br><span class="line">                &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><!-- 使用静态工厂创建对象--> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bean1&quot; class=&quot;cn.xidiaa.bean.Bean1Factory&quot; factory-method=&quot;&quot;getBean1&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>③：使用实例工厂创建 ，创建不是静态的方法，返回类对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Bean2Factory&#123;</span><br><span class="line">     public Bean2 getBean2( )&#123;</span><br><span class="line">              return new Bean2( );</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p> (2)  Bean标签常用属性</p><p> 1）id属性：起名称，id属性值名称任意命名。</p><p>?       id属性值，不能包含特殊符号。根据id值得到配置对象。</p><p> 2）class属性：创建对象所在类的全路径。</p><p> 3）name属性：功能和id属性是一样的，id属性值不能包含特殊符号，但是在name属性值里面可以包含特殊符号。</p><p> 4）scope属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-singleton：默认值，单例   scope=“singleton”  cn.xidiaa.ioc.User@1be3a66</span><br><span class="line">                                             cn.xidiaa.ioc.User@1be3a66</span><br><span class="line">-prototype:多例  cn.xidiaa.ioc.User@e90eef</span><br><span class="line">                 cn.xidiaa.ioc.User@d381e4</span><br></pre></td></tr></table></figure><p>（3）属性注入介绍</p><p>1）创建对象的时候，像类里面属性里面设置值。</p><p>2）属性注入的方式介绍（三种方式）</p><p>​      三种方式包括：使用set方法注入，有参数构造注入，使用接口注入。<br>       在Spring框架里面，支持前两种方式：</p><p>①：使用有参数构造注入属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;demo&quot; class=&quot;cn.xidiaa.property.PropertyDemo1&quot;&gt;</span><br><span class="line">              &lt;constructor-arg name=&quot;username&quot; value=&quot;jery&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">       &lt;/bean&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private String username;</span><br><span class="line">   public PropertyDemo(String username)&#123;</span><br><span class="line">        this.username=username;</span><br><span class="line">   &#125;</span><br><span class="line">   public void test1()&#123;</span><br><span class="line">    System.out.println(&quot;demo......&quot;+username);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>②：使用set方法注入属性  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private String bookname;</span><br><span class="line">  public void setBookname(String bookname)&#123;</span><br><span class="line">       this.bookname=bookname;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;book&quot; class=&quot;cn.xidiaa.property.Book&quot;&gt;</span><br><span class="line">          &lt;property  name=&quot;bookname&quot; value=&quot;方漫图&quot;&gt;&lt;/property&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p> 3）注入对象类型属性：xml方式</p><p> ①：创建service类和dao类<br> 在service得到dao对象</p><p> ②：具体实现过程<br>     在service里面把dao作为类型属性，生成dao类型属性的set方法。     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">          private UserDao userDao;</span><br><span class="line">          public void setUserDao(UserDao uesrDao)&#123;</span><br><span class="line">                 this.userDao=userDao;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p> ③：配置文件中注入关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;cn.xidiaa.ioc.UserDao&quot;&gt;&lt;/bean&gt;</span><br><span class="line">        &lt;bean id=&quot;userDao&quot; class=&quot;cn.xidiaa.ioc.UserService&quot;&gt;        </span><br><span class="line">       &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p> 4)基于注解方式的bean创建以及注入<br> 因为Spring注解的实现是需要AOP的支持，因此在依赖方面需要注意，其次，要在XML中开启注解扫描：</p><pre><code>&lt;context:component-scan base-package=&quot;&quot; /&gt;</code></pre><p>实际上这个配置，会让Spring在指定包下扫描，把带有注解标志的bean实例化，并且会进行属性注入。  </p><p>创建对象的4个注解：</p><p>@Component/@Controller/@Service/@Repository<br>在这4个注解上，通过value属性来指定bean的id，通过@scope配合来声明单例OR多例。</p><p>注入属性：</p><p>@Autowired/@Resource/@Qualifier</p><p>注意：@Resource是javax包下的，就是J2EE提供的；而@Autowired是Spring提供的。（不必提供setter方法）</p><p>@Resource默认按照名称注入，如果找不到才按照类型注入。</p><p>@Autowired默认按照类型注入，可以结合@Qualifier进行名称注入。</p><p>注意：如果@Autowired进行类型注入，很可能类型会有多个满足（多态），那么到底注入哪个呢？所以说，如果按照@Autowired类型注入，一定注意结合@Qualifier。实际开发中，显然，注入应该是确定的，那么按照名称注入，应该是首选！ </p><h3 id="3-Spring事务管理"><a href="#3-Spring事务管理" class="headerlink" title="3.Spring事务管理"></a>3.Spring事务管理</h3><p>Spring的声明式事务管理，用的最多的就是基于注解的方式。首先我们得配置一个事务管理器，而事务管理器需要我们注入DataSource。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;tx:annotation-driven/&gt;</span><br></pre></td></tr></table></figure><p>  对于多个数据源，需要定义多个事务管理器，同时也得开启事务注解。过个事务管理器，可以通过Qualifier属性进行区分。</p><p>配置完毕后，直接在service层的类或者方法上，使用<br>@Transactional(value = “gcs”, rollbackFor = Exception.class)</p><h3 id="4-Spring整合web项目原理"><a href="#4-Spring整合web项目原理" class="headerlink" title="4.Spring整合web项目原理"></a>4.Spring整合web项目原理</h3><p>?1）加载Spring核心配置文件     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context=new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);</span><br></pre></td></tr></table></figure><p>  new对象，功能可以实现，效率很低。</p><p>  2）实现思想：把加载配置文件和创建对象过程，在服务器启动时候完成。</p><p>  3）实现原理：</p><p>   ①：ServletContext对象</p><p>   ②：监听器</p><p>   ③：具体使用</p><p>   ——在服务器启动的时候，为每个项目创建一个ServletContext对象</p><p>   ——在ServletContext对象创建的时候，使用监听器可以具体到ServletContext对象在什么时候创建</p><p>   ——使用监听器听到ServletContext对象创建的时候，加载spring配置文件，把配置文件配置对象创建</p><p>   ——把创建出来的对象放到ServletContext域对象里面（setAttribute方法）<br>   ——获取对象的时候，到ServletContext域里面得到（getAttribute方法）</p><h3 id="5-补充"><a href="#5-补充" class="headerlink" title="5.补充"></a>5.补充</h3><p>（1）.IOC和DI区别</p><p>1）IOC: 控制反转，把对象创建交给spring进行配置</p><p>2）DI: 依赖注入，向类里面的属性中设置值</p><p>3）关系：依赖注入不能单独存在，需要在ioc基础之上完成操作</p><p>（2）.关于AOP的几个重点概念：</p><p>1）AOP的实现，一种横向抽取机制，依赖于动态代理模式。</p><p>2）JoinPoint：连接点，说白了，就是可以被增强的方法；</p><p>3）PointCut：切入点，对哪些JoinPoint进行拦截；</p><p>4）Advice：通知，就是拦截后的动作；</p><p>5）Aspect：切面，把增强应用到具体方法的过程；</p><p>Spring的AOP需要借助aspectj来实现，可以通过XML，也可以通过注解来完成。</p><p>比如，采用XML方式的话，需要指明用A类的哪个方法对B类的哪些方法上进行增强，这里就涉及到execution表达式了；</p><p>比如，采用注解方式的话，就更加简单了，先在XML中开启AOP（&lt;aop:aspectj-autoproxy /&gt;），然后在增强方法上直接使用类似@Before(value=”execution(具体的表达式)”)就可以了；<br>其实在实际开发中，我们对于AOP最常用的就是事务了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于java程序员，Spring是做多使用，也必须掌握的框架之一。Spring是一站式的开源框架解决方案。&lt;/p&gt;
&lt;h3 id=&quot;1-Spring的核心：AOP-、IOC&quot;&gt;&lt;a href=&quot;#1-Spring的核心：AOP-、IOC&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Spring框架 " scheme="https://minminminzhang.github.io/categories/Spring%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="相关技术" scheme="https://minminminzhang.github.io/tags/%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>小顽童项目准备</title>
    <link href="https://minminminzhang.github.io/2018/cjze1fwze0016cwnua4zduw8r/"/>
    <id>https://minminminzhang.github.io/2018/cjze1fwze0016cwnua4zduw8r/</id>
    <published>2018-10-28T00:32:45.112Z</published>
    <updated>2019-01-19T02:34:32.997Z</updated>
    
    <content type="html"><![CDATA[<p>基于前期的学习，为了进一步用以实践，我们准备开发一个小网站—–小顽童。</p><p>涉及到：1.前端 2.后台 3.移动端</p><p>网站的内容：</p><p>1.板块（论坛，可以参考西电睿思），具体主题未定，大家均可以提出意见，然后进行业务开发。</p><p>2.工具，提供常用查询，如天气查询，列车时刻查询，远程查询 ，IP详情，电话详情，遥控等等。</p><p>3.自定义模块</p><p>涉及到的技术：</p><p>工具：IDEA,maven,git(github),wiki</p><p>容器：tomcat7及以上，推荐9</p><p>前端：html+css+js(Ajax)</p><p>前端框架：vue.js</p><p>后台：jsp/servlet</p><p>框架：spring/springmvc/mybatis</p><p>移动端：推荐webApp</p><p>数据库：mysql</p><p>美工：ps,图标尽量在阿里巴巴矢量图标库下载，美图秀秀也可以。</p><p>本次项目分工明确：我作为项目参与者，主要负责后台开发。</p><h4 id="一-首先，安装开发工具IDEA"><a href="#一-首先，安装开发工具IDEA" class="headerlink" title="一.首先，安装开发工具IDEA"></a>一.首先，安装开发工具IDEA</h4><p>IDEA的安装以及破解步骤：</p><p>1.从睿思或者官网下载最新的IDEA软件到本地。</p><p>2.双击安装，选择合适的下载路径。</p><p>3.安装完毕后，先不要打开。</p><p>4.开始破解：</p><p>5.首先更改hosts文件。（位置：C:\Windows\System32\drives\etc）。</p><p>6.使用文本编译器打开hosts</p><p>  在最后一行添加：0.0.0.0          account.jetbrains.com!1540689850659]</p><p>7.打开运行idea，会提示让你注册，有三种方式，下面就是注册码，copy进去确认即可。</p><p>K71U8DBPNE-eyJsaWNlbnNlSWQiOiJLNzFVOERCUE5FIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifV0sImhhc2giOiI4OTA4Mjg5LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-Owt3/+LdCpedvF0eQ8635yYt0+ZLtCfIHOKzSrx5hBtbKGYRPFDrdgQAK6lJjexl2emLBcUq729K1+ukY9Js0nx1NH09l9Rw4c7k9wUksLl6RWx7Hcdcma1AHolfSp79NynSMZzQQLFohNyjD+dXfXM5GYd2OTHya0zYjTNMmAJuuRsapJMP9F1z7UTpMpLMxS/JaCWdyX6qIs+funJdPF7bjzYAQBvtbz+6SANBgN36gG1B2xHhccTn6WE8vagwwSNuM70egpahcTktoHxI7uS1JGN9gKAr6nbp+8DbFz3a2wd+XoF3nSJb/d2f/6zJR8yJF8AOyb30kwg3zf5cWw==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==</p><h4 id="二-安装git，这里默认都是Windows系统。"><a href="#二-安装git，这里默认都是Windows系统。" class="headerlink" title="二.安装git，这里默认都是Windows系统。"></a>二.安装git，这里默认都是Windows系统。</h4><p>1.登陆git官网，下载windows版的进行安装，选择安装路径，其他均选择默认配置。</p><p>2.安装成功后，验证是否成功（打开git bash，输入git–version）。</p><p>3.检查用户名和邮箱是否配置（git config –global –list）</p><p>4.如果没有，进行配置。</p><p>设置用户名：git config –global user.name “xxx”</p><p>设置邮箱：git config –global user.email “xxxxx”</p><p>5.生成ssh-key（ssh-keygen -t rsa -C “你的email”）</p><p>整个过程一直回车，有需要yes/no,就yes。最后会生成一份ssh私钥和一份公钥。</p><p>6.打开公钥位置，发给项目管理人。</p><h4 id="三-申请github账号"><a href="#三-申请github账号" class="headerlink" title="三.申请github账号"></a>三.申请github账号</h4><p>申请成功后，将用户名一并发给项目管理人。</p><h4 id="四-用码云进行一个简单的前后端测试"><a href="#四-用码云进行一个简单的前后端测试" class="headerlink" title="四.用码云进行一个简单的前后端测试"></a>四.用码云进行一个简单的前后端测试</h4><p>1.进入：<a href="http://gitee.com/" target="_blank" rel="noopener">http://gitee.com/</a></p><p>搜索到urchin_board，然后进行fork。</p><p>2.切换到alpha分支上面，创建一个txt文件，进行PR操作，则成功进入到项目组织里面。</p><h4 id="五-安装tomcat9"><a href="#五-安装tomcat9" class="headerlink" title="五.安装tomcat9"></a>五.安装tomcat9</h4><p>   安装方式：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a></p><h4 id="六-安装maven"><a href="#六-安装maven" class="headerlink" title="六.安装maven"></a>六.安装maven</h4><p>安装教程为：<a href="https://blog.csdn.net/t_1025/article/details/70148793" target="_blank" rel="noopener">https://blog.csdn.net/t_1025/article/details/70148793</a></p><p>中央仓库建议用阿里巴巴，这样速度更快一些</p><h4 id="七-在idea上进行git操作"><a href="#七-在idea上进行git操作" class="headerlink" title="七.在idea上进行git操作"></a>七.在idea上进行git操作</h4><p>1.File-setting-Gitee，点击Install。</p><p>2.安装成功后，进行如下操作。</p><p>​    crtl+alt+s到界面：Version Control-Gitee-Creat API Token-输入码云的账号和密码-Test</p><p>3.接下来用git拉取项目</p><p>(1)File–New–Project from Version Control–Git</p><p>(2)复制仓库时：要求输入URL和Directory。</p><p>4，在码云中，切换到alpha，点击克隆/下载，复制链接到URL，进行克隆，克隆成功后就可以看到新建的文件了。</p><p>注意：当遇到URL没有错误，但克隆失败时，检查是否已经添加了ssh-key，如果没有则先进行添加之后再克隆代码。</p><p>5.点击同步之后，检查idea页面最下方是否存在Terminal和Git：master。</p><p>6.创建分支</p><p>git checkout -b “分支名-alpha”</p><p>创建成功之后，右下角出现分支名–Git：minminminzhang。</p><h4 id="八-接下来进行项目的同步操作。"><a href="#八-接下来进行项目的同步操作。" class="headerlink" title="八.接下来进行项目的同步操作。"></a>八.接下来进行项目的同步操作。</h4><h5 id="1-编写pom-xml-一人编写，其他人同步即可。"><a href="#1-编写pom-xml-一人编写，其他人同步即可。" class="headerlink" title="1.编写pom.xml,一人编写，其他人同步即可。"></a>1.编写pom.xml,一人编写，其他人同步即可。</h5><p>编写完成之后，进行pull操作。</p><p>pull操作可以用git命令：</p><p>git stash</p><p>git pull origin master</p><p>git stash pop</p><p>还有一种就是：右击项目-Git-Repository-Pull，始终选择origin/alpha.</p><p>就可以看到pom.xml进行更新了，更新完成之后有290行代码。</p><h5 id="2-整合SSM框架"><a href="#2-整合SSM框架" class="headerlink" title="2.整合SSM框架"></a>2.整合SSM框架</h5><p>  <a href="https://www.cnblogs.com/hackyo/p/6646051.html" target="_blank" rel="noopener">https://www.cnblogs.com/hackyo/p/6646051.html</a></p><h4 id="九-运行项目"><a href="#九-运行项目" class="headerlink" title="九.运行项目"></a>九.运行项目</h4><p>1，重新登录码云，有可能过期了。</p><p>Alt+Ctrl+s–Gitee–Create API Token–Test</p><p>2，再配置一下tomcat服务器</p><p> (1)点击项目urchin右边的倒三角Edit Configurations</p><p> (2)在Run/Debug Configurations页面：点击最上面的“+”号–Maven–选择项目urchin–在Command ling行选择tomact：run，应用保存。</p><p>3，测试，运行</p><p>在index.jsp页面简单的写一个程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        p&#123;</span><br><span class="line">            font-size: 50px;</span><br><span class="line">            color:aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello World!&lt;/h2</span><br><span class="line">    &lt;p&gt;小顽童项目开始了&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>点击运行：</p><p>下方出现一行[INFO]  Running war on <a href="http://localhost:9091/urchin" target="_blank" rel="noopener">http://localhost:9091/urchin</a></p><p>即访问此网址就可以看到运行结果。</p><p>以上准备工作完成之后，我们就可以进行项目的设计开发了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于前期的学习，为了进一步用以实践，我们准备开发一个小网站—–小顽童。&lt;/p&gt;
&lt;p&gt;涉及到：1.前端 2.后台 3.移动端&lt;/p&gt;
&lt;p&gt;网站的内容：&lt;/p&gt;
&lt;p&gt;1.板块（论坛，可以参考西电睿思），具体主题未定，大家均可以提出意见，然后进行业务开发。&lt;/p&gt;
&lt;p&gt;2
      
    
    </summary>
    
      <category term="相关技术" scheme="https://minminminzhang.github.io/categories/%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="相关技术" scheme="https://minminminzhang.github.io/tags/%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java中常用设计模式的使用方法与区别</title>
    <link href="https://minminminzhang.github.io/2018/cjze1fx8b002lcwnu900gbuz3/"/>
    <id>https://minminminzhang.github.io/2018/cjze1fx8b002lcwnu900gbuz3/</id>
    <published>2018-10-08T12:10:59.041Z</published>
    <updated>2018-11-18T02:22:32.249Z</updated>
    
    <content type="html"><![CDATA[<p> 设计模式其实就是一套被反复使用的代码设计经验的总结。</p><p> 使用设计模式的优点就是：代码可以重用，更容易被他人理解，保证代码的可靠性。</p><p>Java中的设计模式以供有23种，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。</p><h2 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h2><p>​       我们在实例化对象的时候通常用new关键字，但是有了工厂，我们在声明对象的时候就可以用到工厂了，使得代码更加灵活。是由一个工厂对象决定创建出哪一种产品类的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//抽象产品</span><br><span class="line">public abstract class Car&#123;</span><br><span class="line">     public abstract  void Driver( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line">public class BenC&#123;</span><br><span class="line">       public void Driver( )&#123;</span><br><span class="line">            Console.WriteLine(&quot;奔驰&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line"></span><br><span class="line">public class BaoM&#123;</span><br><span class="line">       public void Driver( )&#123;</span><br><span class="line">            Console.WriteLine(&quot;宝马&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//简单工厂</span><br><span class="line"></span><br><span class="line">public class Driver( )&#123;</span><br><span class="line">      public static Car DriverCar (string carName)&#123;</span><br><span class="line">                Car car;</span><br><span class="line">           if(carName)==&quot;奔驰&quot;)&#123;</span><br><span class="line">              car=new BenC( );</span><br><span class="line">         &#125; </span><br><span class="line">          else&#123;</span><br><span class="line">                car=new BaoM( );</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//客户代码</span><br><span class="line">public class Boss&#123;</span><br><span class="line">    Car car1=Driver.DriverCar(&quot;奔驰&quot;);</span><br><span class="line">   car1.Driver();</span><br><span class="line">  Car car2=Driver.DriverCar(&quot;宝马&quot;);</span><br><span class="line">   car2.Driver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><p>（1）简单工厂包含必要的判断逻辑，实现了对象的创建和使用的分离。</p><p>（2）客户端无需知道所创建的具体产品类的类名，只需要具体产品类对应的参数即可。</p><p>（3）在不修改客户端代码的情况下更换和增加具体产品类，提高了系统的灵活性。</p><p>缺点：</p><p>当产品修改时，工厂类也需要做相应的修改，违反了开—闭原则。</p><p>简单工厂模式适用于业务简单或者具体产品很少增加的情况。而对于复杂的业务环境不太适应。因此提出工厂方法模式。</p><h2 id="二、工厂方法模式："><a href="#二、工厂方法模式：" class="headerlink" title="二、工厂方法模式："></a>二、工厂方法模式：</h2><p>​       工厂方法模式是简单工厂的进一步延伸，这样说是因为简单工厂违反了开—闭原则，而工厂方法可以完美的解决这个问题。工厂方法不在工厂类中进行逻辑判断，程序可以为不同产品类提供不同的工厂。当使用工厂方法设计模式时，对象调用者需要与具体的工厂类耦合。</p><p>​      工厂方法模式的各个角色：</p><p>​       抽象工厂角色：工厂方法模式的核心，它与应用程序无关。是具体工厂必须实现的接口或者必须继承的父类他由抽象类或者接口来实现。</p><p>​       具体工厂角色：它含有和具体逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。</p><p>​       抽象产品角色：他是具体产品继承的父类或者是实现的接口。一般由抽象类或者接口来实现。</p><p>​       具体产品角色：具体工厂角色所创建的对象就是此角色的实例。由具体类实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//抽象产品</span><br><span class="line">public abstract class Car&#123;</span><br><span class="line">     public abstract  void Driver( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line">public class BenC&#123;</span><br><span class="line">       public void Driver( )&#123;</span><br><span class="line">            Console.WriteLine(&quot;奔驰&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line"></span><br><span class="line">public class BaoM&#123;</span><br><span class="line">       public void Driver( )&#123;</span><br><span class="line">            Console.WriteLine(&quot;宝马&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//抽象工厂</span><br><span class="line">public  abstract class Driver&#123;</span><br><span class="line">   public abstract Car DriverCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体工厂</span><br><span class="line">public class DriverBenC( )&#123;</span><br><span class="line">      public  Car DriverCar ()</span><br><span class="line">             Car  car=new BenC( );</span><br><span class="line">           return car;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体工厂</span><br><span class="line">public class DriverBaoM( )&#123;</span><br><span class="line">      public  Car DriverCar ()</span><br><span class="line">             Car  car=new BaoM( );</span><br><span class="line">         return car;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//客户代码</span><br><span class="line">public class Boss&#123;</span><br><span class="line">Driver d=new DriverBenC( );    </span><br><span class="line">Car car=d.DriverCar( );</span><br><span class="line"> car.Driver();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>优点：</p><p>（1）工厂方法用来创建客户所需要的产品，同时隐藏了哪种产品具体类将被实例化的细节，用户只需要关注工厂，不需要关注创建的细节。</p><p>（2）当产品增加时，只需要增加对应的工厂就好，完全符合开放封闭性原则。</p><p>缺点：</p><p>抽象层的加入使得理解程度加大。</p><h2 id="三、抽象工厂模式："><a href="#三、抽象工厂模式：" class="headerlink" title="三、抽象工厂模式："></a>三、抽象工厂模式：</h2><p>抽象工厂模式与工厂方法模式的区别就在于需要创建对象的复杂程度上。抽象工厂模式是三个里面最为抽象，最具有一般性的。用意在于给客户端提供一个接口，可以创建多个产品中的产品对象。</p><p>使用抽象工厂模式还要满足以下条件：</p><p>（1）系统中有多个产品族，而系统一次只可能消费其中一族产品。</p><p>（2）同属于同属于同一产品族的产品一起使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//抽象产品</span><br><span class="line">public abstract class BenC&#123;</span><br><span class="line">     public abstract  void Driver( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line">public class BenCSportCar&#123;</span><br><span class="line">      public void Driver( )&#123;</span><br><span class="line">          Console.WriteLine(&quot;奔驰&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line">public class BenCBusinessCar&#123;</span><br><span class="line">       public void Driver( )&#123;</span><br><span class="line">           Console.WriteLine(&quot;奔驰&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//抽象产品</span><br><span class="line">public abstract class BaoM&#123;</span><br><span class="line">     public abstract  void Driver( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line">public class BaoMSportCar&#123;</span><br><span class="line">       public void Driver( )&#123;</span><br><span class="line">            Console.WriteLine(&quot;宝马&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//具体产品</span><br><span class="line">public class BaoM&#123;SportCar&#123;</span><br><span class="line">      public void Driver( )&#123;</span><br><span class="line">           Console.WriteLine(&quot;宝马&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//抽象工厂</span><br><span class="line">public  abstract class Driver&#123;</span><br><span class="line">   public abstract BenCCar DriverBenCCar();</span><br><span class="line">   public abstract BaoMCar DriverBenCCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//具体工厂</span><br><span class="line">public class SportDriver( )&#123;</span><br><span class="line">       public BenCCar  DriverBenCCar()&#123;</span><br><span class="line">               BenCSportCar  bencSport=new  BenCSportCar();</span><br><span class="line">               return   bencSport;</span><br><span class="line">        &#125;</span><br><span class="line">         public BaoMCar  DriverBaoMCar()&#123;</span><br><span class="line">             BaoMSportCar  baomSport=new  BaoMSportCar();</span><br><span class="line">                 return   baomSport;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//具体工厂</span><br><span class="line">public class BusinessDriver( )&#123;</span><br><span class="line">        public BenCCar  DriverBenCCar()&#123;</span><br><span class="line">       BenCSportCar  bencSport=new  BenCSportCar();</span><br><span class="line">        return   bencSport;</span><br><span class="line">         &#125;</span><br><span class="line">      public BaoMCar  DriverBaoMCar()&#123;</span><br><span class="line">       BaoMSportCar  baomSport=new  BaoMSportCar();</span><br><span class="line">       return   baomSport;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//客户代码</span><br><span class="line">public class Boss&#123;</span><br><span class="line">Driver d=new DriverBenC( );    </span><br><span class="line">Car car=d.DriverCar( );</span><br><span class="line"> car.Driver();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上可以发现，增加一个产品族很简单，而增加一个新的产品会很复杂。抽象工厂模式一般用于具有产品树和产品族的场景下。</p><p>补充：</p><p>1.单例模式，一个类只有一个实例存在。存在两种不同形式的单例：</p><p>第一种形式：饿汉式单例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">       private Singleton()&#123; &#125;</span><br><span class="line">       //在内部定义一个实例，private，只供内部使用。</span><br><span class="line">       private static Singleton instance =new Singleton();</span><br><span class="line">       //提供了一个供外部访问本class的静态方法，可以直接访问。</span><br><span class="line">       public static Singleton getInstance()&#123;</span><br><span class="line">                       return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种：懒汉式单例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">       private  static  Singleton instace=null;</span><br><span class="line">       private Singleton()&#123;&#125;</span><br><span class="line">       public static  synchronized Singleton getInstance()&#123;</span><br><span class="line">       //比上面的方法有所改进，不用每次都进行声称对象，只是第一次使用时生成实例，提高了效率!</span><br><span class="line">              if(instance==null)  </span><br><span class="line">               instance =newSingleton();</span><br><span class="line">              return instance;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例的特点：外界无法通过构造器来创建对象，该类必须提供一个静态方法向外界提供该类的唯一实例。</p><p>2.在开发中常用的设计模式</p><p>（1）工厂模式：工厂类可以根据条件生成不同的子类对象，这些子类有一个公共的抽象父类并且实现的相同的方法，但这些方法针对不同的数据进行了不同的操作。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。</p><p>（2）代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可分为：远程代理、虚拟代理、保护代理、Cache 代理、防火墙代理、同步化代理、智能引用代理。</p><p>（3）适配器模式：把一个类的接口变成客户所期待的另一种接口，从而使原本因接口不匹配而无法一起使用的类能够一起工作。</p><p>（4）模板方式模式：提供一个抽象类，将部分逻辑以具体方式或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 设计模式其实就是一套被反复使用的代码设计经验的总结。&lt;/p&gt;
&lt;p&gt; 使用设计模式的优点就是：代码可以重用，更容易被他人理解，保证代码的可靠性。&lt;/p&gt;
&lt;p&gt;Java中的设计模式以供有23种，包括：Abstract Factory（抽象工厂模式），Builder（建造者
      
    
    </summary>
    
      <category term="设计模式" scheme="https://minminminzhang.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://minminminzhang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
