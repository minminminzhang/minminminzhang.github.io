<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简单工厂、工厂方法、抽象工厂 使用方法与区别]]></title>
    <url>%2F2018%2Fcjn0dvswq0006yknux4s30bci%2F</url>
    <content type="text"><![CDATA[一、简单工厂模式​ 我们在实例化对象的时候通常用new关键字，但是有了工厂，我们在声明对象的时候就可以用到工厂了，使得代码更加灵活。是由一个工厂对象决定创建出哪一种产品类的实例。 //抽象产品 public abstract class Car{ ​ public abstract void Driver( ); } //具体产品 public class BenC{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //具体产品 public class BaoM{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //简单工厂 public class Driver( ){ ​ public static Car DriverCar (string carName){ ​ Car car; ​ if(carName)==”奔驰”){ ​ car=new BenC( ); ​ } ​ else{ ​ car=new BaoM( ); ​ } } //客户代码 public class Boss{ ​ Car car1=Driver.DriverCar(“奔驰”); ​ car1.Driver(); Car car2=Driver.DriverCar(“宝马”); car2.Driver(); } 优点： （1）简单工厂包含必要的判断逻辑，实现了对象的创建和使用的分离。 （2）客户端无需知道所创建的具体产品类的类名，只需要具体产品类对应的参数即可。 （3）在不修改客户端代码的情况下更换和增加具体产品类，提高了系统的灵活性。 缺点： 当产品修改时，工厂类也需要做相应的修改，违反了开—闭原则。 简单工厂模式适用于业务简单或者具体产品很少增加的情况。而对于复杂的业务环境不太适应。因此提出工厂方法模式。 二、工厂方法模式：​ 工厂方法模式是简单工厂的进一步延伸，这样说是因为简单工厂违反了开—闭原则，而工厂方法可以完美的解决这个问题。工厂方法不在工厂类中进行逻辑判断，程序可以为不同产品类提供不同的工厂。当使用工厂方法设计模式时，对象调用者需要与具体的工厂类耦合。 ​ 工厂方法模式的各个角色： ​ 抽象工厂角色：工厂方法模式的核心，它与应用程序无关。是具体工厂必须实现的接口或者必须继承的父类他由抽象类或者接口来实现。 ​ 具体工厂角色：它含有和具体逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 ​ 抽象产品角色：他是具体产品继承的父类或者是实现的接口。一般由抽象类或者接口来实现。 ​ 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。由具体类实现。 //抽象产品 public abstract class Car{ ​ public abstract void Driver( ); } //具体产品 public class BenC{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //具体产品 public class BaoM{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //抽象工厂 public abstract class Driver{ public abstract Car DriverCar(); } //具体工厂 public class DriverBenC( ){ ​ public Car DriverCar () ​ Car car=new BenC( ); ​ return car; } //具体工厂 public class DriverBaoM( ){ ​ public Car DriverCar () ​ Car car=new BaoM( ); ​ return car; } //客户代码 public class Boss{ Driver d=new DriverBenC( ); Car car=d.DriverCar( ); car.Driver(); } 优点： （1）工厂方法用来创建客户所需要的产品，同时隐藏了哪种产品具体类将被实例化的细节，用户只需要关注工厂，不需要关注创建的细节。 （2）当产品增加时，只需要增加对应的工厂就好，完全符合开放封闭性原则。 缺点： 抽象层的加入使得理解程度加大。 三、抽象工厂模式：抽象工厂模式与工厂方法模式的区别就在于需要创建对象的复杂程度上。抽象工厂模式是三个里面最为抽象，最具有一般性的。用意在于给客户端提供一个接口，可以创建多个产品中的产品对象。 使用抽象工厂模式还要满足以下条件： （1）系统中有多个产品族，而系统一次只可能消费其中一族产品。 （2）同属于同属于同一产品族的产品一起使用。 //抽象产品 public abstract class BenC{ ​ public abstract void Driver( ); } //具体产品 public class BenCSportCar{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //具体产品 public class BenCBusinessCar{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //抽象产品 public abstract class BaoM{ ​ public abstract void Driver( ); } //具体产品 public class BaoMSportCar{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //具体产品 public class BaoM{SportCar{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //抽象工厂 public abstract class Driver{ public abstract BenCCar DriverBenCCar(); public abstract BaoMCar DriverBenCCar(); } //具体工厂 public class SportDriver( ){ ​ public BenCCar DriverBenCCar(){ ​ BenCSportCar bencSport=new BenCSportCar(); ​ return bencSport; ​ } ​ public BaoMCar DriverBaoMCar(){ ​ BaoMSportCar baomSport=new BaoMSportCar(); ​ return baomSport; ​ } } //具体工厂 public class BusinessDriver( ){ ​ public BenCCar DriverBenCCar(){ ​ BenCSportCar bencSport=new BenCSportCar(); ​ return bencSport; ​ } ​ public BaoMCar DriverBaoMCar(){ ​ BaoMSportCar baomSport=new BaoMSportCar(); ​ return baomSport; ​ } } //客户代码 public class Boss{ Driver d=new DriverBenC( ); Car car=d.DriverCar( ); car.Driver(); } 从上可以发现，增加一个产品族很简单，而增加一个新的产品会很复杂。抽象工厂模式一般用于具有产品树和产品族的场景下。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂、工厂方法、抽象工厂 使用方法与区别]]></title>
    <url>%2F2018%2Fcjn0dvsvz0000yknumikyb7vs%2F</url>
    <content type="text"><![CDATA[一、简单工厂模式​ 我们在实例化对象的时候通常用new关键字，但是有了工厂，我们在声明对象的时候就可以用到工厂了，使得代码更加灵活。是由一个工厂对象决定创建出哪一种产品类的实例。 //抽象产品 public abstract class Car{ ​ public abstract void Driver( ); } //具体产品 public class BenC{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //具体产品 public class BaoM{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //简单工厂 public class Driver( ){ ​ public static Car DriverCar (string carName){ ​ Car car; ​ if(carName)==”奔驰”){ ​ car=new BenC( ); ​ } ​ else{ ​ car=new BaoM( ); ​ } } //客户代码 public class Boss{ ​ Car car1=Driver.DriverCar(“奔驰”); ​ car1.Driver(); Car car2=Driver.DriverCar(“宝马”); car2.Driver(); } 优点： （1）简单工厂包含必要的判断逻辑，实现了对象的创建和使用的分离。 （2）客户端无需知道所创建的具体产品类的类名，只需要具体产品类对应的参数即可。 （3）在不修改客户端代码的情况下更换和增加具体产品类，提高了系统的灵活性。 缺点： 当产品修改时，工厂类也需要做相应的修改，违反了开—闭原则。 简单工厂模式适用于业务简单或者具体产品很少增加的情况。而对于复杂的业务环境不太适应。因此提出工厂方法模式。 二、工厂方法模式：​ 工厂方法模式是简单工厂的进一步延伸，这样说是因为简单工厂违反了开—闭原则，而工厂方法可以完美的解决这个问题。工厂方法不在工厂类中进行逻辑判断，程序可以为不同产品类提供不同的工厂。当使用工厂方法设计模式时，对象调用者需要与具体的工厂类耦合。 ​ 工厂方法模式的各个角色： ​ 抽象工厂角色：工厂方法模式的核心，它与应用程序无关。是具体工厂必须实现的接口或者必须继承的父类他由抽象类或者接口来实现。 ​ 具体工厂角色：它含有和具体逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 ​ 抽象产品角色：他是具体产品继承的父类或者是实现的接口。一般由抽象类或者接口来实现。 ​ 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。由具体类实现。 //抽象产品 public abstract class Car{ ​ public abstract void Driver( ); } //具体产品 public class BenC{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //具体产品 public class BaoM{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //抽象工厂 public abstract class Driver{ public abstract Car DriverCar(); } //具体工厂 public class DriverBenC( ){ ​ public Car DriverCar () ​ Car car=new BenC( ); ​ return car; } //具体工厂 public class DriverBaoM( ){ ​ public Car DriverCar () ​ Car car=new BaoM( ); ​ return car; } //客户代码 public class Boss{ Driver d=new DriverBenC( ); Car car=d.DriverCar( ); car.Driver(); } 优点： （1）工厂方法用来创建客户所需要的产品，同时隐藏了哪种产品具体类将被实例化的细节，用户只需要关注工厂，不需要关注创建的细节。 （2）当产品增加时，只需要增加对应的工厂就好，完全符合开放封闭性原则。 缺点： 抽象层的加入使得理解程度加大。 三、抽象工厂模式：抽象工厂模式与工厂方法模式的区别就在于需要创建对象的复杂程度上。抽象工厂模式是三个里面最为抽象，最具有一般性的。用意在于给客户端提供一个接口，可以创建多个产品中的产品对象。 使用抽象工厂模式还要满足以下条件： （1）系统中有多个产品族，而系统一次只可能消费其中一族产品。 （2）同属于同属于同一产品族的产品一起使用。 //抽象产品 public abstract class BenC{ ​ public abstract void Driver( ); } //具体产品 public class BenCSportCar{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //具体产品 public class BenCBusinessCar{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //抽象产品 public abstract class BaoM{ ​ public abstract void Driver( ); } //具体产品 public class BaoMSportCar{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //具体产品 public class BaoM{SportCar{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //抽象工厂 public abstract class Driver{ public abstract BenCCar DriverBenCCar(); public abstract BaoMCar DriverBenCCar(); } //具体工厂 public class SportDriver( ){ ​ public BenCCar DriverBenCCar(){ ​ BenCSportCar bencSport=new BenCSportCar(); ​ return bencSport; ​ } ​ public BaoMCar DriverBaoMCar(){ ​ BaoMSportCar baomSport=new BaoMSportCar(); ​ return baomSport; ​ } } //具体工厂 public class BusinessDriver( ){ ​ public BenCCar DriverBenCCar(){ ​ BenCSportCar bencSport=new BenCSportCar(); ​ return bencSport; ​ } ​ public BaoMCar DriverBaoMCar(){ ​ BaoMSportCar baomSport=new BaoMSportCar(); ​ return baomSport; ​ } } //客户代码 public class Boss{ Driver d=new DriverBenC( ); Car car=d.DriverCar( ); car.Driver(); } 从上可以发现，增加一个产品族很简单，而增加一个新的产品会很复杂。抽象工厂模式一般用于具有产品树和产品族的场景下。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂、工厂方法、抽象工厂 使用方法与区别]]></title>
    <url>%2F2018%2Fcjn0dvsww0008yknulhnz9gut%2F</url>
    <content type="text"><![CDATA[一、简单工厂模式​ 我们在实例化对象的时候通常用new关键字，但是有了工厂，我们在声明对象的时候就可以用到工厂了，使得代码更加灵活。是由一个工厂对象决定创建出哪一种产品类的实例。 //抽象产品 public abstract class Car{ ​ public abstract void Driver( ); } //具体产品 public class BenC{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //具体产品 public class BaoM{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //简单工厂 public class Driver( ){ ​ public static Car DriverCar (string carName){ ​ Car car; ​ if(carName)==”奔驰”){ ​ car=new BenC( ); ​ } ​ else{ ​ car=new BaoM( ); ​ } } //客户代码 public class Boss{ ​ Car car1=Driver.DriverCar(“奔驰”); ​ car1.Driver(); Car car2=Driver.DriverCar(“宝马”); car2.Driver(); } 优点： （1）简单工厂包含必要的判断逻辑，实现了对象的创建和使用的分离。 （2）客户端无需知道所创建的具体产品类的类名，只需要具体产品类对应的参数即可。 （3）在不修改客户端代码的情况下更换和增加具体产品类，提高了系统的灵活性。 缺点： 当产品修改时，工厂类也需要做相应的修改，违反了开—闭原则。 简单工厂模式适用于业务简单或者具体产品很少增加的情况。而对于复杂的业务环境不太适应。因此提出工厂方法模式。 二、工厂方法模式：​ 工厂方法模式是简单工厂的进一步延伸，这样说是因为简单工厂违反了开—闭原则，而工厂方法可以完美的解决这个问题。工厂方法不在工厂类中进行逻辑判断，程序可以为不同产品类提供不同的工厂。当使用工厂方法设计模式时，对象调用者需要与具体的工厂类耦合。 ​ 工厂方法模式的各个角色： ​ 抽象工厂角色：工厂方法模式的核心，它与应用程序无关。是具体工厂必须实现的接口或者必须继承的父类他由抽象类或者接口来实现。 ​ 具体工厂角色：它含有和具体逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 ​ 抽象产品角色：他是具体产品继承的父类或者是实现的接口。一般由抽象类或者接口来实现。 ​ 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。由具体类实现。 //抽象产品 public abstract class Car{ ​ public abstract void Driver( ); } //具体产品 public class BenC{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //具体产品 public class BaoM{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //抽象工厂 public abstract class Driver{ public abstract Car DriverCar(); } //具体工厂 public class DriverBenC( ){ ​ public Car DriverCar () ​ Car car=new BenC( ); ​ return car; } //具体工厂 public class DriverBaoM( ){ ​ public Car DriverCar () ​ Car car=new BaoM( ); ​ return car; } //客户代码 public class Boss{ Driver d=new DriverBenC( ); Car car=d.DriverCar( ); car.Driver(); } 优点： （1）工厂方法用来创建客户所需要的产品，同时隐藏了哪种产品具体类将被实例化的细节，用户只需要关注工厂，不需要关注创建的细节。 （2）当产品增加时，只需要增加对应的工厂就好，完全符合开放封闭性原则。 缺点： 抽象层的加入使得理解程度加大。 三、抽象工厂模式：抽象工厂模式与工厂方法模式的区别就在于需要创建对象的复杂程度上。抽象工厂模式是三个里面最为抽象，最具有一般性的。用意在于给客户端提供一个接口，可以创建多个产品中的产品对象。 使用抽象工厂模式还要满足以下条件： （1）系统中有多个产品族，而系统一次只可能消费其中一族产品。 （2）同属于同属于同一产品族的产品一起使用。 //抽象产品 public abstract class BenC{ ​ public abstract void Driver( ); } //具体产品 public class BenCSportCar{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //具体产品 public class BenCBusinessCar{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //抽象产品 public abstract class BaoM{ ​ public abstract void Driver( ); } //具体产品 public class BaoMSportCar{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //具体产品 public class BaoM{SportCar{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //抽象工厂 public abstract class Driver{ public abstract BenCCar DriverBenCCar(); public abstract BaoMCar DriverBenCCar(); } //具体工厂 public class SportDriver( ){ ​ public BenCCar DriverBenCCar(){ ​ BenCSportCar bencSport=new BenCSportCar(); ​ return bencSport; ​ } ​ public BaoMCar DriverBaoMCar(){ ​ BaoMSportCar baomSport=new BaoMSportCar(); ​ return baomSport; ​ } } //具体工厂 public class BusinessDriver( ){ ​ public BenCCar DriverBenCCar(){ ​ BenCSportCar bencSport=new BenCSportCar(); ​ return bencSport; ​ } ​ public BaoMCar DriverBaoMCar(){ ​ BaoMSportCar baomSport=new BaoMSportCar(); ​ return baomSport; ​ } } //客户代码 public class Boss{ Driver d=new DriverBenC( ); Car car=d.DriverCar( ); car.Driver(); } 从上可以发现，增加一个产品族很简单，而增加一个新的产品会很复杂。抽象工厂模式一般用于具有产品树和产品族的场景下。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2Fcjn0dvswz0009yknutyzgn4sr%2F</url>
    <content type="text"><![CDATA[title: 简单工厂、工厂方法、抽象工厂 使用方法与区别categories: 设计模式tags: 设计模式 一、简单工厂模式​ 我们在实例化对象的时候通常用new关键字，但是有了工厂，我们在声明对象的时候就可以用到工厂了，使得代码更加灵活。是由一个工厂对象决定创建出哪一种产品类的实例。 //抽象产品 public abstract class Car{ ​ public abstract void Driver( ); } //具体产品 public class BenC{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //具体产品 public class BaoM{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //简单工厂 public class Driver( ){ ​ public static Car DriverCar (string carName){ ​ Car car; ​ if(carName)==”奔驰”){ ​ car=new BenC( ); ​ } ​ else{ ​ car=new BaoM( ); ​ } } //客户代码 public class Boss{ ​ Car car1=Driver.DriverCar(“奔驰”); ​ car1.Driver(); Car car2=Driver.DriverCar(“宝马”); car2.Driver(); } 优点： （1）简单工厂包含必要的判断逻辑，实现了对象的创建和使用的分离。 （2）客户端无需知道所创建的具体产品类的类名，只需要具体产品类对应的参数即可。 （3）在不修改客户端代码的情况下更换和增加具体产品类，提高了系统的灵活性。 缺点： 当产品修改时，工厂类也需要做相应的修改，违反了开—闭原则。 简单工厂模式适用于业务简单或者具体产品很少增加的情况。而对于复杂的业务环境不太适应。因此提出工厂方法模式。 二、工厂方法模式：​ 工厂方法模式是简单工厂的进一步延伸，这样说是因为简单工厂违反了开—闭原则，而工厂方法可以完美的解决这个问题。工厂方法不在工厂类中进行逻辑判断，程序可以为不同产品类提供不同的工厂。当使用工厂方法设计模式时，对象调用者需要与具体的工厂类耦合。 ​ 工厂方法模式的各个角色： ​ 抽象工厂角色：工厂方法模式的核心，它与应用程序无关。是具体工厂必须实现的接口或者必须继承的父类他由抽象类或者接口来实现。 ​ 具体工厂角色：它含有和具体逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 ​ 抽象产品角色：他是具体产品继承的父类或者是实现的接口。一般由抽象类或者接口来实现。 ​ 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。由具体类实现。 //抽象产品 public abstract class Car{ ​ public abstract void Driver( ); } //具体产品 public class BenC{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //具体产品 public class BaoM{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //抽象工厂 public abstract class Driver{ public abstract Car DriverCar(); } //具体工厂 public class DriverBenC( ){ ​ public Car DriverCar () ​ Car car=new BenC( ); ​ return car; } //具体工厂 public class DriverBaoM( ){ ​ public Car DriverCar () ​ Car car=new BaoM( ); ​ return car; } //客户代码 public class Boss{ Driver d=new DriverBenC( ); Car car=d.DriverCar( ); car.Driver(); } 优点： （1）工厂方法用来创建客户所需要的产品，同时隐藏了哪种产品具体类将被实例化的细节，用户只需要关注工厂，不需要关注创建的细节。 （2）当产品增加时，只需要增加对应的工厂就好，完全符合开放封闭性原则。 缺点： 抽象层的加入使得理解程度加大。 三、抽象工厂模式：抽象工厂模式与工厂方法模式的区别就在于需要创建对象的复杂程度上。抽象工厂模式是三个里面最为抽象，最具有一般性的。用意在于给客户端提供一个接口，可以创建多个产品中的产品对象。 使用抽象工厂模式还要满足以下条件： （1）系统中有多个产品族，而系统一次只可能消费其中一族产品。 （2）同属于同属于同一产品族的产品一起使用。 //抽象产品 public abstract class BenC{ ​ public abstract void Driver( ); } //具体产品 public class BenCSportCar{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //具体产品 public class BenCBusinessCar{ ​ public void Driver( ){ ​ Console.WriteLine(“奔驰”); ​ } } //抽象产品 public abstract class BaoM{ ​ public abstract void Driver( ); } //具体产品 public class BaoMSportCar{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //具体产品 public class BaoM{SportCar{ ​ public void Driver( ){ ​ Console.WriteLine(“宝马”); ​ } } //抽象工厂 public abstract class Driver{ public abstract BenCCar DriverBenCCar(); public abstract BaoMCar DriverBenCCar(); } //具体工厂 public class SportDriver( ){ ​ public BenCCar DriverBenCCar(){ ​ BenCSportCar bencSport=new BenCSportCar(); ​ return bencSport; ​ } ​ public BaoMCar DriverBaoMCar(){ ​ BaoMSportCar baomSport=new BaoMSportCar(); ​ return baomSport; ​ } } //具体工厂 public class BusinessDriver( ){ ​ public BenCCar DriverBenCCar(){ ​ BenCSportCar bencSport=new BenCSportCar(); ​ return bencSport; ​ } ​ public BaoMCar DriverBaoMCar(){ ​ BaoMSportCar baomSport=new BaoMSportCar(); ​ return baomSport; ​ } } //客户代码 public class Boss{ Driver d=new DriverBenC( ); Car car=d.DriverCar( ); car.Driver(); } 从上可以发现，增加一个产品族很简单，而增加一个新的产品会很复杂。抽象工厂模式一般用于具有产品树和产品族的场景下。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于RESTful的理解]]></title>
    <url>%2F2018%2Fcjn0dvswh0002yknufyjdqevn%2F</url>
    <content type="text"><![CDATA[了解RESTful的起因学习springmvc的时候，在配置前端控制器中时有三种方式： 第一种：*.action，访问一、以.action结尾由DispatcherServlet进行解析。 第二种：/，所有访问的地址由DispatcherServlet进行解析，对于静态文件的解析需要配置不让DispatcherServlet进行解析，使用此种方法可以实现RESTful风格的url。 第三种：/*，这样配置不对使用此种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错。 由此了解到Resultful架构。 RESTful的介绍RESTful架构，就是目前最流行的一种互联网软件架构。具有结构清晰，符合标准，易于理解，扩展方便的优点。 RESTful的起源Roy Thomas Fielding 在2000年的博士论文提出来的。他在文中写到：“长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观评估不同的设计选择对系统行为的影响。而相反的，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽略的一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我写这篇问猴子那个的目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、事宜通信的架构。” Roy Thomas Fielding 将他对互联网软件的架构原则，命名为REST，，即Representational State Transfer的缩写。可翻译 为“表现层状态转化”。要理解RESTful的架构，最好的方法就是去理解Representational State Transfer词组的意思。 资源REST翻译为“表现层状态转化”，省略的主语，“表现层”其实指的是“资源”的“表现层”。 “资源”就是网络上的一个实体，或者说就是网络上的一个具体信息。可以是一短文本、一张图片、一首歌曲，总之就是一个具体的存在实体。可以用一个URI访问它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以。上网就是与互联网上一系列的“资源”互动，调用它的URI。 表现层“资源”是一种信息实体，它可以有多种外在表现形式。我们把“资源”具体呈现出来的形式，叫做它的“表现层”。 比如：文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JSP格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格的说，有些网址最后的“.html”后缀名是不必要的，因为这个后缀名表示格式，属于“表现层”范围，而URL只代表“资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Context-Type字段指定，这两个字段才是对“表现层”的描述。 状态转换访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，涉及到数据和状态的变化。 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器发生“状态转换”。而这种转换你是建立在表现层之上的，所以就是“表现层状态转换”。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表现操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种操作：GET用来获取资源，POST用来新建资源（也可用来更新资源），PUT用来更新资源，DELETE用来删除资源。 总结综合以上学习，总结RESTful架构： （1）每一个URI代表一种资源 （2）客户端和服务器之间，传递这种资源的表现层。 （3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现“表现层状态转换”。 常见错误（1）URI不能包含动词 ​ 因为“资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。 例如：网上汇款，从账户1向账户2汇款200元 ​ POST /accounts/1/transfer/200/to/2/ 正确的写法应该是：POST /transaction HTTP/1.1 ​ Host: 127.0.0.1 ​ from=1&amp;to=2&amp;account=200.00 （2）在URI中不能加入版本号 ​ http://www.example.com/app/1.0/foo ​ http://www.example.com/app/1.1/foo ​ http://www.example.com/app/2.0/foo 不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头的Accept字段中进行区分 Accept: vnd.example-com.foo+json; version=1.0 Accept: vnd.example-com.foo+json; version=1.1 Accept: vnd.example-com.foo+json; version=2.0]]></content>
      <categories>
        <category>RESTful架构</category>
      </categories>
      <tags>
        <tag>RESTful架构  URI资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2018%2Fcjn0dvt0o000nyknu0yv07826%2F</url>
    <content type="text"><![CDATA[​ 对于一个认真的程序员，在学习过程中总要写Blog来记录学习过程中的点点滴滴。踩过的坑终将变成成功道路上的跳板。 Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。经过搜索资料，不断学习，请教别人，最终搭建好了我的个人博客框架，在此写下整个过程分享。博文包括三个部分：构建基本框架、不断优化、补充内容。 ​ 构建基本框架：从最简单的相关软件介绍到搭建完成属于自己的独立博客。不断优化：在完成简单的搭建之后，不断美化自己的页面展示。补充内容包括了Hexo的语法以及。。。。。。。 构建基本框架： 基础准备：&nbsp; &nbsp; &nbsp; &nbsp;安装Git&nbsp; &nbsp; &nbsp; &nbsp;将本地的Hexo提交到GitHub上进行管理&nbsp; &nbsp; &nbsp; &nbsp;安装步骤：&nbsp; &nbsp; &nbsp; &nbsp;1.在Git官网上(https://git-scm.com/download/win) 下载Windows版本。&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;2.下载完成后，双击.msi文件安装至G:\blogresoft\git。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 安装NodeJs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hexo是基于NodeJs环境的静态博客，里面的npm工具很有用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装步骤：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.在Node.js官网(https://nodejs.org/en) 下载最新版本。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.点击最新64位的8.11.4LTS版本下载到G盘新建的blogresoft文件夹下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3：双击.msi文件安装，不断点击next即可安装成功至G:\blogresoft\nodejs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GitHub账号&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 没有GitHub账号的情况下,在官网页面注册一个新的即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 配置SSH Keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 配置SSH Keys 之后,每次对自己的博客改动之后，提交的时候,不再需要重新输入GitHub的账号的密码了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置步骤:在 G:\blogresoft\git文件夹下点击git-bash.exe，输入以下命令检查.ssh文件是否已经存在： 1$ ls -al ~/.ssh 不存在会出现提示： ls: cannot access ‘/c/User/Administrator/ .ssh’:No such file or directory 接着执行如下代码，生成.ssh文件夹： 1$ mkdir .ssh 进入.ssh文件夹： 1$ cd .ssh 输入如下代码： 123$ ssh-keygen -t rsa -C&quot;GitHub登陆邮箱&quot;$ id_rsa 按回车键，提示是否使用长密码，按回车，继续按回车，不使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将ssh公钥部分添加到GitHub，.ssh文件夹下后缀名为.pub的文件是公钥，右键打开方式选择写字板打开，复制其中所有的内容。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在GitHub网站右上角点击setting。点击左侧SSH and GPG keys，点击右上角New SSH key，在Key中粘贴.ssh文件夹下后缀名为.pub的文件的所有内容，点击Add SSH key添加公钥，此时公钥状态为黑色。 在G:\blogresoft\git文件夹下双击git-bash.exe，输入以下命令： 123$ git config --global user.name &quot;usename&quot;$ git config --global user.email &quot;email&quot; 其中usename为注册GitHub时的账户名，email为注册GitHub时的邮箱。 输入如下命令，测试SSH是否配置成功： 1$ ssh -T git@github.com 出现提示，输入yes回车，出现欢迎提示: Hi minminminzhang! Your’ve successfully authenticated,but GitHub does not provide shell access. 此时回到SSH and GPG keys处，公钥状态变为绿色。 新建仓库​ 在Git上新建一个仓库 在GitHub上新建一个仓库，并取名为your_username.github.io，其中your_username是您自己的GitHub账号名。 在本地写博客 在G:/blogresoft/git文件夹下新建一个index.html文件，并输入一下内容： 12345678&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;你好！这是我的第一篇博客&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 用Git把index.html提交到GitHub上，在cmd中输入以下命令： 123456789$ git init $ git add index.html $ git commit -m &quot;我的第一篇博客&quot;$ git remote add originhttps://github.com/your_username/your_username.github$ git push -u origin master 在浏览器中输入your_username.github.io即可访问文件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 hexo安装配置：*下载Hexo 下载官网： http://hexo.io github: https://github.com/hexojs/hexo 在G:/blogresoft/git文件夹下双击git-bash.exe 输入以下命令进行安装Hexo 1$ npm install -g hexo 在G:/blogresoft/git下安装文件夹hexo，并切换至Hexo工作目录 1$ cd hexo 初始化文件夹 1$ hexo init 安装hexo的扩展插件 1$ npm install 安装其他插件 1234$ npm install hexo-deployer-git -save$ npm install hexo-renderer-ejs -save$ npm install hexo-renderer-stylus -save$ npm install hexo-render-marked -save 生成静态页面 1$ hexo g 开启本地服务器 1$ hexo s 会出现提示： INFO Start processing INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop 此时：访问http://localhost:4000就可以看到刚刚创建的博客了。注意：若是无法访问，说明端口4000被占用了。可以输入如下的命令换端口试一下： 1$ hexo s -p 5000 更换后，访问http://localhost:5000进行查看。 *部署Hexo： 修改配置 修改站点配置文件G:/blogresoft/git/hexo/_config.yml,修改deploy项的内容： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: git@github.com:username/username.github.io.gitbranch: master 注意：1.hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，称为站点配置文件，一个是各个theme下的，称为主题配置文件； 2.type: repo: branch:分别和后面的内容之间有分隔输入下面的命令将Hexo博客部署到GitHub中： 清空静态页面 1$ hexo clean 生成静态页面 123$ hexo g$ npm install hexo -deployer-git -save 部署 1$ hexo d 在完成之后就可以访问https://minminminzhang.github.io,出现Hexo安装成功的页面提示。注意：我在最后一部配置的时候出现了仓库不存在的提示：出现这种错误，有两种原因： 1.修改站点文件时：仓库名输入有误 2.在部署之前没有执行$ npm install hexo -deployer-git -save还有一种错误的情况由G:/blogresoft/git/hexo下的.deploy_git隐藏文件所致,删除这个隐藏文件即可。完成之后进行重新部署： 12345$ hexo clean$ hexo g$ hexo d 重新访问进行验证。 不断优化更换主题 Hexo中G:/blogresoft/git/hexo/themes/landscape默认的主题很简陋，我们可以换成更美观的。本博客选择Next主题，简单美观，好配置。 下载主题： 在Next发布页面(https://github.com/iissnan/hexo-theme-next/releases) 下载最新版本hexo-theme-next-5.1.4。放在G:/blogresoft/git/hexo/themes文件夹下并改名为next。启用主题打开站点配置文件，在theme字段更改如下代码： 1theme： next 主题安装完成，在切换之前，用hexo clean来清除hexo的缓存。 验证主题： 启动Hexo本地站点，并开启调试模式： 1$ hexo s -debug 出现提示：INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop 此时使用浏览器访问http://localhost:4000，检查Next安装是否成功。Next安装成功之后的页面设置参考： https://blog.csdn.net/u012195214/article/details/79204088 写博客：定位到hexo根目录，执行命令： 1$ hexo new &apos;my first-blog&apos; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hexo会帮我们在 G:/blogresoft/git/hexo/source/_posts 下生成相关文件，我们只需要打开这个文件就可以开始写博客了。 当然也可以在G:/blogresoft/git/hexo/source/_posts 直接创建后缀为.md的文件。使用命令的好处是帮我们自动生成了时间。 &nbsp;&nbsp;&nbsp;&nbsp;打开文件，除了在文章开头部分的一些参数，比如标题(title:) 、创建时间(date:) 等，正文部分使用Markdown格式书写: 注意：NexT默认主页显示文章的全部内容，这对于有些很长的文章来说非常不美观，建议主页仅显示文章的摘要。 在合适的位置插入以下内容作为分隔符 1$ &lt;!--is more--&gt; 分隔符以前的内容将会在索引页上显示为摘要。 补充内容： Hexo常用命令： npm install hexo -g #安装npm update hexo -g #更新hexo init #初始化hexo publish [layout] #发表草稿。hexo n “name” #新建文章hexo g #生成静态网页hexo p #发表草稿。 hexo s #启动服务hexo d #部署网站 参数：-g 部署之前先生成静态文件。]]></content>
      <categories>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>搭建个人博客  相关技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2Fcjn0dvsx5000dyknuark681p6%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
