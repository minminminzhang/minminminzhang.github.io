<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用迭代算法解决汉诺塔问题]]></title>
    <url>%2F2018%2Fcjp6mvinn0006mgnuveoeerla%2F</url>
    <content type="text"><![CDATA[汉诺塔游戏可以简单描述为：n个盘子和3根柱子：A(起始柱子)、B(过渡柱子)、C(目的柱子)，盘子的大小不同且中间有一孔，可以将盘子“串”在柱子上，每个盘子只能放在比它大的盘子上面。起初，所有盘子在A柱上，问题是将盘子一个一个地从A柱子移动到C柱子。移动过程中，可以使用B柱，但盘子也只能放在比它大的盘子上面。 因此我们得出汉诺塔问题的以下几个限制条件： 1.在小圆盘上不能放大圆盘。 2.在三根柱子之间一回只能移动一个圆盘。 3.只能移动在最顶端的圆盘。 首先，我们从简单的例子开始分析，然后再总结出一般规律： 1.当n=1的时候，即此时只有一个盘子，那么直接将其移动至C即可。移动过程就是 A -&gt; C 2.当n=2的时候，这时候有两个盘子，那么在一开始移动的时候，我们需要借助B柱作为过渡的柱子，即将A柱最上面的那个小圆盘移至B柱，然后将A柱底下的圆盘移至C柱，最后将B柱的圆盘移至C柱即可。那么完整移动过程就是A -&gt; B , A -&gt; C , B -&gt; C 3.当n=3的时候，那么此时从上到下依次摆放着从小到大的三个圆盘，根据题目的限制条件：在小圆盘上不能放大圆盘，而且把圆盘从A柱移至C柱后，C柱圆盘的摆放情况和刚开始A柱的是一模一样的。所以呢，我们每次移至C柱的圆盘（移至C柱后不再移到其他柱子上去），必须是从大到小的，即一开始的时候，我们应该想办法把最大的圆盘移至C柱，然后再想办法将第二大的圆盘移至C柱……然后重复这样的过程，直到所有的圆盘都按照原来A柱摆放的样子移动到了C柱。 那么根据这样的思路，思考如何才能够将最大的盘子移至C柱？ 要将最大的盘子移至C柱，那么必然要先搬掉A柱上面的n-1个盘子，而C柱一开始的时候是作为目标柱的，所以我们可以用B柱作为”暂存”这n-1个盘子的过渡柱，当把这n-1的盘子移至B柱后，我们就可以把A柱最底下的盘子移至C柱了。 我们来看看现在各个柱子上盘子的情况，A柱上无盘子，而B柱从上到下依次摆放着从小到大的n-1个盘子，C柱上摆放着最大的那个盘子。 所以接下来那就是要把B柱这剩下的n-1个盘子移至C柱，那么我们需要借助A柱，将A柱作为新的”过渡”柱，B柱为初始柱，将这n-1个盘子移至目标C柱。 123456789101112131415public class HanoiTower&#123; topN：移动的盘子数 from：初始柱子 to：目的柱子 inter：过渡柱子 public static void doTower(int topN,char from,char inter ,char to)&#123; if(topN==1)&#123; System.out.println(&quot;盘子1，从”+from+“柱子到”+to+&quot;柱子&quot;); &#125;else&#123; doTower(topN-1,from,to ,inter); System.out.println(&quot;盘子&quot;+topN+&quot;，从&quot;+from+“柱子到”+to+&quot;柱子&quot;); doTower(topN-1,inter,from ,to); &#125; &#125;&#125; 测试：12345public class TestHanoiTower&#123; public class void main(String [] args)&#123; HanoiTower.doTower(3,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;); &#125; &#125; ​ 程序结果为：盘子1，从A柱子到C柱子 盘子2，从A柱子到B柱子 盘子1，从C柱子到B柱子 盘子3，从A柱子到C柱子 盘子1，从B柱子到A柱子 盘子2，从B柱子到C柱子 盘子1，从A柱子到C柱子 即我们用迭代算法解决了汉诺塔问题。]]></content>
      <categories>
        <category>迭代算法</category>
      </categories>
      <tags>
        <tag>迭代算法 汉诺塔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架总结]]></title>
    <url>%2F2018%2Fcjp6mvin70002mgnubs05m91w%2F</url>
    <content type="text"><![CDATA[对于java程序员，Spring是做多使用，也必须掌握的框架之一。Spring是一站式的开源框架解决方案。 1.Spring的核心：AOP 、IOC（1）AOP：面向切面编程，扩展功能不是修改源代码实现。 （2）IOC：控制反转。IOC操作时把对象的创建交给Springl进行管理，IOC 操作包括IOC的配置文件文件方式和IOC的注解方式。 2.Spring的bean管理（xml方式）（1）bean实例化的方式 1）在Spring里面通过配置文件创建对象 2）bean实例化的三种方式 ①：使用类的无参数构造创建 注意：这样的前提是该类存在无参数的构造方法，如果类里面没有参数的构造，会出现异常：No default constructor found； ②：使用静态工厂创建，创建静态的方法，返回类对象。 12345public class Bean1Factory&#123; public static Bean1 getBean1( )&#123; return new Bean1( ); &#125; &#125; 1&lt;bean id=&quot;bean1&quot; class=&quot;cn.xidiaa.bean.Bean1Factory&quot; factory-method=&quot;&quot;getBean1&gt;&lt;/bean&gt; ③：使用实例工厂创建 ，创建不是静态的方法，返回类对象。 12345public class Bean2Factory&#123; public Bean2 getBean2( )&#123; return new Bean2( ); &#125; &#125; (2) Bean标签常用属性 1）id属性：起名称，id属性值名称任意命名。 ? id属性值，不能包含特殊符号。根据id值得到配置对象。 2）class属性：创建对象所在类的全路径。 3）name属性：功能和id属性是一样的，id属性值不能包含特殊符号，但是在name属性值里面可以包含特殊符号。 4）scope属性 1234-singleton：默认值，单例 scope=“singleton” cn.xidiaa.ioc.User@1be3a66 cn.xidiaa.ioc.User@1be3a66-prototype:多例 cn.xidiaa.ioc.User@e90eef cn.xidiaa.ioc.User@d381e4 （3）属性注入介绍 1）创建对象的时候，像类里面属性里面设置值。 2）属性注入的方式介绍（三种方式） ​ 三种方式包括：使用set方法注入，有参数构造注入，使用接口注入。 在Spring框架里面，支持前两种方式： ①：使用有参数构造注入属性。 123&lt;bean id=&quot;demo&quot; class=&quot;cn.xidiaa.property.PropertyDemo1&quot;&gt; &lt;constructor-arg name=&quot;username&quot; value=&quot;jery&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 1234567private String username; public PropertyDemo(String username)&#123; this.username=username; &#125; public void test1()&#123; System.out.println(&quot;demo......&quot;+username); &#125; ②：使用set方法注入属性 1234private String bookname; public void setBookname(String bookname)&#123; this.bookname=bookname; &#125; 123&lt;bean id=&quot;book&quot; class=&quot;cn.xidiaa.property.Book&quot;&gt; &lt;property name=&quot;bookname&quot; value=&quot;方漫图&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 3）注入对象类型属性：xml方式 ①：创建service类和dao类 在service得到dao对象 ②：具体实现过程 在service里面把dao作为类型属性，生成dao类型属性的set方法。 123456public class UserService &#123; private UserDao userDao; public void setUserDao(UserDao uesrDao)&#123; this.userDao=userDao; &#125; &#125; ③：配置文件中注入关系 1234&lt;bean id=&quot;userDao&quot; class=&quot;cn.xidiaa.ioc.UserDao&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;cn.xidiaa.ioc.UserService&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 4)基于注解方式的bean创建以及注入 因为Spring注解的实现是需要AOP的支持，因此在依赖方面需要注意，其次，要在XML中开启注解扫描： &lt;context:component-scan base-package=&quot;&quot; /&gt; 实际上这个配置，会让Spring在指定包下扫描，把带有注解标志的bean实例化，并且会进行属性注入。 创建对象的4个注解： @Component/@Controller/@Service/@Repository在这4个注解上，通过value属性来指定bean的id，通过@scope配合来声明单例OR多例。 注入属性： @Autowired/@Resource/@Qualifier 注意：@Resource是javax包下的，就是J2EE提供的；而@Autowired是Spring提供的。（不必提供setter方法） @Resource默认按照名称注入，如果找不到才按照类型注入。 @Autowired默认按照类型注入，可以结合@Qualifier进行名称注入。 注意：如果@Autowired进行类型注入，很可能类型会有多个满足（多态），那么到底注入哪个呢？所以说，如果按照@Autowired类型注入，一定注意结合@Qualifier。实际开发中，显然，注入应该是确定的，那么按照名称注入，应该是首选！ 3.Spring事务管理Spring的声明式事务管理，用的最多的就是基于注解的方式。首先我们得配置一个事务管理器，而事务管理器需要我们注入DataSource。 123&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;tx:annotation-driven/&gt; 对于多个数据源，需要定义多个事务管理器，同时也得开启事务注解。过个事务管理器，可以通过Qualifier属性进行区分。 配置完毕后，直接在service层的类或者方法上，使用@Transactional(value = “gcs”, rollbackFor = Exception.class) 4.Spring整合web项目原理?1）加载Spring核心配置文件 1ApplicationContext context=new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); new对象，功能可以实现，效率很低。 2）实现思想：把加载配置文件和创建对象过程，在服务器启动时候完成。 3）实现原理： ①：ServletContext对象 ②：监听器 ③：具体使用 ——在服务器启动的时候，为每个项目创建一个ServletContext对象 ——在ServletContext对象创建的时候，使用监听器可以具体到ServletContext对象在什么时候创建 ——使用监听器听到ServletContext对象创建的时候，加载spring配置文件，把配置文件配置对象创建 ——把创建出来的对象放到ServletContext域对象里面（setAttribute方法） ——获取对象的时候，到ServletContext域里面得到（getAttribute方法） 5.补充（1）.IOC和DI区别 1）IOC: 控制反转，把对象创建交给spring进行配置 2）DI: 依赖注入，向类里面的属性中设置值 3）关系：依赖注入不能单独存在，需要在ioc基础之上完成操作 （2）.关于AOP的几个重点概念： 1）AOP的实现，一种横向抽取机制，依赖于动态代理模式。 2）JoinPoint：连接点，说白了，就是可以被增强的方法； 3）PointCut：切入点，对哪些JoinPoint进行拦截； 4）Advice：通知，就是拦截后的动作； 5）Aspect：切面，把增强应用到具体方法的过程； Spring的AOP需要借助aspectj来实现，可以通过XML，也可以通过注解来完成。 比如，采用XML方式的话，需要指明用A类的哪个方法对B类的哪些方法上进行增强，这里就涉及到execution表达式了； 比如，采用注解方式的话，就更加简单了，先在XML中开启AOP（&lt;aop:aspectj-autoproxy /&gt;），然后在增强方法上直接使用类似@Before(value=”execution(具体的表达式)”)就可以了；其实在实际开发中，我们对于AOP最常用的就是事务了。]]></content>
      <categories>
        <category>Spring框架 </category>
      </categories>
      <tags>
        <tag>Springl整合web项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小顽童项目准备]]></title>
    <url>%2F2018%2Fcjp6mviny0009mgnulfn2w8ca%2F</url>
    <content type="text"><![CDATA[基于前期的学习，为了进一步用以实践，我们准备开发一个小网站—–小顽童。 涉及到：1.前端 2.后台 3.移动端 网站的内容： 1.板块（论坛，可以参考西电睿思），具体主题未定，大家均可以提出意见，然后进行业务开发。 2.工具，提供常用查询，如天气查询，列车时刻查询，远程查询 ，IP详情，电话详情，遥控等等。 3.自定义模块 涉及到的技术： 工具：IDEA,maven,git(github),wiki 容器：tomcat7及以上，推荐9 前端：html+css+js(Ajax) 前端框架：vue.js 后台：jsp/servlet 框架：spring/springmvc/mybatis 移动端：推荐webApp 数据库：mysql 美工：ps,图标尽量在阿里巴巴矢量图标库下载，美图秀秀也可以。 本次项目分工明确：我作为项目参与者，主要负责后台开发。 一.首先，安装开发工具IDEAIDEA的安装以及破解步骤： 1.从睿思或者官网下载最新的IDEA软件到本地。 2.双击安装，选择合适的下载路径。 3.安装完毕后，先不要打开。 4.开始破解： 5.首先更改hosts文件。（位置：C:\Windows\System32\drives\etc）。 6.使用文本编译器打开hosts 在最后一行添加：0.0.0.0 account.jetbrains.com!1540689850659] 7.打开运行idea，会提示让你注册，有三种方式，下面就是注册码，copy进去确认即可。 K71U8DBPNE-eyJsaWNlbnNlSWQiOiJLNzFVOERCUE5FIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifV0sImhhc2giOiI4OTA4Mjg5LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-Owt3/+LdCpedvF0eQ8635yYt0+ZLtCfIHOKzSrx5hBtbKGYRPFDrdgQAK6lJjexl2emLBcUq729K1+ukY9Js0nx1NH09l9Rw4c7k9wUksLl6RWx7Hcdcma1AHolfSp79NynSMZzQQLFohNyjD+dXfXM5GYd2OTHya0zYjTNMmAJuuRsapJMP9F1z7UTpMpLMxS/JaCWdyX6qIs+funJdPF7bjzYAQBvtbz+6SANBgN36gG1B2xHhccTn6WE8vagwwSNuM70egpahcTktoHxI7uS1JGN9gKAr6nbp+8DbFz3a2wd+XoF3nSJb/d2f/6zJR8yJF8AOyb30kwg3zf5cWw==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog== 二.安装git，这里默认都是Windows系统。1.登陆git官网，下载windows版的进行安装，选择安装路径，其他均选择默认配置。 2.安装成功后，验证是否成功（打开git bash，输入git–version）。 3.检查用户名和邮箱是否配置（git config –global –list） 4.如果没有，进行配置。 设置用户名：git config –global user.name “xxx” 设置邮箱：git config –global user.email “xxxxx” 5.生成ssh-key（ssh-keygen -t rsa -C “你的email”） 整个过程一直回车，有需要yes/no,就yes。最后会生成一份ssh私钥和一份公钥。 6.打开公钥位置，发给项目管理人。 三.申请github账号申请成功后，将用户名一并发给项目管理人。 四.用码云进行一个简单的前后端测试1.进入：http://gitee.com/ 搜索到urchin_board，然后进行fork。 2.切换到alpha分支上面，创建一个txt文件，进行PR操作，则成功进入到项目组织里面。 五.安装tomcat9 安装方式：http://tomcat.apache.org/ 六.安装maven安装教程为：https://blog.csdn.net/t_1025/article/details/70148793 中央仓库建议用阿里巴巴，这样速度更快一些 七.在idea上进行git操作1.File-setting-Gitee，点击Install。 2.安装成功后，进行如下操作。 ​ crtl+alt+s到界面：Version Control-Gitee-Creat API Token-输入码云的账号和密码-Test 3.接下来用git拉取项目 (1)File–New–Project from Version Control–Git (2)复制仓库时：要求输入URL和Directory。 4，在码云中，切换到alpha，点击克隆/下载，复制链接到URL，进行克隆，克隆成功后就可以看到新建的文件了。 注意：当遇到URL没有错误，但克隆失败时，检查是否已经添加了ssh-key，如果没有则先进行添加之后再克隆代码。 5.点击同步之后，检查idea页面最下方是否存在Terminal和Git：master。 6.创建分支 git checkout -b “分支名-alpha” 创建成功之后，右下角出现分支名–Git：minminminzhang。 八.接下来进行项目的同步操作。1.编写pom.xml,一人编写，其他人同步即可。编写完成之后，进行pull操作。 pull操作可以用git命令： git stash git pull origin master git stash pop 还有一种就是：右击项目-Git-Repository-Pull，始终选择origin/alpha. 就可以看到pom.xml进行更新了，更新完成之后有290行代码。 2.整合SSM框架 https://www.cnblogs.com/hackyo/p/6646051.html 九.运行项目1，重新登录码云，有可能过期了。 Alt+Ctrl+s–Gitee–Create API Token–Test 2，再配置一下tomcat服务器 (1)点击项目urchin右边的倒三角Edit Configurations (2)在Run/Debug Configurations页面：点击最上面的“+”号–Maven–选择项目urchin–在Command ling行选择tomact：run，应用保存。 3，测试，运行 在index.jsp页面简单的写一个程序。 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;style&gt; p&#123; font-size: 50px; color:aquamarine; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2 &lt;p&gt;小顽童项目开始了&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 点击运行： 下方出现一行[INFO] Running war on http://localhost:9091/urchin 即访问此网址就可以看到运行结果。 以上准备工作完成之后，我们就可以进行项目的设计开发了。]]></content>
      <categories>
        <category>开发项目准备工作</category>
      </categories>
      <tags>
        <tag>开发项目准备  相关技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中常用设计模式的使用方法与区别]]></title>
    <url>%2F2018%2Fcjp6mvj1x000omgnut5kctmvy%2F</url>
    <content type="text"><![CDATA[设计模式其实就是一套被反复使用的代码设计经验的总结。 使用设计模式的优点就是：代码可以重用，更容易被他人理解，保证代码的可靠性。 Java中的设计模式以供有23种，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。 一、简单工厂模式​ 我们在实例化对象的时候通常用new关键字，但是有了工厂，我们在声明对象的时候就可以用到工厂了，使得代码更加灵活。是由一个工厂对象决定创建出哪一种产品类的实例。 1234//抽象产品public abstract class Car&#123; public abstract void Driver( );&#125; 123456//具体产品public class BenC&#123; public void Driver( )&#123; Console.WriteLine(&quot;奔驰&quot;); &#125;&#125; 1234567//具体产品public class BaoM&#123; public void Driver( )&#123; Console.WriteLine(&quot;宝马&quot;); &#125;&#125; 123456789101112//简单工厂public class Driver( )&#123; public static Car DriverCar (string carName)&#123; Car car; if(carName)==&quot;奔驰&quot;)&#123; car=new BenC( ); &#125; else&#123; car=new BaoM( ); &#125;&#125; 1234567//客户代码public class Boss&#123; Car car1=Driver.DriverCar(&quot;奔驰&quot;); car1.Driver(); Car car2=Driver.DriverCar(&quot;宝马&quot;); car2.Driver();&#125; 优点： （1）简单工厂包含必要的判断逻辑，实现了对象的创建和使用的分离。 （2）客户端无需知道所创建的具体产品类的类名，只需要具体产品类对应的参数即可。 （3）在不修改客户端代码的情况下更换和增加具体产品类，提高了系统的灵活性。 缺点： 当产品修改时，工厂类也需要做相应的修改，违反了开—闭原则。 简单工厂模式适用于业务简单或者具体产品很少增加的情况。而对于复杂的业务环境不太适应。因此提出工厂方法模式。 二、工厂方法模式：​ 工厂方法模式是简单工厂的进一步延伸，这样说是因为简单工厂违反了开—闭原则，而工厂方法可以完美的解决这个问题。工厂方法不在工厂类中进行逻辑判断，程序可以为不同产品类提供不同的工厂。当使用工厂方法设计模式时，对象调用者需要与具体的工厂类耦合。 ​ 工厂方法模式的各个角色： ​ 抽象工厂角色：工厂方法模式的核心，它与应用程序无关。是具体工厂必须实现的接口或者必须继承的父类他由抽象类或者接口来实现。 ​ 具体工厂角色：它含有和具体逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 ​ 抽象产品角色：他是具体产品继承的父类或者是实现的接口。一般由抽象类或者接口来实现。 ​ 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。由具体类实现。 1234//抽象产品public abstract class Car&#123; public abstract void Driver( );&#125; 123456//具体产品public class BenC&#123; public void Driver( )&#123; Console.WriteLine(&quot;奔驰&quot;); &#125;&#125; 1234567//具体产品public class BaoM&#123; public void Driver( )&#123; Console.WriteLine(&quot;宝马&quot;); &#125;&#125; 1234//抽象工厂public abstract class Driver&#123; public abstract Car DriverCar();&#125; 123456//具体工厂public class DriverBenC( )&#123; public Car DriverCar () Car car=new BenC( ); return car; &#125; 123456//具体工厂public class DriverBaoM( )&#123; public Car DriverCar () Car car=new BaoM( ); return car; &#125; 123456//客户代码public class Boss&#123;Driver d=new DriverBenC( ); Car car=d.DriverCar( ); car.Driver(); &#125; 优点： （1）工厂方法用来创建客户所需要的产品，同时隐藏了哪种产品具体类将被实例化的细节，用户只需要关注工厂，不需要关注创建的细节。 （2）当产品增加时，只需要增加对应的工厂就好，完全符合开放封闭性原则。 缺点： 抽象层的加入使得理解程度加大。 三、抽象工厂模式：抽象工厂模式与工厂方法模式的区别就在于需要创建对象的复杂程度上。抽象工厂模式是三个里面最为抽象，最具有一般性的。用意在于给客户端提供一个接口，可以创建多个产品中的产品对象。 使用抽象工厂模式还要满足以下条件： （1）系统中有多个产品族，而系统一次只可能消费其中一族产品。 （2）同属于同属于同一产品族的产品一起使用。 1234//抽象产品public abstract class BenC&#123; public abstract void Driver( );&#125; 123456//具体产品public class BenCSportCar&#123; public void Driver( )&#123; Console.WriteLine(&quot;奔驰&quot;); &#125;&#125; 123456//具体产品public class BenCBusinessCar&#123; public void Driver( )&#123; Console.WriteLine(&quot;奔驰&quot;); &#125;&#125; 1234//抽象产品public abstract class BaoM&#123; public abstract void Driver( );&#125; 123456//具体产品public class BaoMSportCar&#123; public void Driver( )&#123; Console.WriteLine(&quot;宝马&quot;); &#125;&#125; 123456//具体产品public class BaoM&#123;SportCar&#123; public void Driver( )&#123; Console.WriteLine(&quot;宝马&quot;); &#125;&#125; 12345//抽象工厂public abstract class Driver&#123; public abstract BenCCar DriverBenCCar(); public abstract BaoMCar DriverBenCCar();&#125; 1234567891011//具体工厂public class SportDriver( )&#123; public BenCCar DriverBenCCar()&#123; BenCSportCar bencSport=new BenCSportCar(); return bencSport; &#125; public BaoMCar DriverBaoMCar()&#123; BaoMSportCar baomSport=new BaoMSportCar(); return baomSport; &#125;&#125; 1234567891011//具体工厂public class BusinessDriver( )&#123; public BenCCar DriverBenCCar()&#123; BenCSportCar bencSport=new BenCSportCar(); return bencSport; &#125; public BaoMCar DriverBaoMCar()&#123; BaoMSportCar baomSport=new BaoMSportCar(); return baomSport; &#125;&#125; 123456//客户代码public class Boss&#123;Driver d=new DriverBenC( ); Car car=d.DriverCar( ); car.Driver(); &#125; 从上可以发现，增加一个产品族很简单，而增加一个新的产品会很复杂。抽象工厂模式一般用于具有产品树和产品族的场景下。 补充： 1.单例模式，一个类只有一个实例存在。存在两种不同形式的单例： 第一种形式：饿汉式单例 123456789public class Singleton&#123; private Singleton()&#123; &#125; //在内部定义一个实例，private，只供内部使用。 private static Singleton instance =new Singleton(); //提供了一个供外部访问本class的静态方法，可以直接访问。 public static Singleton getInstance()&#123; return instance; &#125;&#125; 第二种：懒汉式单例 12345678910public class Singleton&#123; private static Singleton instace=null; private Singleton()&#123;&#125; public static synchronized Singleton getInstance()&#123; //比上面的方法有所改进，不用每次都进行声称对象，只是第一次使用时生成实例，提高了效率! if(instance==null) instance =newSingleton(); return instance; &#125;&#125; 单例的特点：外界无法通过构造器来创建对象，该类必须提供一个静态方法向外界提供该类的唯一实例。 2.在开发中常用的设计模式 （1）工厂模式：工厂类可以根据条件生成不同的子类对象，这些子类有一个公共的抽象父类并且实现的相同的方法，但这些方法针对不同的数据进行了不同的操作。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 （2）代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可分为：远程代理、虚拟代理、保护代理、Cache 代理、防火墙代理、同步化代理、智能引用代理。 （3）适配器模式：把一个类的接口变成客户所期待的另一种接口，从而使原本因接口不匹配而无法一起使用的类能够一起工作。 （4）模板方式模式：提供一个抽象类，将部分逻辑以具体方式或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于RESTful的理解]]></title>
    <url>%2F2018%2Fcjp6mvimk0000mgnu7ygabey6%2F</url>
    <content type="text"><![CDATA[了解RESTful的起因学习springmvc的时候，在配置前端控制器中时有三种方式： 第一种：*.action，访问一、以.action结尾由DispatcherServlet进行解析。 第二种：/，所有访问的地址由DispatcherServlet进行解析，对于静态文件的解析需要配置不让DispatcherServlet进行解析，使用此种方法可以实现RESTful风格的url。 第三种：/*，这样配置不对使用此种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错。 由此了解到Resultful架构。 RESTful的介绍RESTful架构，就是目前最流行的一种互联网软件架构。具有结构清晰，符合标准，易于理解，扩展方便的优点。 RESTful的起源Roy Thomas Fielding 在2000年的博士论文提出来的。他在文中写到：“长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观评估不同的设计选择对系统行为的影响。而相反的，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽略的一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我写这篇问猴子那个的目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、事宜通信的架构。” Roy Thomas Fielding 将他对互联网软件的架构原则，命名为REST，，即Representational State Transfer的缩写。可翻译 为“表现层状态转化”。要理解RESTful的架构，最好的方法就是去理解Representational State Transfer词组的意思。 资源REST翻译为“表现层状态转化”，省略的主语，“表现层”其实指的是“资源”的“表现层”。 “资源”就是网络上的一个实体，或者说就是网络上的一个具体信息。可以是一短文本、一张图片、一首歌曲，总之就是一个具体的存在实体。可以用一个URI访问它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以。上网就是与互联网上一系列的“资源”互动，调用它的URI。 表现层“资源”是一种信息实体，它可以有多种外在表现形式。我们把“资源”具体呈现出来的形式，叫做它的“表现层”。 比如：文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JSP格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格的说，有些网址最后的“.html”后缀名是不必要的，因为这个后缀名表示格式，属于“表现层”范围，而URL只代表“资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Context-Type字段指定，这两个字段才是对“表现层”的描述。 状态转换访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，涉及到数据和状态的变化。 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器发生“状态转换”。而这种转换你是建立在表现层之上的，所以就是“表现层状态转换”。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表现操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种操作：GET用来获取资源，POST用来新建资源（也可用来更新资源），PUT用来更新资源，DELETE用来删除资源。 总结综合以上学习，总结RESTful架构： （1）每一个URI代表一种资源 （2）客户端和服务器之间，传递这种资源的表现层。 （3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现“表现层状态转换”。 常见错误（1）URI不能包含动词 ​ 因为“资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。 例如：网上汇款，从账户1向账户2汇款200元 ​ POST /accounts/1/transfer/200/to/2/ 正确的写法应该是：POST /transaction HTTP/1.1 ​ Host: 127.0.0.1 ​ from=1&amp;to=2&amp;account=200.00 （2）在URI中不能加入版本号 ​ http://www.example.com/app/1.0/foo ​ http://www.example.com/app/1.1/foo ​ http://www.example.com/app/2.0/foo 不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头的Accept字段中进行区分 Accept: vnd.example-com.foo+json; version=1.0 Accept: vnd.example-com.foo+json; version=1.1 Accept: vnd.example-com.foo+json; version=2.0]]></content>
      <categories>
        <category>RESTful架构</category>
      </categories>
      <tags>
        <tag>RESTful架构  URI资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2018%2Fcjp6mvj20000pmgnumy4c0ka6%2F</url>
    <content type="text"><![CDATA[​ 对于一个认真的程序员，在学习过程中总要写Blog来记录学习过程中的点点滴滴。踩过的坑终将变成成功道路上的跳板。 Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。经过搜索资料，不断学习，请教别人，最终搭建好了我的个人博客框架，在此写下整个过程分享。博文包括三个部分：构建基本框架、不断优化、补充内容。 ​ 构建基本框架：从最简单的相关软件介绍到搭建完成属于自己的独立博客。不断优化：在完成简单的搭建之后，不断美化自己的页面展示。补充内容包括了Hexo的语法以及。。。。。。。 构建基本框架： 基础准备：&nbsp; &nbsp; &nbsp; &nbsp;安装Git&nbsp; &nbsp; &nbsp; &nbsp;将本地的Hexo提交到GitHub上进行管理&nbsp; &nbsp; &nbsp; &nbsp;安装步骤：&nbsp; &nbsp; &nbsp; &nbsp;1.在Git官网上(https://git-scm.com/download/win) 下载Windows版本。&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;2.下载完成后，双击.msi文件安装至G:\blogresoft\git。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 安装NodeJs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hexo是基于NodeJs环境的静态博客，里面的npm工具很有用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装步骤：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.在Node.js官网(https://nodejs.org/en) 下载最新版本。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.点击最新64位的8.11.4LTS版本下载到G盘新建的blogresoft文件夹下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3：双击.msi文件安装，不断点击next即可安装成功至G:\blogresoft\nodejs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GitHub账号&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 没有GitHub账号的情况下,在官网页面注册一个新的即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 配置SSH Keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 配置SSH Keys 之后,每次对自己的博客改动之后，提交的时候,不再需要重新输入GitHub的账号的密码了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置步骤:在 G:\blogresoft\git文件夹下点击git-bash.exe，输入以下命令检查.ssh文件是否已经存在： 1$ ls -al ~/.ssh 不存在会出现提示： ls: cannot access ‘/c/User/Administrator/ .ssh’:No such file or directory 接着执行如下代码，生成.ssh文件夹： 1$ mkdir .ssh 进入.ssh文件夹： 1$ cd .ssh 输入如下代码： 123$ ssh-keygen -t rsa -C&quot;GitHub登陆邮箱&quot;$ id_rsa 按回车键，提示是否使用长密码，按回车，继续按回车，不使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将ssh公钥部分添加到GitHub，.ssh文件夹下后缀名为.pub的文件是公钥，右键打开方式选择写字板打开，复制其中所有的内容。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在GitHub网站右上角点击setting。点击左侧SSH and GPG keys，点击右上角New SSH key，在Key中粘贴.ssh文件夹下后缀名为.pub的文件的所有内容，点击Add SSH key添加公钥，此时公钥状态为黑色。 在G:\blogresoft\git文件夹下双击git-bash.exe，输入以下命令： 123$ git config --global user.name &quot;usename&quot;$ git config --global user.email &quot;email&quot; 其中usename为注册GitHub时的账户名，email为注册GitHub时的邮箱。 输入如下命令，测试SSH是否配置成功： 1$ ssh -T git@github.com 出现提示，输入yes回车，出现欢迎提示: Hi minminminzhang! Your’ve successfully authenticated,but GitHub does not provide shell access. 此时回到SSH and GPG keys处，公钥状态变为绿色。 新建仓库​ 在Git上新建一个仓库 在GitHub上新建一个仓库，并取名为your_username.github.io，其中your_username是您自己的GitHub账号名。 在本地写博客 在G:/blogresoft/git文件夹下新建一个index.html文件，并输入一下内容： 12345678&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;你好！这是我的第一篇博客&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 用Git把index.html提交到GitHub上，在cmd中输入以下命令： 123456789$ git init $ git add index.html $ git commit -m &quot;我的第一篇博客&quot;$ git remote add originhttps://github.com/your_username/your_username.github$ git push -u origin master 在浏览器中输入your_username.github.io即可访问文件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 hexo安装配置：*下载Hexo 下载官网： http://hexo.io github: https://github.com/hexojs/hexo 在G:/blogresoft/git文件夹下双击git-bash.exe 输入以下命令进行安装Hexo 1$ npm install -g hexo 在G:/blogresoft/git下安装文件夹hexo，并切换至Hexo工作目录 1$ cd hexo 初始化文件夹 1$ hexo init 安装hexo的扩展插件 1$ npm install 安装其他插件 1234$ npm install hexo-deployer-git -save$ npm install hexo-renderer-ejs -save$ npm install hexo-renderer-stylus -save$ npm install hexo-render-marked -save 生成静态页面 1$ hexo g 开启本地服务器 1$ hexo s 会出现提示： INFO Start processing INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop 此时：访问http://localhost:4000就可以看到刚刚创建的博客了。注意：若是无法访问，说明端口4000被占用了。可以输入如下的命令换端口试一下： 1$ hexo s -p 5000 更换后，访问http://localhost:5000进行查看。 *部署Hexo： 修改配置 修改站点配置文件G:/blogresoft/git/hexo/_config.yml,修改deploy项的内容： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: git@github.com:username/username.github.io.gitbranch: master 注意：1.hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，称为站点配置文件，一个是各个theme下的，称为主题配置文件； 2.type: repo: branch:分别和后面的内容之间有分隔输入下面的命令将Hexo博客部署到GitHub中： 清空静态页面 1$ hexo clean 生成静态页面 123$ hexo g$ npm install hexo -deployer-git -save 部署 1$ hexo d 在完成之后就可以访问https://minminminzhang.github.io,出现Hexo安装成功的页面提示。注意：我在最后一部配置的时候出现了仓库不存在的提示：出现这种错误，有两种原因： 1.修改站点文件时：仓库名输入有误 2.在部署之前没有执行$ npm install hexo -deployer-git -save还有一种错误的情况由G:/blogresoft/git/hexo下的.deploy_git隐藏文件所致,删除这个隐藏文件即可。完成之后进行重新部署： 12345$ hexo clean$ hexo g$ hexo d 重新访问进行验证。 不断优化更换主题 Hexo中G:/blogresoft/git/hexo/themes/landscape默认的主题很简陋，我们可以换成更美观的。本博客选择Next主题，简单美观，好配置。 下载主题： 在Next发布页面(https://github.com/iissnan/hexo-theme-next/releases) 下载最新版本hexo-theme-next-5.1.4。放在G:/blogresoft/git/hexo/themes文件夹下并改名为next。启用主题打开站点配置文件，在theme字段更改如下代码： 1theme： next 主题安装完成，在切换之前，用hexo clean来清除hexo的缓存。 验证主题： 启动Hexo本地站点，并开启调试模式： 1$ hexo s -debug 出现提示：INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop 此时使用浏览器访问http://localhost:4000，检查Next安装是否成功。Next安装成功之后的页面设置参考： https://blog.csdn.net/u012195214/article/details/79204088 写博客：定位到hexo根目录，执行命令： 1$ hexo new &apos;my first-blog&apos; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hexo会帮我们在 G:/blogresoft/git/hexo/source/_posts 下生成相关文件，我们只需要打开这个文件就可以开始写博客了。 当然也可以在G:/blogresoft/git/hexo/source/_posts 直接创建后缀为.md的文件。使用命令的好处是帮我们自动生成了时间。 &nbsp;&nbsp;&nbsp;&nbsp;打开文件，除了在文章开头部分的一些参数，比如标题(title:) 、创建时间(date:) 等，正文部分使用Markdown格式书写: 注意：NexT默认主页显示文章的全部内容，这对于有些很长的文章来说非常不美观，建议主页仅显示文章的摘要。 在合适的位置插入以下内容作为分隔符 1$ &lt;!--is more--&gt; 分隔符以前的内容将会在索引页上显示为摘要。 补充内容： Hexo常用命令： npm install hexo -g #安装npm update hexo -g #更新hexo init #初始化hexo publish [layout] #发表草稿。hexo n “name” #新建文章hexo g #生成静态网页hexo p #发表草稿。 hexo s #启动服务hexo d #部署网站 参数：-g 部署之前先生成静态文件。]]></content>
      <categories>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>搭建个人博客  相关技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2Fcjp6mvinu0008mgnubhoral6s%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
