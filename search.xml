<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux系统命令(3)]]></title>
    <url>%2F2019%2Fcjr7r6l9e000gfknuih26kuou%2F</url>
    <content type="text"><![CDATA[Linux系统是多用户的，因此可能有多人同时使用这台主机来进行工作，为了考虑每个人的隐私权以及每个人喜好的工作环境，因此，“文件所有者”的角色就显得重要了。 1.Linux文件属性12345[root@www ~] # ls -aldrwx------ 3 root root 4096 Sep 5 10:37 .gconf-rw-r--r-- 1 root root 42304 Sep 4 18:26 install.log[ 1 ] [2] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ][ 权限 ] [连接][ 所有者 ][ 用户组 ][ 文件容量 ][ 修改日期 ][ 文件名 ] (1)第一列代表这个文件的类型与权限一共有10个字符，第一个字符代表这个文件是“目录，文件或链接文件等”。[d] 代表目录，[-]代表文件。接下来的字符串中，以3个为一组，且均为“rwx”的3个参数的组合，其中[r]代表可读，[w]代表可写，[x]代表可执行。要注意的是，这3个权限的位置不会改变，如果没有权限，就会出现减号[-]。 第一组为“文件所有者的权限”。 第二组为“同用户组的权限”。 第三组为“其他非本地用户的权限”。 1234567例：- [r w x ][r - x ][r - -] 1 2 3 4 5 6 7 8 9 01:代表为文件234:拥有者的权限，可读可写可执行567:同用户组的权限，可读可执行不可写890:其他非本地用户的权限，不可读不可写不可执行 (2)第二列表示有多少文件名连接到此节点(3)第三列表示这个文件(或目录)的“所有着账号”(4)第四列表示这个文件所属的用户组(5)第五列为这个文件的容量大小，默认单位为B(6)第六列为这个文件的创建日期或者最近修改的日期。(7)第七列为改文件名。2.改变文件属性与权限chgrp:改变文件所属用户组 chown:改变文件所有者 chmod:改变文件的权限 (1)改变所属用户组：chgrp12345[root@www ~] # chgrp [-R] dirname/filename例：[root@www ~] # chgrp users install.log &gt;==install.log 所属用户组改为test[root@www ~] # chgrp testing install.log &gt;==找不到用户组testing，不能改变。 (2)chown:改变文件所有者12345例1：将install.log 的所有者改为bin[root@www ~] # chown bin install.log 例2：将install.log 的所有者与用户组改为root[root@www ~] # chown root:root install.log (3)chmod:改变文件的权限权限的设置方法有两种，数字或者符号。 ①数字类型改变文件权限各权限的分数对照: r:4, w:2,x:1 每种身份(owner,group,others)各自的权限是需要累加的。 12345678例如当权限为[-rwxrwx---]owner=4+2+1=7group=4+2+1=7others=0+0+0=0因此设置权限更改时，该文件的权限数字就是770。例：将文件.bashrc的所有权限启用[root@www ~] # chmod 777 .bashrc ②符号类型改变文件权限u,g,o分别代表三种身份(owner,group,others)，a代表all，也即全部的身份。读写权限可以写成r,w,x 12345678910例1：[root@www ~] # chmod u=rwx,go=rx .bashrc[root@www ~] # ls -al .bashrc-rwxr-xr-x 1 root root 395 Jul 4 11 :45 .bashrc例2：不知道原先文件的属性，现在增加.bashrc这个文件每个人均可写入的权限[root@www ~] # chmod a+w .bashrc例3：去掉全部人可执行的属性[root@www ~] # chmod a-x .bashrc 3.目录与文件的权限意义(1)权限对文件的重要性文件是实际含有数据的地方，包括一般文件、数据库内容文件、二进制可执行文件等。因此权限对于文件来说，它的意义如下： r(read)：可读取文件的实际内容，如读取文本文件的文字内容等。 w(write)：可以编辑、修改、新增文件的内容（但不包括删除该文件）。 x(execute)：该文件具有可以被执行的权限。在Windows下面，一个文件是否具有被执行的能力是通过“扩展名”来判断的，例如.exe,.bat,.com等，但在linxu里面文件能否执行则是由是否具有“x”这个权限来决定的，和文件名没有绝对的关系。 对于文件的r,w,x来说，主要是针对“文件的内容”而言，与文件名的存在与否没有关系的。 (2)权限对目录的重要性目录主要的内容是记录文件名列表，文件名与目录有强烈的关联。 r(read contents in directory)：表示具有读取目录结构列表的权限，可以查询该目录下的文件名数据，可以利用ls这个命令将该目录的内容列表显示出来。 w(modify contents of directory)：具有更改目录结构列表的权限，具体如下： ​①新建新的文件与目录 ②删除已经存在的文件与目录（不论该文件的权限如何） ③将已经存在的文档或者目录重命名 ④转移该目录内的文件，目录位置。 总之，目录的w权限就与该目录下的文件名变动有关。 x(access directory)：目录不可以被执行，目录的x代表的是用户能否进入该目录成为工作目录的用途，所谓的工作目录就是目前所在的目录。]]></content>
      <categories>
        <category>linux系统应用命令 </category>
      </categories>
      <tags>
        <tag>应用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统进一步了解]]></title>
    <url>%2F2019%2Fcjr7r6ljp001ufknute2o7sei%2F</url>
    <content type="text"><![CDATA[在学习了linux的基础和简单命令后，开始学习linux系统的目录与路径相关知识。我们之前学过切换目录的命令cd，以此进入文件路径。文件路径分为绝对路径和相对路径。 绝对路径：路径的写法一定是由根目录/泄气，例如/usr/share/doc这个目录。 相对路径：路径的写法不是由/写起，例如路径/usr/share/doc到路径/usr/share/man下面时，可以写成”cd../man”。相对路径指的是相对目前的工作目录。 1.常见的处理目录命令1234cd:切换目录pwd:显示当前目录mkdir:新建一个新的目录rmdir:删除一个空的目录 (1)cd(Change Directory,切换目录)在CentOS中创建的minner账号的主文件夹是/home/minner/,而root的主文件夹则是/root/ 12345678910111213141516[root@www ~] # cd# 进入相对路径或绝对路径[root@www ~] # cd ~minner# 去到minner用户的主文件夹，即/home/minner[root@www minner] # cd ~# 表示回到自己的文件夹，即/root这个目录[root@www ~] # cd# 没有加上任何路径，也代表回到自己主文件夹的意思[root@www ~] # cd ..# 表示去到上层目录，即/root的上层目录[root@www /] # cd -# 表示回到刚才的目录，即/root[root@www ~] # cd /var/spool/mail# 去到指定的绝对路径[root@www mail] # cd ../mqueue# 相对路径，从路径/var/spool/mail到路径/var/spool/mqueue 注意:cd命令和目录名称之间存在一个空格。 (2)pwd（Print Working Directory,显示目前所在的目录）123456789101112[root@www ~] # pwd [-p]参数：-p：显示当前路径例如：只显示当前的工作目录[root@www ~] # pwd/root &lt;==显示出目录例：显示出实际的工作目录[root@www ~] # cd /var/mail[root@www ~] # pwd/var/mail &lt;==列出目前的工作目录 (3)mkdir(make directory,新建新目录)12345[root@www ~] # cd /tmp[root@www ~] # mkdir test &lt;==创建名为test的新目录[root@www ~] # mkdir test1/test2/test3 &lt;==无法直接创建多级目录[root@www ~] # mkdir -p test1/test2/test3 &lt;==利用-p，可以直接创建多级目录[root@www ~] # mkdir -m 711 test2 &lt;==利用-m，可以强制设置属性。如果没有m，则为默认属性 (4)rmdir(删除空目录)123[root@www ~] # test &lt;==可以直接删掉[root@www ~] # test1 &lt;==不能直接删掉，因为里面有内容[root@www ~] # -p test1/test2/test3 &lt;==加上参数-p，可以一次性删除 2.关于执行路径的变量：$PATH123[root@www ~] # echo $PATH &lt;==以root身份列出查询的路径[root@www ~] # su - minner[minner@www ~] # echo $PATH &lt;==以minner身份列出查询的路径 3.查看文件与目录12345678910111213141516[root@www ~] # ls [-aAdfFhilnrRSt] 目录名称[root@www ~] # ls [--color=&#123;never,auto,always&#125;] 目录名称[root@www ~] # ls [--full-time] 名称目录参数：-a：全部的文件，连用隐藏文件一同列出来-d：仅列出目录本身，而不是目录内的文件数据-l：列出长数据串，包含文件的属性与权限等数据--color=never ：不要依据文件特性给予颜色显示--color=always ：显示颜色--color=auto ：让系统自行依据设置来判断是否给予颜色--full-time ：以完整时间（包括年月日时分）模式输出--time=&#123;atime,ctime&#125; ：输出访问时间或改变权限属性时间而非内容更改时间[root@www ~] # ls -al ~ &lt;==目录文件都是以深蓝色显示[root@www ~] # ls -alF --color=never ~ &lt;==不显示颜色，但在文件夹名未显示出该文件夹代表的类型[root@www ~] # ls -al --full-time ~ &lt;==完整呈现文件的修改时间 4.复制、删除与移动：cp,rm,mv(1) cp (复制文件或目录)1234567891011121314151617[root@www ~] # cp [-adfilprsu] 源文件(source) 目标文件(destination) 例1：[root@www ~] # cp ~/.bashrc /tmp/bashrc[root@www ~] # cp -i ~/.bashrc /tmp/bashrccp: overwrite &apos;/tmp/bashrc&apos;?n &lt;==n 不覆盖，y为覆盖# 重复做两次操作，由于/tmp下面已经存在bashc了，加上-i参数后# 则在覆盖前会询问用户是否确定，可以按下n或者y来二次确认例2：切换目录到/tmp，并将/var/log/wtmp 复制到/tmp且查看属性:[root@www ~] # cd /tmp[root@www ~] # cp /var/log/wtmp . &lt;==想要复制到当前目录，最后的“.”不要忘记[root@www ~] # ls -l /var/log/wtmp wtmp例3：复制 /etc/ 这个目录下的所有内容复制到 /tmp下面[root@www ~] # cp /etc/ /tmp[root@www ~] # cp -r /etc/ /tmp &lt;==如果是目录不能直接复制，要加上-r参数 (2) rm(移除文件)1234567891011121314151617[root@www ~] # rm [-fir]文件或目录例1：将刚才在cp的范例中创建的bashrc删除掉[root@www ~] # cd /tmp[root@www tmp] # rm -i bashrc &lt;==如果加上-i的参数就会主动询问，避免删除错误的文件名例2：通过*，将/tmp下面开头为bashrc的文件名全部删除[root@www tmp] # rm -i bashrc* &lt;==*代表0到无穷多个任意字符例3：将cp范例中所创建的/tmp/etc/这个目录删除掉[root@www tmp] # rmdir /tmp/etc &lt;==删不掉，因为不是空目录[root@www tmp] # rm -r /tmp/etc &lt;==加r删除例4：删除一个带有 - 开头的文件[root@www tmp] # touch ./-aaa- &lt;==touch这个命令可以创建空文件[root@www tmp] # rm -aaa- &lt;==系统会误判[root@www tmp] # rm ./-aaa- (3)mv(移动文件与目录，或更名)1234567891011121314151617[root@www ~] mv source destination例1：复制一个文件，创建一个目录，将文件移动到目录[root@www ~] # cd /tmp[root@www tmp] # cp ~/.bashrc bashrc [root@www tmp] # mkdir mvtest[root@www tmp] # mv bashrc mvtest#将文件移动到某个目录去例2：将刚才的目录名称重命名为mvtest2[root@www tmp] # mv mvtest mvtset2例3：再创建两个文件，再全部移动到/tmp/mvtest2当中[root@www tmp] # cp ~/.bashrc bashrc1[root@www tmp] # cp ~/.bashrc bashrc2[root@www tmp] # mv bashrc1 bashrc2 mvtest2# 注意，如果有多个源文件或目录，则最后一个一定是“目录”，将所有的数据移动到该目录 5.取得路径的文件名与目录名称1234[root@www ~] # basename /etc/sysconfig/networknetwork &lt;==取得最后的文件名[root@www ~] # dirname /etc/sysconfig/network/etc/sysconfig &lt;==取得目录名 6.文件内容查询12345678cat: 由第一行开始显示文件内容tac: 从最后一行开始显示，可以看出tac是cat的倒写形式。nl: 显示的时候，顺便输出行号more: 一页一页地显示文件内容less: 与more类似，但是比more更好的是， 它可以往前翻页。head: 只看头几行tail: 只看结尾几行od: 以二进制的方式读取文件内容 (1)cat(concatenate)123456789[root@www ~] # cat [-AbEnTv]参数：-b： 列出行号，仅针对非空白部分-n： 打印出行号，连同空白处也会有行号例1:查看/etc/issue这个文件的内容[root@www ~] # cat /etc/issue[root@www ~] # cat -n /etc/issue &lt;==加上行号[root@www ~] # cat -A /etc/issue &lt;==将/etc/issue的内容完整的显示出来 (2) tac(反向列示)1[root@www ~] # tac /etc/issue (3)nl(添加行号打印)123456[root@www ~] # nl [-bnw] 文件例1：[root@www ~] # nl /etc/issue &lt;==空白处不显示行号[root@www ~] # nl --b /etc/issue &lt;==空白处显示行号 (4)可翻页查看more(一页一页翻动) 1[root@www ~] # more /etc/man.config more后面接的文件内容行数大于屏幕输出的行数时，可以一页一页的查看。 12345空格键(Space)：代表向下翻一页enter ： 代表向下滚动一行/字符串 ： 代表在这个显示的内容当中，相信爱查询“字符串”这个关键字:f ： 立刻显示出文件名以及目前显示的行数q ：代表离开more，不再显示该文件内容 less(一页一页翻动) 1[root@www ~] # more /etc/man.config less比more更有弹性。在使用more的时候，并没有办法向前面翻，只能往后面看。但使用less的时候，可以向前和向后看。 7.数据选取head和tail都是以“行”为单位来选取数据的。 (1)head(取出前面几行)12345678910[root@www ~] # head [-n number] 文件参数：-n：后面接数字，代表显示几行的意思[root@www ~] # head /etc/man.config# 默认的情况中，显示前10行，若要显示前20行，就要如下执行命令：[root@www ~] # head -n 20 /etc/man.config例：如果后面100行数据都不打印，只打印 /etc/man.config的前面几行[root@www ~] # head -n -100 /etc/man.config (2)tail (取出后面几行)123456789[root@www ~] # tail /etc/man.config# 默认的情况中，显示前10行，若要显示后20行，就要如下执行命令：[root@www ~] # tail -n 20 /etc/man.config例1：列出100行以后的数据[root@www ~] # tail -n +100 /etc/man.config例2：取出/etc/man.config的第11-20行[root@www ~] # head -n 20 /etc/man.config | tail -n 10 补充：从自己创建的文件夹到root的主文件夹还可以用命令su]]></content>
      <categories>
        <category>linux系统应用命令 </category>
      </categories>
      <tags>
        <tag>应用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口本地测试正确 线上测试发生错误]]></title>
    <url>%2F2019%2Fcjr7r6l8r0002fknuwgc2dalp%2F</url>
    <content type="text"><![CDATA[完成代码之后，在本地接口测试正确，但是发布到线上之后总是测试有问题。经过再三查找，总结如下： 1.代码书写不严谨例如我在写邮件功能模块时的，根据id查询邮件记录的Controller层。 代码如下： 1234567891011@RequestMapping (value = &quot;/getEmailRecordById&quot;,method = RequestMethod.POST)public Object getEmailRecordById( @RequestParam(value=&quot;id&quot;,required =false) Integer id)&#123; String mailModel= String.valueOf(mailService.getEmailRecordById(id)); if(mailModel!=null)&#123; return new AJAXResult(MsgCode.success); &#125;else&#123; return new AJAXResult(MsgCode.notexsit); &#125; &#125; 测试的时候发现，无论id为何值，每次返回的结果都是success。于是，在第五行之后加上打印 1System.out.println(&quot;mailModel=&quot;+mailModel) 输入id为数据库中不存在id时，发现mailModel并不等于null，而是等于”[ ]”，是一个空的数组。 因此要将判断条件改为： 12345if(mailModel!=&quot;[]&quot;)&#123; return new AJAXResult(MsgCode.success); &#125;else&#123; return new AJAXResult(MsgCode.notexsit); &#125; 这样测试之后便得到正确结果。 2.忽略临界条件在写员工模块部分，根据员工名查找员工密码时： 12345678910@RequestMapping(value=&quot;/getPasswordByName&quot;,method = RequestMethod.POST) public Object getPasswordByName( @RequestParam(value=&quot;name&quot;,required = false) String name )&#123; String employModel=employeeService.getPasswordByName(name); if(employModel!=null)&#123; return new AJAXResult(MsgCode.success); &#125;else return new AJAXResult(MsgCode.notexsit); &#125; 当输入不存在的name时结果返回notexsit，输入正确的name时返回success。但是，忽略了未输入参数的情况。因此，可以将name的required改为true，这样name参数就是必须要传入的了。或者在判断条件else处再加上判断name是否为空。 3.代码测试和数据库不一致我在移植数据库的时候，出现了错误，导致数据库的好多存储值为null，因此导致了测试结果总是返回不存在。晚上线上数据库之后，发现测试正确了。因此在测试代码接口的时候，一定确保线上环境和数据库的一致性。]]></content>
      <categories>
        <category>线上 测试</category>
      </categories>
      <tags>
        <tag>接口发布测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语句优化]]></title>
    <url>%2F2019%2Fcjr7r6lpu0026fknuh041viy0%2F</url>
    <content type="text"><![CDATA[当写代码初期的时候，SQL语句基本都关注正确性就可以了。但是随着将代码不断的应用，在这个过程中，SQL语句的优化就变的很重要，因为它关乎到程序执行的效率。因此，我们在Mapper中写sql语句时，要使用优质的SQL语句。以下是我在实践中学到的一些sql语句优化改进。 1.SQL语句中的in包含的值不应该过多 MySQL将in中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，运行的时候产生的消耗会很大。例如： 1select id from t where num in(1,2,3) 对于这种连续的数值，尽量用between，不要用in。 2、区分in和exists、not in和not exists 1select * from 表A where id in (select id from 表B) 上面SQL语句相当于 1select * from 表A where exists(select * from 表B where 表B.id=表A.id) 区分in和exists主要是造成了驱动顺序的改变，如果是exists，那么以外层表为驱动表，先被访问，如果是in，那么先执行子查询。所以in适合于外表大而内表小的情况；exists适合于外表小而内表大的情况。关于not in和not exists，尽量使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。 例如： 1select colname … from A表 where a.id not in (select b.id from B表) 修改为： 1select colname … from A表 Left join B表 on where a.id = b.id where b.id is null 3.is null或is not null操作（判断字符段是否为空） 索引不索引空值，因此判断字符段是否为空不会应用索引。任何包含null值的列都将不会被包含在索引中。当一个索引有多列时，但是只要这些列中有一列含有null，该列就会从索引中排除，即使对该列建索引也不会提高性能。 因此可以采用其它相同功能的操作运算代替，如：a is not null 改为 a&gt;0 等其他对等的条件。 4、尽量用union all代替union union和union all的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。当然，union all的前提条件是两个结果集没有重复数据 5、尽量不要使用%前缀模糊查询 例如LIKE“%name”或者LIKE“%name%”，这种查询会导致索引失效而进行全表扫描。但是可以使用LIKE “name%”。 6、避免在where子句中对字段进行表达式操作 比如： 1select user_id,user_project from user_base where age*2=36; 可以改成： 1select user_id,user_project from user_base where age=36/2; 7.避免隐式类型转换 where子句中出现column字段的类型和传入的参数类型不一致的时候发生的类型转换，应该尽量确保一致。 8.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： 1select id from t where num=10 or num=20 可以这样查询： 1select id from t where num=10 union all select id from t where num=20]]></content>
      <categories>
        <category>SQL语句优化 </category>
      </categories>
      <tags>
        <tag>SQL语句优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统初步了解]]></title>
    <url>%2F2019%2Fcjr7r6l9a000cfknugt3a3946%2F</url>
    <content type="text"><![CDATA[最近学习了有关于linux操作系统的基础以及相关指令，接下来做一介绍。linux系统是“多任务，多用户”，即主机上可以同时允许多人上线来工作，并且资源的分配较为公平。这也将存在一个问题：关机问题。在Windows系统中，由于是单用户，所以即使计算机关机，对于别人也不会有影响。但在Linux系统中，由于每个程序都是在后台执行的，因此，在你看不到的屏幕背后其实可能有很多人同时在你的主机上面工作，例如浏览网页，传送信件等，如果直接按下电源开关来关机，则其他人的数据可能就此终端了。 1.Linux登陆纯文本界面 Linux默认的情况下会提供6个Terminal来让用户登录，切换的方式为使用【Ctrl】+【Alt】+【F1】~【F6】的组合按钮。 系统将【F1】~【F6】命名为tty1~tty6的操作界面环境。按下【Ctrl】+【Alt】+【F7】转换到图形界面桌面。 按下【Ctrl】+【Alt】+【F1】来到tty1的登陆界面。 123456CentOS release 5.3 (Final)Kernel 2.6.18-128.el5 on an i686www login: vbirdPassword:[minner@www~] $_ (1).CentOS release 5.3 (Final) 显示Linux distribution的名称与版本 (2).Kernel 2.6.18-128.el5 on an i686 显示内核版本 (3).www login 主机名 (4).Password 密码，输入后不会显示 (5).[minner@www~] $_ 登陆后，显示的正确信息。最左边的vbird显示的是当前用户的账号，而@之后接的www则是主机名。最右边的~则指的是“当前所在的目录”，那个$是提示符。 这样就已登陆主机了。 2.基本命令操作 (1)显示日期与时间：date 12[minner@www~] $ dateSun Jan 13 17:34:52 CST 2019 上面显示为：星期天，1月13日，时间为17:34:52，在2019年的CTS时区 1234[minner@www~] $ date +%Y/%m/%d2019/1/13[minner@www~] $ date +%H:%M17:34 (2)显示日历的命令：cal 12345678[minner@www~] $ calJanuary 2019Su Mo Tu We Th Fr Sa 1 2 3 4 56 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 [vbird@www~] $ cal [[month] year]12[minner@www~] $ cal 2019查询2019年所有日历 基本的cal语法为： 1[minner@www~] $ cal [[month] year] (3)计算器：bc 12345678[minner@www~] $ bc1+4+3 810%3 110/100 0quit quit:离开计算器 在上文中10/100结果为0，因为bc默认输出整数，如果要输出全部小数，就要执行scale=number,number代表小数点后的位数，例如： 1234567[minner@www~] $ bcscale=3 1/3.33334/1000.340quit (2)改变支持语言 ①显示目前所支持的语言 12[minner@www~] $ echo $LANG zh_CN.UTF-8 上面的意思是目前的语言(LANG)为zh_CN.UTF-8 ②修改语言为英文 123[minner@www~] $ LANG=en__US[minner@www~] $ echo $LANG en__US 再次确认，支持语言由汉语改成英语 3.正确关机 若不正常关机，则可能造成文件系统的毁损。 在正常情况下，关机要注意下面几件事： (1)查看系统的使用状态 如果要谁在线，执行命令”who”。查看网络的联机状态，执行命令”netstat -a”。查看后台执行的程序，用命令“ps-aux”。 (2)通知在线用户关机的时刻 用shutdown这个命令来实现 Linux，除了以tty7图形界面来登陆系统，无论以什么身份都能够关机外，只有root有权限。 1234567891011[root@www ~] # /sbin/shutdown [-t秒] 时间 [警告消息]参数：-t sec:-t后面加秒数，表示几秒后关机-k :不是真的关机，只是发送警告消息出去-r :在将系统的服务停掉之后就重启-h :将系统的服务停掉之后，立即关机-n :不经过init程序，直接以shutdown来关机-f :关机并开机之后，强制略过fsck的磁盘检查-F :系统重启之后，强制进行fsck的磁盘检查-c :取消已经在进行的shutdown命令内容时间 ：一定要加入的参数，指定系统关机的时间。 例如： 1234567891011121314151617[root@www ~] # shutdown -h now立刻关机[root@www ~] # shutdown -h 20：25系统在今天的20：25关机。如果在超过20：25执行此命令，则隔天的20：25关机。[root@www ~] # shutdown -h +10十分钟后关机[root@www ~] # shutdown -r now系统立刻重启[root@www ~] # shutdown -r +30 &apos;The system will reboot&apos;再过三十分钟系统重启，将后面消息显示给所有用户[root@www ~] # shutdown -k now &apos;The system will reboot&apos;仅发出警告信件的参数，系统并不会关机 4.补充 (1)[Tab]键具有命令补全和文件补齐功能 123456[minner@www~] $ ca [Tab][Tab]执行这个命令以后，所有以ca开头的命令都被显示出来。[minner@www~] $ ls -al ~/.bash[Tab][Tab]所有以.bash开头的文件名都会被显示出来[Tab]接在一串命令的第一个命令之后，则为“命令补全”[Tab]接在一串命令的第二个命令之后，则为“文件补齐” (2)[Ctrl]-c可以停止运行，让程序停下来。 (3)[Ctrl]-d代表键盘输入结束。 (4)man page 12[minner@www~] $ man date执行这个命令查询到关于date命令的使用方法 (5) man -f man 1234[minner@www~] $ man -f man执行这个命令后，输出的数据包括两部分。左部分是命令以及该命令代表的意义。右半部份是这个命令的简易说明。[minner@www~] $ man -f 执行这个命令后，只会找到命令以及该命令代表的意义 (6) man -k man 12[minner@www~] $ man -k man只要有man的关键字都会列出来 我们知道Linux中有很多的命令，但不用挨个去背。 一般遇到记不清楚的命令，可以这样查找： 首先：man+模糊命令，找相关的说明。然后：模糊命令+两次[Tab]键，查找以模糊命令开头的命令，查找到以后再去man查询命令。]]></content>
      <categories>
        <category>linux系统应用命令 </category>
      </categories>
      <tags>
        <tag>应用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小顽童OA项目之邮件功能模块]]></title>
    <url>%2F2019%2Fcjr7r6ljg001ofknu2bmnwbg5%2F</url>
    <content type="text"><![CDATA[我开发的第一部分是实现发送邮件的业务：实现简单邮件的发送，以及带图片，带附件的邮件发送。将每次发送邮件的记录进行保存，并且可以通过id，或者其他字段进行查询，修改，删除。 首先，第一步是实现邮件发送业务并保存记录： 在pom.xml中写入： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 在application.properties进行配置： 12345678spring.mail.host=smtp.163.comspring.mail.username=minzhang1534781927@163.comspring.mail.password=468975520zmspring.mail.default-encoding=UTF-8spring.mail.port=25spring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=true 在Mapper层： 12345678910111213package org.ppcirgo.oa.mapper;import org.apache.ibatis.annotations.*;import org.ppcirgo.oa.beans.model.MailModel;import org.springframework.stereotype.Repository;@Repositorypublic interface MailMapper &#123; //保存发邮件记录 @Insert(value=&quot;insert into emailRecord (sender,receiver,time,subject,status,content,password) values(#&#123;sender&#125;,#&#123;receiver&#125;,#&#123;time&#125;,#&#123;subject&#125;,#&#123;status&#125;,#&#123;content&#125;,#&#123;password&#125;)&quot;) int saveEmailRecord(MailModel mailModel); &#125; 在Service层 123456789101112131415161718package org.ppcirgo.oa.service;import org.ppcirgo.oa.beans.model.MailModel;public interface MailService &#123; //发送简单邮件 public MailModel sendSimpleMail(String from, String to, String subject, String content); //发送带图片的邮件 public MailModel sendInilneMail(String from,String to, String subject, String content,String resPath,String resId); //发送带附件的邮件 public MailModel sendAttachmentMail(String from,String to,String subject,String content,String filePath); //保存发邮件记录 int saveEmailRecord(MailModel mailModel); &#125; 在ServiceImpl层： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package org.ppcirgo.oa.service.impl;import org.ppcirgo.oa.beans.model.MailModel;import org.ppcirgo.oa.mapper.MailMapper;import org.ppcirgo.oa.service.MailService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.core.io.FileSystemResource;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import javax.mail.MessagingException;import javax.mail.internet.MimeMessage;import java.io.File;import java.util.List;@Transactional@Servicepublic class MailServiceImpl implements MailService &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private JavaMailSender mailSender; @Autowired private MailMapper mailMapper; MailModel emailModel=new MailModel(); /* * 发送简单邮件 * @Param sender 邮件发送者 * @Param receiver 邮件接收者 * @Param content 邮件内容 */ public MailModel sendSimpleMail(String sender, String receiver, String subject, String content) &#123; SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(sender); message.setTo(receiver); message.setSubject(subject); message.setText(content); try &#123; mailSender.send(message); logger.info(&quot;简单邮件已经发送&quot;); &#125;catch (Exception e)&#123; logger.error(&quot;发送邮件发生异常&quot;,e); &#125; return emailModel; &#125; /* * 发送嵌入静态资源（一般是图片）的邮件 * @Param sender 邮件发送者 * @Param receiver 邮件接收者 * @Param content 邮件内容，需要包括一个静态资源id，比如：&lt;img src=\&quot;cid:resId01\&quot;&gt; * @Param resPath 静态资源路径和文件名 * @Param resId 静态资源id */ public MailModel sendInilneMail(String sender,String receiver, String subject, String content,String resPath,String resId)&#123; MimeMessage message= mailSender.createMimeMessage(); try &#123; //true表示需要创建一个multipart message MimeMessageHelper helper=new MimeMessageHelper(message,true); helper.setFrom(sender); helper.setTo(receiver); helper.setSubject(subject); helper.setText(content,true); FileSystemResource res=new FileSystemResource(new File(resPath)); helper.addInline(resId,res); mailSender.send(message); logger.info(&quot;嵌入静态资源的邮件已经发送&quot;); &#125; catch (MessagingException e) &#123; logger.error(&quot;发送嵌入静态资源的邮件已经发生异常&quot;,e); &#125; return emailModel; &#125; /* * 发送带附件的邮件 * @Param sender 邮件发送者 * @Param receiver 邮件接收者 * @Param content 邮件内容 * @Param filePath 附件路径 */ public MailModel sendAttachmentMail(String sender,String receiver,String subject,String content,String filePath)&#123; MimeMessage message=mailSender.createMimeMessage(); try &#123; //true表示需要创建一个multipart message MimeMessageHelper helper=new MimeMessageHelper(message,true); helper.setFrom(sender); helper.setTo(receiver); helper.setSubject(subject); helper.setText(content,true); FileSystemResource file=new FileSystemResource(new File(filePath)); String fileName=filePath.substring(filePath.lastIndexOf(File.separator)); helper.addAttachment(fileName,file); mailSender.send(message); logger.info(&quot;带附件的邮件已经发送&quot;); &#125; catch (MessagingException e) &#123; logger.error(&quot;发送带附件的邮件时发生异常&quot;,e); &#125; return emailModel; &#125; @Override public int saveEmailRecord(MailModel mailModel) &#123; return mailMapper.saveEmailRecord(mailModel); &#125; &#125; 在Controller层 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package org.ppcirgo.oa.controller;import org.ppcirgo.oa.AJAXResult;import org.ppcirgo.oa.beans.model.MailModel;import org.ppcirgo.oa.service.MailService;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.web.bind.annotation.*;@RestControllerpublic class MailController &#123; @Autowired private MailService mailService; private String defaultStatus=&quot;1&quot;;//默认的发邮件状态 // 简单邮件发送,并保存记录 @RequestMapping(value=&quot;/sendSimpleEmail&quot;,method = RequestMethod.GET) public Object sendSimpleMail( @RequestParam(value=&quot;sender&quot;,required = false) String sender, @RequestParam(value=&quot;receiver&quot;,required = false )String receiver, @RequestParam(value=&quot;subject&quot;,required = false) String subject, @RequestParam(value=&quot;content&quot;,required = false) String content ) &#123; MailModel mailModel=mailService.sendSimpleMail(sender,receiver,subject,content); mailModel.setTime(DateUtlis.currentTime((System.currentTimeMillis()))); mailModel.setStatus(defaultStatus); if(mailService.saveEmailRecord(mailModel)&gt;0) return new AJAXResult(MsgCode.success); else return new AJAXResult(MsgCode.error); &#125; // 带有附件的邮件 @RequestMapping(value=&quot;/sendInlineMail&quot;,method =RequestMethod.GET) public Object sendInilneMail( @RequestParam(value=&quot;sender&quot;,required = false) String sender, @RequestParam(value=&quot;receiver&quot;,required = false )String receiver, @RequestParam(value=&quot;subject&quot;,required = false) String subject, @RequestParam(value=&quot;content&quot;,required = false) String content, @RequestParam(value=&quot;resPath&quot;,required = false) String resPath, @RequestParam(value=&quot;resId&quot;,required = false) String resId ) &#123; MailModel mailModel=mailService.sendInilneMail(sender, receiver, subject, content,resPath,resId); mailModel.setTime(DateUtlis.currentTime((System.currentTimeMillis()))); mailModel.setStatus(defaultStatus); if(mailService.saveEmailRecord(mailModel)&gt;0) return new AJAXResult(MsgCode.success); else return new AJAXResult(MsgCode.error); &#125;// 带有附件的邮件 @RequestMapping(value=&quot;/sendAttachmentMail&quot;,method =RequestMethod.GET) public Object sendAttachmentMail( @RequestParam(value=&quot;sender&quot;,required = false) String sender, @RequestParam(value=&quot;receiver&quot;,required = false )String receiver, @RequestParam(value=&quot;subject&quot;,required = false) String subject, @RequestParam(value=&quot;content&quot;,required = false) String content, @RequestParam(value=&quot;filePath&quot;,required = false) String filePath ) &#123; MailModel mailModel=mailService.sendAttachmentMail(sender, receiver, subject, content,filePath); mailModel.setTime(DateUtlis.currentTime((System.currentTimeMillis()))); mailModel.setStatus(defaultStatus); if(mailService.saveEmailRecord(mailModel)&gt;0) return new AJAXResult(MsgCode.success); else return new AJAXResult(MsgCode.error); &#125; &#125; 在model中： 12345678910111213141516package org.ppcirgo.oa.beans.model;import lombok.Data;import lombok.ToString;@Data@ToStringpublic class MailModel &#123; private Integer id; private String sender; //邮件发送者 private String receiver; //邮件接收者 private String time; //邮件发送时间 private String subject; //邮件主题 private String status; //邮件发送状态 1：发送成功 0：发送失败 private String content; //邮件内容 private String password; //找回密码时，系统产生的随机密码&#125; 实现了第一步，则通过id，或者其他字段进行查询，修改，删除邮件记录，将变得很简单。在Mapper层写Sql语句，Service层写接口，ServiceImpl层写实现Service层接口的类，最后在Controller进行Service的调用。 在Mapper层添加： 12345678910111213141516171819//根据发送者查找邮件内容@Select(value=&quot;select * from emailRecord where id=#&#123;id&#125;&quot;) List&lt;MailModel&gt; getEmailRecordById(@Param(&quot;id&quot;) Integer id);//根据标题查询邮件内容@Select(value=&quot;select * from emailRecord where subject like &apos;%$&#123;subject&#125;%&apos;&quot;) List&lt;MailModel&gt; getEmailRecordBySubject(@Param(&quot;subject&quot;) String subject);//根据发送者修改邮件主题@Update(value = &quot; update emailRecord set subject=#&#123;subject&#125; where id=#&#123;sender&#125; &quot;)int updateEmailRecordBySender(@Param(&quot;subject&quot;) String subject, @Param(&quot;sender&quot;) String sender);//根据发送者改变发送邮件的state@Update(value=&quot; update emailRecord set status=#&#123;status&#125; where sender=#&#123;sender&#125;&quot;)int updateStatusById(@Param(&quot;status&quot;) String status ,@Param(&quot;sender&quot;) String sender);//根据发送者删除邮件@Delete(value=&quot;delete from emailRecord where sender=#&#123;sender&#125;&quot;)int deleteEmailRecordBySender(@Param(&quot;sender&quot;) String sender); 其他层按照此格式书写代码。 这样就实现了一个OA项目完整的邮件功能。]]></content>
      <categories>
        <category>邮件功能开发</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小顽童OA项目介绍]]></title>
    <url>%2F2019%2Fcjr7r6l9m000mfknu5pz1rlw5%2F</url>
    <content type="text"><![CDATA[小顽童之OA项目介绍：基于一个员工在50-100的小型公司的背景，实现简洁办公自动化。具体要实现的功能有： 1.周计划（编辑/展示给某组或者部门） 2.月计划（编辑/展示给某组或者部门，计划书的完成进度跟踪，以及提醒及任务安排） 3.考勤管理（移动app考勤+人脸识别+定位+照片），考勤查询（矿工，请假，休假，正常，迟到）。 4.自动统计里程与绩效。 5.加盟管理（创建/编辑/删除某部门的方案，以及活动效果反馈） 6.导出相关表单为excel文件（如消费者的详细信息） 7.公司事物通知 8.公司邮件 9.移动办公支持 10.会展示一个页面给商家，进行反馈，以及提交需求和建议。同时可以展示公司近期的活动安排。 11.提供管理小顽童项目的接口（上架下架产品） 小顽童之OA项目使用了Springboot轻量级框架，这也是现在企业较为常用的框架。Springboot是Spring框架的集成，相比于Spring框架，Springboot框架除了拥有Spring框架的功能外，配置很简单。只要在pom.xml文件中添加相关依赖，maven可以自动下载。不用担心jar包版本之间的依赖冲突了。开发效率很高。 搭建Springboot框架所需要的前提 ①jdk8-jdk11 ②Maven3.3 ③Tomcat9.0]]></content>
      <categories>
        <category>相关技术</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道关于顺时针打印矩阵的常见算法题]]></title>
    <url>%2F2018%2Fcjr7r6l9i000ifknu0xxxx8jv%2F</url>
    <content type="text"><![CDATA[描述如下： 假设有一个4*4的矩阵，具体为： 12345671 2 3 4 5 6 7 8 9 10 11 1213 14 15 16 需要顺时针打印这个矩阵，上面输出的结果应该为：【1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10】。 考虑将函数的输入当作是一个二维数组（表示矩阵），返回值是矩阵的打印顺序集合。顺时针打印需要明确以下两点： （1）知道当前打印到哪一行和哪一列了 （2）不能出现越界和重复打印 对于第一点，定义两个变量row和col指向当前打印的行和列即可；第二点，顺时针打印其实是一圈一圈的打印，打印过程中的任何一次顺时针打印圈都可以用四个变量唯一确定。当前圈的第一行和最后一行，当前圈的最左一列和最右一列。越界问题其实就是要限定row和col变量的取值范围。 具体的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.ArrayList; /** *top：当前打印圈的第一行；left：当前打印圈的最左列；bottom：当前打印圈的最后一行；right：当前打印圈的最 *右边一列。top和bottom是用来限定row的取值范围；left和right是用来限定col的取值范围。 * @param matric */public class printMatric &#123; public printMatric(int[][] matric) &#123; if (matric == null) &#123; System.out.print(&quot;矩阵为空！&quot;); &#125; //获取矩阵的行和列 int row = matric.length; int col = matric.length; //保存待返回的结果集 ArrayList&lt;Integer&gt; res = new ArrayList(row * col); int top = 0, left = 0, bottom = row - 1, right = col - 1; while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123; //从左到右 for (int m = left; m &lt;= right; m++) &#123; res.add(matric[top][m]); &#125; //从上到下 for (int m = top + 1; m &lt;=bottom; m++) &#123; res.add(matric[m][right]); &#125; //从右到左 //只剩一行时，从左到右和从右到左打印的是同一行 if (top != bottom) &#123; for (int m = right - 1; m &gt;= left; m--) &#123; res.add(matric[bottom][m]); &#125; &#125; //从下到上 if (right != left) &#123; for (int m = bottom - 1; m &gt; top; m--) &#123; res.add(matric[m][left]); &#125; &#125; //为下一圈打印做准备 top++; left++; bottom--; right--; &#125; System.out.print(res); &#125; &#125; 测试： 123456public class Main &#123; public static void main(String args[]) &#123; int[][] matric = new int[][]&#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125;, &#123;13, 14, 15, 16&#125;&#125;; printMatric printMatric = new printMatric(matric); &#125;&#125; 测试之后得到的打印结果是：【1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10】。]]></content>
      <categories>
        <category>算法应用</category>
      </categories>
      <tags>
        <tag>算法应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用迭代算法解决汉诺塔问题]]></title>
    <url>%2F2018%2Fcjr7r6l97000bfknu38lah0yk%2F</url>
    <content type="text"><![CDATA[汉诺塔游戏可以简单描述为：n个盘子和3根柱子：A(起始柱子)、B(过渡柱子)、C(目的柱子)，盘子的大小不同且中间有一孔，可以将盘子“串”在柱子上，每个盘子只能放在比它大的盘子上面。起初，所有盘子在A柱上，问题是将盘子一个一个地从A柱子移动到C柱子。移动过程中，可以使用B柱，但盘子也只能放在比它大的盘子上面。 因此我们得出汉诺塔问题的以下几个限制条件： 1.在小圆盘上不能放大圆盘。 2.在三根柱子之间一回只能移动一个圆盘。 3.只能移动在最顶端的圆盘。 首先，我们从简单的例子开始分析，然后再总结出一般规律： 1.当n=1的时候，即此时只有一个盘子，那么直接将其移动至C即可。移动过程就是 A -&gt; C 2.当n=2的时候，这时候有两个盘子，那么在一开始移动的时候，我们需要借助B柱作为过渡的柱子，即将A柱最上面的那个小圆盘移至B柱，然后将A柱底下的圆盘移至C柱，最后将B柱的圆盘移至C柱即可。那么完整移动过程就是A -&gt; B , A -&gt; C , B -&gt; C 3.当n=3的时候，那么此时从上到下依次摆放着从小到大的三个圆盘，根据题目的限制条件：在小圆盘上不能放大圆盘，而且把圆盘从A柱移至C柱后，C柱圆盘的摆放情况和刚开始A柱的是一模一样的。所以呢，我们每次移至C柱的圆盘（移至C柱后不再移到其他柱子上去），必须是从大到小的，即一开始的时候，我们应该想办法把最大的圆盘移至C柱，然后再想办法将第二大的圆盘移至C柱……然后重复这样的过程，直到所有的圆盘都按照原来A柱摆放的样子移动到了C柱。 那么根据这样的思路，思考如何才能够将最大的盘子移至C柱？ 要将最大的盘子移至C柱，那么必然要先搬掉A柱上面的n-1个盘子，而C柱一开始的时候是作为目标柱的，所以我们可以用B柱作为”暂存”这n-1个盘子的过渡柱，当把这n-1的盘子移至B柱后，我们就可以把A柱最底下的盘子移至C柱了。 我们来看看现在各个柱子上盘子的情况，A柱上无盘子，而B柱从上到下依次摆放着从小到大的n-1个盘子，C柱上摆放着最大的那个盘子。 所以接下来那就是要把B柱这剩下的n-1个盘子移至C柱，那么我们需要借助A柱，将A柱作为新的”过渡”柱，B柱为初始柱，将这n-1个盘子移至目标C柱。 123456789101112131415public class HanoiTower&#123; topN：移动的盘子数 from：初始柱子 to：目的柱子 inter：过渡柱子 public static void doTower(int topN,char from,char inter ,char to)&#123; if(topN==1)&#123; System.out.println(&quot;盘子1，从”+from+“柱子到”+to+&quot;柱子&quot;); &#125;else&#123; doTower(topN-1,from,to ,inter); System.out.println(&quot;盘子&quot;+topN+&quot;，从&quot;+from+“柱子到”+to+&quot;柱子&quot;); doTower(topN-1,inter,from ,to); &#125; &#125;&#125; 测试： 12345public class TestHanoiTower&#123; public class void main(String [] args)&#123; HanoiTower.doTower(3,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;); &#125; &#125; ​ 程序结果为：盘子1，从A柱子到C柱子 盘子2，从A柱子到B柱子 盘子1，从C柱子到B柱子 盘子3，从A柱子到C柱子 盘子1，从B柱子到A柱子 盘子2，从B柱子到C柱子 盘子1，从A柱子到C柱子 即我们用迭代算法解决了汉诺塔问题。]]></content>
      <categories>
        <category>迭代算法</category>
      </categories>
      <tags>
        <tag>汉诺塔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用递归和迭代解决二叉树问题]]></title>
    <url>%2F2018%2Fcjr7r6l930007fknuyt4y0zjr%2F</url>
    <content type="text"><![CDATA[二叉树是数据结构最常见的一种应用。关于二叉树的很多问题都可以用递归和迭代来解决。 二叉树是一颗树，其中每个节点都不能有对于两个儿子。用代码可以简单的表示为： 1234567class TreeNode&#123; int val; //左孩子 TreeNode left; //右孩子 TreeNode left;&#125; 1.求二叉树的最大深度 12345678int maxDeath(TreeNode node)&#123; if(node==null)&#123; return 0;&#125; int left=maxDeath(node.left); int right=maxDeath(node.right); return Math.max(left,right)+1;&#125; 2.求二叉树的最小深度 123456789101112131415int getMinDepth()&#123; if(root==null)&#123; return 0; &#125; return getMin(root);&#125;int getMin(TreeNode root)&#123; if(root==null)&#123; return Integer.MAX_VALUE; &#125; if（root.left==null&amp;&amp;root.right==null）&#123; return 1; &#125; return Math.min(getMin(root.left),getMin(root.right))+1;&#125; 3.求二叉树中节点的个数 12345678int numOfTreeNode(TreeNode root)&#123; if(root==null)&#123; return 0; &#125; int left=numOfNode(root.left); int right=numOfNode(root.right); return left+right+1;&#125; 4.求二叉树中叶子节点的个数 123456789int numsOfNodeTreeNode(TreeNode root)&#123; if(root==null)&#123; return 0; &#125; if(root.left==null&amp;&amp;root.right==null)&#123; return 1; &#125; return numsOfNodeTreeNode(root.left)+numsOfNodeTreeNode(root.right);&#125; 5.求二叉树中第K层节点的个数 12345678910int numsOfLevelTreeNode(TreeNode node,int k)&#123; if(root==null||k&lt;1)&#123; return 0; &#125; if(k=1)&#123; return 1; &#125; int numLeft=numsOfLevelTreeNode(root.left,k-1); int numRight=numsOfLevelTreeNode(root.right,k-1);&#125; 平衡二叉树是其每个节点的左子数和右子树的高度最多差1的二叉查找树. 6.判断二叉树是否是平衡二叉树 1234567891011121314boolean isBalanced(TreeNode node)&#123; return maxDeath(node)!=-1;//空树的高度为1&#125; int maxDeath2(TreeNode node)&#123; if(node==null)&#123; return 0; &#125; int left=maxDeath(node.left); int right=maxDeath(node.right); if(left==-1||right==-1||Math.abs(left-right)&gt;1)&#123; return -1; &#125; return Math.max(left,right)+1; &#125; 7.判断两个二叉树是否完全相同 12345678910111213boolean isSameTreeNode(TreeNode t1,TreeNode t2)&#123; if(t1==null&amp;&amp;t2==null)&#123; return true; &#125;else if(t1==null||t2==null)&#123; return false; &#125; if(t1.val!=t2.val)&#123; return false; &#125; boolean left=isSameTreeNode(t1.left,t2.left); boolean right=isSameTreeNode(t1.right,t2.right); return left&amp;&amp;right;&#125; 8.两个二叉树是否为镜像 1234567891011boolean isMirror(TreeNode t1,TreeNode t2)&#123; if(t1==null&amp;&amp;t2==null)&#123; return true; &#125;else if(t1==null||t2==null)&#123; return false; &#125; if(t1.val!=t2.val)&#123; return false; &#125; return isMirror(t1.left,t2.right)&amp;&amp;isMirror(t1.right,t2.left);&#125; 9.二叉树的前序遍历 迭代解法 12345678910111213141516171819ArrayList&lt;Integer&gt; preOrder(TreeNode root)&#123; Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); if(root==null)&#123; return list; &#125; stack.push(root); while(!stack.empty)&#123; TreeNode node=stack.pop(); list.add(node.val); if(node.right!=null)&#123; stack.push(node.right); &#125; if(node.left!=null)&#123; stack.push(node.left); &#125; &#125; return list;&#125; 递归解法 12345678910111213ArrayList&lt;Integer&gt; preOrder(TreeNode root)&#123; ArrayList&lt;Integer&gt; result =new ArrayList&lt;Integer&gt;(); preOrder2(root,result); return result;&#125;void preOrder2(TreeNode root,ArrayList&lt;Integer&gt; result)&#123; if(root==null)&#123; return; &#125; result.add(root.val); preOrder2(root.left,result); preOrder2(root.right,result);&#125; 10.二叉树中的中序遍历 12345678910111213141516ArrayList&lt;Integer&gt; inOrder(TreeNode root)&#123; Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); TreeNode current=root; while(current！=null||!stack.empty())&#123; while(current!=null)&#123; stack.add(current); current=current.left; &#125; current=stack.peek(); stack.pop(); list.add(current.val); current=current.right; &#125; return list;&#125; 11.二叉树的后序遍历 12345678910ArrayList&lt;Integer&gt; postOrder(TreeNode root)&#123; ArrayList&lt;Integer&gt; list=new ArrayList&gt;(Integer); if(root==null)&#123; return list; &#125; list.addAll(posrOrder(root.left)); list.addAll(posrOrder(root.right); list.add(root.val); return list;&#125;]]></content>
      <categories>
        <category>算法应用</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中常用的注解总结]]></title>
    <url>%2F2018%2Fcjr7r6l910006fknuynf4p4p0%2F</url>
    <content type="text"><![CDATA[注解就是源代码的元数据。 1.声明bean的注解 @Conponent组件，当组件不好归类的时候，我们可以使用这个注解进行标注 @Service在业务逻辑层使用（service层） @Reponsitory在数据访问层使用（dao层） @Controller在展现层使用，控制器的声明，用来创建处理http请求的对象（Controller层） 1234567@Controllerpublic class TestController&#123; @RequestMapping(&quot;/test&quot;) public String test（String string）｛ return &quot;hello&quot;;｝&#125; 2.注入bean的注解 @Autowired：由Spring提供，可以用在字段上，或者方法上。默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired（required=false） @Resource：作用相当于@Autowired，只不过@Autowired按byName自动注入，而@Resource默认按byName自动注入。 都可以注解在set方法和属性上 3.java配置类相关注解 @Configuration声明当前类为配置类，相当于xml形式的Spring配置（类上） @Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上） @Component注解，表明这个类是一个bean（类上） 4.切面（AOP）相关注解 Spring支持AspectJ的注解式切面编程 @Aspect声明一个切面（类上） 使用@After、@Before、@Around定义advice，可直接将拦截规则（切点）作为参数 @After 在方法执行之后执行（方法上） @Before 在方法执行之前执行（方法上） @Around 在方法执行之前与之后执行（方法上） @PointCut声明切点 5.@Bean的属性支持 @Scope用来配置 spring bean 的作用域，它标识 bean 的作用域。 其设置的类型包括： Singleton：单例，一个Spring容器中只有一个bean实例，默认模式 Protetype：每次调用新建一个bean Request：web项目中，给每个http request新建一个bean Session：web项目中，给每个http session新建一个bean GlobalSession：给每一个global http session 新建一个Bean实例 6.@Value注解 @Value为属性注入值（属性上） 普通字符注入： @Value（”lisa”） String name 注入文件资源： @Value（”classpath:com/file/test.txt”）String source file 注入配置文件： @Value(“${book.name}”)Sring bookName 7.SpringMVC相关注解 @Controller：声明该类为SpringMVC中的Controller @RequestMapping：用于映射Web请求，包括访问路径和参数（类或方法上） 具体的在类定义处：提供初步的请求映射信息，相对于WEB应用的根目录。 方法处：提供进一步的戏份映射信息，相对于类定义处的URL。 @RequestParam：用于将请求参数区数据映射到功能处理方法的参数上。 123public class test(@RequestParam Integer id)&#123; return mailService.fetch(id);&#125; 这个id就是要接收从接口传递过来的参数id的值的，如果接口传递过来的参数名和你接收的不一致，也可以如下 : 123public class test(@RequestParam(value=&quot;user_id&quot;) Integer id)&#123; return mailService.fetch(id)&#125; 其中user_id就是接口传递的参数，id就是映射user_id的参数名 @ResponseBody：支持将返回值放在response内，而不是一个页面，通常用户返回json数据 注意：Spring4之后加的注解@RestController。原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController代替@Controller就不需要再配置@ResponseBody，默认返回json格式。 123456@RestControllerpublic class TestController&#123; @RequestMapping(&quot;/test&quot;) public String test（String string）｛ return &quot;hello&quot;;｝ } @RequestBody：允许request的参数在request体中，而不是在直接连接在地址后面 @ModelAttribute：让全局的@RequestMapping都能获得在此设置的键值对 以上是我在学习中常见的和常用的java注解。]]></content>
      <categories>
        <category>开发注解应用</category>
      </categories>
      <tags>
        <tag>注解应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间典当厅项目之增加功能和上传]]></title>
    <url>%2F2018%2Fcjr7r6l9p000ofknunaxgk4vp%2F</url>
    <content type="text"><![CDATA[在项目之上添加用户排序功能，上传到服务器。 增加排序功能：1.分别在dao，service，controller三层实现相应的后台代码。 ​ dao层 1234public List&lt;InfoUser&gt; userSort() &#123; String sql = &quot;select * from t_user ORDER by goldCoins desc &quot;; return this.jdbcTemplate.query(sql, new InfoUser()); &#125; ​ service层 123public List&lt;InfoUser&gt; userSort() &#123; return this.userDao.userSort();&#125; controller层 1234567891011@ResponseBody@RequestMapping(&#123;&quot;userSort&quot;&#125;)@ApiOperation( value = &quot;get user sort&quot;, httpMethod = &quot;GET&quot;, response = Result.class, nickname = &quot;ALISURE&quot;)public Result getUserSort() &#123; return new Result(this.userService.userSort());&#125; 2.在idea里面调试，访问https://localhost:8081/ddh/user/soetUser 本地测试正确。 3.上传服务器 ​ （1）打开Xshell，输入项目名称和密码，连接到项目服务器。 ​ （2）打开Xftp，连接成功。在路径下找到后台代码 ​ （3）上传修改之后的新代码。服务器中的后台代码都是以.class结尾，编译之后的文件，不能直接修改。 ​ 应该先下载要修改的文件，在IDEA里面打开，修改要添加的代码，修改之后在IDEA里面进行单个文件的编译。找到编译之后的class文件（项目编译之后的class一般存储在项目下的target文件夹里面），直接拖进Xftp进行上传。 ​ 注意：编译项目里面的某个单个文件时直接在IDEA里面编辑，不要再cmd命令框里面编译，因为cmd默认实在当前目录查找class文件，会报找不到依赖包的错误。 ​ 4.把项目上传服务器成功之后，重新启动tomcat.即可通过网址http://timeseller.fantasy512.cn/ddh/user/soetUser 即可获取到用户数据，然后将获取到的用户数据和接口user/sortUser一并传给前端，实现前后端的交互。 ​5.确保无误的代码即可上传到github上保存完整的代码。 补充：重启服务器的tomcat （1）首先，进入tomcat下的bin目录 1cd usr/tomcat/bin （2）使用tomcat关闭命令 1./shutdown.sh （3）查看tomcat是否已经关闭 1ps -ef|grep java ​ 如果显示以下相似信息，说明tomcat还没有关闭 123456789root 7010 1 0 Apr19 ? 00:30:13 /usr/local/java/bin/java-Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties-Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms1024m -Xmx1024m-XX:NewSize=256m -XX:MaxNewSize=256m -XX:PermSize=256m -XX:MaxPermSize=256m-XX:+DisableExplicitGC -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager-Djava.endorsed.dirs=/usr/local/tomcat/endorsed -classpath /usr/local/tomcat/bin/bootstrap.jar-Dcatalina.base=/usr/local/tomcat -Dcatalina.home=/usr/local/tomcat-Djava.io.tmpdir=/usr/local/tomcat/temp org.apache.catalina.startup.Bootstrap start （4）如果直接想杀死tomcat进程（进程号7010），可以使用kill命令 1kill -9 7010 （5）继续查看tomcat是否已经关闭 1ps -ef|grep java 如果出现以下信息，则表示tomcat已经关闭 1root 7010 1 0 Apr19 ? 00:30:30 [java] &lt;defunct&gt; （6）最后，启动tomcat./startup.sh]]></content>
      <categories>
        <category>代码上传服务器 </category>
      </categories>
      <tags>
        <tag>代码上传服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架总结]]></title>
    <url>%2F2018%2Fcjr7r6l8z0005fknu6dv0ml1t%2F</url>
    <content type="text"><![CDATA[对于java程序员，Spring是做多使用，也必须掌握的框架之一。Spring是一站式的开源框架解决方案。 1.Spring的核心：AOP 、IOC（1）AOP：面向切面编程，扩展功能不是修改源代码实现。 （2）IOC：控制反转。IOC操作时把对象的创建交给Springl进行管理，IOC 操作包括IOC的配置文件文件方式和IOC的注解方式。 2.Spring的bean管理（xml方式）（1）bean实例化的方式 1）在Spring里面通过配置文件创建对象 2）bean实例化的三种方式 ①：使用类的无参数构造创建 注意：这样的前提是该类存在无参数的构造方法，如果类里面没有参数的构造，会出现异常：No default constructor found； ②：使用静态工厂创建，创建静态的方法，返回类对象。 12345public class Bean1Factory&#123; public static Bean1 getBean1( )&#123; return new Bean1( ); &#125; &#125; 1&lt;bean id=&quot;bean1&quot; class=&quot;cn.xidiaa.bean.Bean1Factory&quot; factory-method=&quot;&quot;getBean1&gt;&lt;/bean&gt; ③：使用实例工厂创建 ，创建不是静态的方法，返回类对象。 12345public class Bean2Factory&#123; public Bean2 getBean2( )&#123; return new Bean2( ); &#125; &#125; (2) Bean标签常用属性 1）id属性：起名称，id属性值名称任意命名。 ? id属性值，不能包含特殊符号。根据id值得到配置对象。 2）class属性：创建对象所在类的全路径。 3）name属性：功能和id属性是一样的，id属性值不能包含特殊符号，但是在name属性值里面可以包含特殊符号。 4）scope属性 1234-singleton：默认值，单例 scope=“singleton” cn.xidiaa.ioc.User@1be3a66 cn.xidiaa.ioc.User@1be3a66-prototype:多例 cn.xidiaa.ioc.User@e90eef cn.xidiaa.ioc.User@d381e4 （3）属性注入介绍 1）创建对象的时候，像类里面属性里面设置值。 2）属性注入的方式介绍（三种方式） ​ 三种方式包括：使用set方法注入，有参数构造注入，使用接口注入。 在Spring框架里面，支持前两种方式： ①：使用有参数构造注入属性。 123&lt;bean id=&quot;demo&quot; class=&quot;cn.xidiaa.property.PropertyDemo1&quot;&gt; &lt;constructor-arg name=&quot;username&quot; value=&quot;jery&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 1234567private String username; public PropertyDemo(String username)&#123; this.username=username; &#125; public void test1()&#123; System.out.println(&quot;demo......&quot;+username); &#125; ②：使用set方法注入属性 1234private String bookname; public void setBookname(String bookname)&#123; this.bookname=bookname; &#125; 123&lt;bean id=&quot;book&quot; class=&quot;cn.xidiaa.property.Book&quot;&gt; &lt;property name=&quot;bookname&quot; value=&quot;方漫图&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 3）注入对象类型属性：xml方式 ①：创建service类和dao类 在service得到dao对象 ②：具体实现过程 在service里面把dao作为类型属性，生成dao类型属性的set方法。 123456public class UserService &#123; private UserDao userDao; public void setUserDao(UserDao uesrDao)&#123; this.userDao=userDao; &#125; &#125; ③：配置文件中注入关系 1234&lt;bean id=&quot;userDao&quot; class=&quot;cn.xidiaa.ioc.UserDao&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;userDao&quot; class=&quot;cn.xidiaa.ioc.UserService&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 4)基于注解方式的bean创建以及注入 因为Spring注解的实现是需要AOP的支持，因此在依赖方面需要注意，其次，要在XML中开启注解扫描： &lt;context:component-scan base-package=&quot;&quot; /&gt; 实际上这个配置，会让Spring在指定包下扫描，把带有注解标志的bean实例化，并且会进行属性注入。 创建对象的4个注解： @Component/@Controller/@Service/@Repository在这4个注解上，通过value属性来指定bean的id，通过@scope配合来声明单例OR多例。 注入属性： @Autowired/@Resource/@Qualifier 注意：@Resource是javax包下的，就是J2EE提供的；而@Autowired是Spring提供的。（不必提供setter方法） @Resource默认按照名称注入，如果找不到才按照类型注入。 @Autowired默认按照类型注入，可以结合@Qualifier进行名称注入。 注意：如果@Autowired进行类型注入，很可能类型会有多个满足（多态），那么到底注入哪个呢？所以说，如果按照@Autowired类型注入，一定注意结合@Qualifier。实际开发中，显然，注入应该是确定的，那么按照名称注入，应该是首选！ 3.Spring事务管理Spring的声明式事务管理，用的最多的就是基于注解的方式。首先我们得配置一个事务管理器，而事务管理器需要我们注入DataSource。 123&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;tx:annotation-driven/&gt; 对于多个数据源，需要定义多个事务管理器，同时也得开启事务注解。过个事务管理器，可以通过Qualifier属性进行区分。 配置完毕后，直接在service层的类或者方法上，使用@Transactional(value = “gcs”, rollbackFor = Exception.class) 4.Spring整合web项目原理?1）加载Spring核心配置文件 1ApplicationContext context=new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); new对象，功能可以实现，效率很低。 2）实现思想：把加载配置文件和创建对象过程，在服务器启动时候完成。 3）实现原理： ①：ServletContext对象 ②：监听器 ③：具体使用 ——在服务器启动的时候，为每个项目创建一个ServletContext对象 ——在ServletContext对象创建的时候，使用监听器可以具体到ServletContext对象在什么时候创建 ——使用监听器听到ServletContext对象创建的时候，加载spring配置文件，把配置文件配置对象创建 ——把创建出来的对象放到ServletContext域对象里面（setAttribute方法） ——获取对象的时候，到ServletContext域里面得到（getAttribute方法） 5.补充（1）.IOC和DI区别 1）IOC: 控制反转，把对象创建交给spring进行配置 2）DI: 依赖注入，向类里面的属性中设置值 3）关系：依赖注入不能单独存在，需要在ioc基础之上完成操作 （2）.关于AOP的几个重点概念： 1）AOP的实现，一种横向抽取机制，依赖于动态代理模式。 2）JoinPoint：连接点，说白了，就是可以被增强的方法； 3）PointCut：切入点，对哪些JoinPoint进行拦截； 4）Advice：通知，就是拦截后的动作； 5）Aspect：切面，把增强应用到具体方法的过程； Spring的AOP需要借助aspectj来实现，可以通过XML，也可以通过注解来完成。 比如，采用XML方式的话，需要指明用A类的哪个方法对B类的哪些方法上进行增强，这里就涉及到execution表达式了； 比如，采用注解方式的话，就更加简单了，先在XML中开启AOP（&lt;aop:aspectj-autoproxy /&gt;），然后在增强方法上直接使用类似@Before(value=”execution(具体的表达式)”)就可以了；其实在实际开发中，我们对于AOP最常用的就是事务了。]]></content>
      <categories>
        <category>Spring框架 </category>
      </categories>
      <tags>
        <tag>相关技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小顽童项目准备]]></title>
    <url>%2F2018%2Fcjr7r6l9r000sfknurehv52k0%2F</url>
    <content type="text"><![CDATA[基于前期的学习，为了进一步用以实践，我们准备开发一个小网站—–小顽童。 涉及到：1.前端 2.后台 3.移动端 网站的内容： 1.板块（论坛，可以参考西电睿思），具体主题未定，大家均可以提出意见，然后进行业务开发。 2.工具，提供常用查询，如天气查询，列车时刻查询，远程查询 ，IP详情，电话详情，遥控等等。 3.自定义模块 涉及到的技术： 工具：IDEA,maven,git(github),wiki 容器：tomcat7及以上，推荐9 前端：html+css+js(Ajax) 前端框架：vue.js 后台：jsp/servlet 框架：spring/springmvc/mybatis 移动端：推荐webApp 数据库：mysql 美工：ps,图标尽量在阿里巴巴矢量图标库下载，美图秀秀也可以。 本次项目分工明确：我作为项目参与者，主要负责后台开发。 一.首先，安装开发工具IDEAIDEA的安装以及破解步骤： 1.从睿思或者官网下载最新的IDEA软件到本地。 2.双击安装，选择合适的下载路径。 3.安装完毕后，先不要打开。 4.开始破解： 5.首先更改hosts文件。（位置：C:\Windows\System32\drives\etc）。 6.使用文本编译器打开hosts 在最后一行添加：0.0.0.0 account.jetbrains.com!1540689850659] 7.打开运行idea，会提示让你注册，有三种方式，下面就是注册码，copy进去确认即可。 K71U8DBPNE-eyJsaWNlbnNlSWQiOiJLNzFVOERCUE5FIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifV0sImhhc2giOiI4OTA4Mjg5LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-Owt3/+LdCpedvF0eQ8635yYt0+ZLtCfIHOKzSrx5hBtbKGYRPFDrdgQAK6lJjexl2emLBcUq729K1+ukY9Js0nx1NH09l9Rw4c7k9wUksLl6RWx7Hcdcma1AHolfSp79NynSMZzQQLFohNyjD+dXfXM5GYd2OTHya0zYjTNMmAJuuRsapJMP9F1z7UTpMpLMxS/JaCWdyX6qIs+funJdPF7bjzYAQBvtbz+6SANBgN36gG1B2xHhccTn6WE8vagwwSNuM70egpahcTktoHxI7uS1JGN9gKAr6nbp+8DbFz3a2wd+XoF3nSJb/d2f/6zJR8yJF8AOyb30kwg3zf5cWw==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog== 二.安装git，这里默认都是Windows系统。1.登陆git官网，下载windows版的进行安装，选择安装路径，其他均选择默认配置。 2.安装成功后，验证是否成功（打开git bash，输入git–version）。 3.检查用户名和邮箱是否配置（git config –global –list） 4.如果没有，进行配置。 设置用户名：git config –global user.name “xxx” 设置邮箱：git config –global user.email “xxxxx” 5.生成ssh-key（ssh-keygen -t rsa -C “你的email”） 整个过程一直回车，有需要yes/no,就yes。最后会生成一份ssh私钥和一份公钥。 6.打开公钥位置，发给项目管理人。 三.申请github账号申请成功后，将用户名一并发给项目管理人。 四.用码云进行一个简单的前后端测试1.进入：http://gitee.com/ 搜索到urchin_board，然后进行fork。 2.切换到alpha分支上面，创建一个txt文件，进行PR操作，则成功进入到项目组织里面。 五.安装tomcat9 安装方式：http://tomcat.apache.org/ 六.安装maven安装教程为：https://blog.csdn.net/t_1025/article/details/70148793 中央仓库建议用阿里巴巴，这样速度更快一些 七.在idea上进行git操作1.File-setting-Gitee，点击Install。 2.安装成功后，进行如下操作。 ​ crtl+alt+s到界面：Version Control-Gitee-Creat API Token-输入码云的账号和密码-Test 3.接下来用git拉取项目 (1)File–New–Project from Version Control–Git (2)复制仓库时：要求输入URL和Directory。 4，在码云中，切换到alpha，点击克隆/下载，复制链接到URL，进行克隆，克隆成功后就可以看到新建的文件了。 注意：当遇到URL没有错误，但克隆失败时，检查是否已经添加了ssh-key，如果没有则先进行添加之后再克隆代码。 5.点击同步之后，检查idea页面最下方是否存在Terminal和Git：master。 6.创建分支 git checkout -b “分支名-alpha” 创建成功之后，右下角出现分支名–Git：minminminzhang。 八.接下来进行项目的同步操作。1.编写pom.xml,一人编写，其他人同步即可。编写完成之后，进行pull操作。 pull操作可以用git命令： git stash git pull origin master git stash pop 还有一种就是：右击项目-Git-Repository-Pull，始终选择origin/alpha. 就可以看到pom.xml进行更新了，更新完成之后有290行代码。 2.整合SSM框架 https://www.cnblogs.com/hackyo/p/6646051.html 九.运行项目1，重新登录码云，有可能过期了。 Alt+Ctrl+s–Gitee–Create API Token–Test 2，再配置一下tomcat服务器 (1)点击项目urchin右边的倒三角Edit Configurations (2)在Run/Debug Configurations页面：点击最上面的“+”号–Maven–选择项目urchin–在Command ling行选择tomact：run，应用保存。 3，测试，运行 在index.jsp页面简单的写一个程序。 1234567891011121314&lt;html&gt;&lt;head&gt; &lt;style&gt; p&#123; font-size: 50px; color:aquamarine; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2 &lt;p&gt;小顽童项目开始了&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 点击运行： 下方出现一行[INFO] Running war on http://localhost:9091/urchin 即访问此网址就可以看到运行结果。 以上准备工作完成之后，我们就可以进行项目的设计开发了。]]></content>
      <categories>
        <category>相关技术</category>
      </categories>
      <tags>
        <tag>相关技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中常用设计模式的使用方法与区别]]></title>
    <url>%2F2018%2Fcjr7r6ljj001qfknubfrgi1kh%2F</url>
    <content type="text"><![CDATA[设计模式其实就是一套被反复使用的代码设计经验的总结。 使用设计模式的优点就是：代码可以重用，更容易被他人理解，保证代码的可靠性。 Java中的设计模式以供有23种，包括：Abstract Factory（抽象工厂模式），Builder（建造者模式），Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）；Facade（门面模式），Adapter（适配器模式），Bridge（桥梁模式），Composite（合成模式），Decorator（装饰模式），Flyweight（享元模式），Proxy（代理模式）；Command（命令模式），Interpreter（解释器模式），Visitor（访问者模式），Iterator（迭代子模式），Mediator（调停者模式），Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibility（责任链模式）。 一、简单工厂模式​ 我们在实例化对象的时候通常用new关键字，但是有了工厂，我们在声明对象的时候就可以用到工厂了，使得代码更加灵活。是由一个工厂对象决定创建出哪一种产品类的实例。 1234//抽象产品public abstract class Car&#123; public abstract void Driver( );&#125; 123456//具体产品public class BenC&#123; public void Driver( )&#123; Console.WriteLine(&quot;奔驰&quot;); &#125;&#125; 1234567//具体产品public class BaoM&#123; public void Driver( )&#123; Console.WriteLine(&quot;宝马&quot;); &#125;&#125; 123456789101112//简单工厂public class Driver( )&#123; public static Car DriverCar (string carName)&#123; Car car; if(carName)==&quot;奔驰&quot;)&#123; car=new BenC( ); &#125; else&#123; car=new BaoM( ); &#125;&#125; 1234567//客户代码public class Boss&#123; Car car1=Driver.DriverCar(&quot;奔驰&quot;); car1.Driver(); Car car2=Driver.DriverCar(&quot;宝马&quot;); car2.Driver();&#125; 优点： （1）简单工厂包含必要的判断逻辑，实现了对象的创建和使用的分离。 （2）客户端无需知道所创建的具体产品类的类名，只需要具体产品类对应的参数即可。 （3）在不修改客户端代码的情况下更换和增加具体产品类，提高了系统的灵活性。 缺点： 当产品修改时，工厂类也需要做相应的修改，违反了开—闭原则。 简单工厂模式适用于业务简单或者具体产品很少增加的情况。而对于复杂的业务环境不太适应。因此提出工厂方法模式。 二、工厂方法模式：​ 工厂方法模式是简单工厂的进一步延伸，这样说是因为简单工厂违反了开—闭原则，而工厂方法可以完美的解决这个问题。工厂方法不在工厂类中进行逻辑判断，程序可以为不同产品类提供不同的工厂。当使用工厂方法设计模式时，对象调用者需要与具体的工厂类耦合。 ​ 工厂方法模式的各个角色： ​ 抽象工厂角色：工厂方法模式的核心，它与应用程序无关。是具体工厂必须实现的接口或者必须继承的父类他由抽象类或者接口来实现。 ​ 具体工厂角色：它含有和具体逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 ​ 抽象产品角色：他是具体产品继承的父类或者是实现的接口。一般由抽象类或者接口来实现。 ​ 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。由具体类实现。 1234//抽象产品public abstract class Car&#123; public abstract void Driver( );&#125; 123456//具体产品public class BenC&#123; public void Driver( )&#123; Console.WriteLine(&quot;奔驰&quot;); &#125;&#125; 1234567//具体产品public class BaoM&#123; public void Driver( )&#123; Console.WriteLine(&quot;宝马&quot;); &#125;&#125; 1234//抽象工厂public abstract class Driver&#123; public abstract Car DriverCar();&#125; 123456//具体工厂public class DriverBenC( )&#123; public Car DriverCar () Car car=new BenC( ); return car; &#125; 123456//具体工厂public class DriverBaoM( )&#123; public Car DriverCar () Car car=new BaoM( ); return car; &#125; 123456//客户代码public class Boss&#123;Driver d=new DriverBenC( ); Car car=d.DriverCar( ); car.Driver(); &#125; 优点： （1）工厂方法用来创建客户所需要的产品，同时隐藏了哪种产品具体类将被实例化的细节，用户只需要关注工厂，不需要关注创建的细节。 （2）当产品增加时，只需要增加对应的工厂就好，完全符合开放封闭性原则。 缺点： 抽象层的加入使得理解程度加大。 三、抽象工厂模式：抽象工厂模式与工厂方法模式的区别就在于需要创建对象的复杂程度上。抽象工厂模式是三个里面最为抽象，最具有一般性的。用意在于给客户端提供一个接口，可以创建多个产品中的产品对象。 使用抽象工厂模式还要满足以下条件： （1）系统中有多个产品族，而系统一次只可能消费其中一族产品。 （2）同属于同属于同一产品族的产品一起使用。 1234//抽象产品public abstract class BenC&#123; public abstract void Driver( );&#125; 123456//具体产品public class BenCSportCar&#123; public void Driver( )&#123; Console.WriteLine(&quot;奔驰&quot;); &#125;&#125; 123456//具体产品public class BenCBusinessCar&#123; public void Driver( )&#123; Console.WriteLine(&quot;奔驰&quot;); &#125;&#125; 1234//抽象产品public abstract class BaoM&#123; public abstract void Driver( );&#125; 123456//具体产品public class BaoMSportCar&#123; public void Driver( )&#123; Console.WriteLine(&quot;宝马&quot;); &#125;&#125; 123456//具体产品public class BaoM&#123;SportCar&#123; public void Driver( )&#123; Console.WriteLine(&quot;宝马&quot;); &#125;&#125; 12345//抽象工厂public abstract class Driver&#123; public abstract BenCCar DriverBenCCar(); public abstract BaoMCar DriverBenCCar();&#125; 1234567891011//具体工厂public class SportDriver( )&#123; public BenCCar DriverBenCCar()&#123; BenCSportCar bencSport=new BenCSportCar(); return bencSport; &#125; public BaoMCar DriverBaoMCar()&#123; BaoMSportCar baomSport=new BaoMSportCar(); return baomSport; &#125;&#125; 1234567891011//具体工厂public class BusinessDriver( )&#123; public BenCCar DriverBenCCar()&#123; BenCSportCar bencSport=new BenCSportCar(); return bencSport; &#125; public BaoMCar DriverBaoMCar()&#123; BaoMSportCar baomSport=new BaoMSportCar(); return baomSport; &#125;&#125; 123456//客户代码public class Boss&#123;Driver d=new DriverBenC( ); Car car=d.DriverCar( ); car.Driver(); &#125; 从上可以发现，增加一个产品族很简单，而增加一个新的产品会很复杂。抽象工厂模式一般用于具有产品树和产品族的场景下。 补充： 1.单例模式，一个类只有一个实例存在。存在两种不同形式的单例： 第一种形式：饿汉式单例 123456789public class Singleton&#123; private Singleton()&#123; &#125; //在内部定义一个实例，private，只供内部使用。 private static Singleton instance =new Singleton(); //提供了一个供外部访问本class的静态方法，可以直接访问。 public static Singleton getInstance()&#123; return instance; &#125;&#125; 第二种：懒汉式单例 12345678910public class Singleton&#123; private static Singleton instace=null; private Singleton()&#123;&#125; public static synchronized Singleton getInstance()&#123; //比上面的方法有所改进，不用每次都进行声称对象，只是第一次使用时生成实例，提高了效率! if(instance==null) instance =newSingleton(); return instance; &#125;&#125; 单例的特点：外界无法通过构造器来创建对象，该类必须提供一个静态方法向外界提供该类的唯一实例。 2.在开发中常用的设计模式 （1）工厂模式：工厂类可以根据条件生成不同的子类对象，这些子类有一个公共的抽象父类并且实现的相同的方法，但这些方法针对不同的数据进行了不同的操作。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 （2）代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可分为：远程代理、虚拟代理、保护代理、Cache 代理、防火墙代理、同步化代理、智能引用代理。 （3）适配器模式：把一个类的接口变成客户所期待的另一种接口，从而使原本因接口不匹配而无法一起使用的类能够一起工作。 （4）模板方式模式：提供一个抽象类，将部分逻辑以具体方式或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于RESTful的理解]]></title>
    <url>%2F2018%2Fcjr7r6l8h0000fknu8xg5vcgg%2F</url>
    <content type="text"><![CDATA[了解RESTful的起因学习springmvc的时候，在配置前端控制器中时有三种方式： 第一种：*.action，访问一、以.action结尾由DispatcherServlet进行解析。 第二种：/，所有访问的地址由DispatcherServlet进行解析，对于静态文件的解析需要配置不让DispatcherServlet进行解析，使用此种方法可以实现RESTful风格的url。 第三种：/*，这样配置不对使用此种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错。 由此了解到Resultful架构。 RESTful的介绍RESTful架构，就是目前最流行的一种互联网软件架构。具有结构清晰，符合标准，易于理解，扩展方便的优点。 RESTful的起源Roy Thomas Fielding 在2000年的博士论文提出来的。他在文中写到：“长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观评估不同的设计选择对系统行为的影响。而相反的，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽略的一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我写这篇问猴子那个的目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、事宜通信的架构。” Roy Thomas Fielding 将他对互联网软件的架构原则，命名为REST，，即Representational State Transfer的缩写。可翻译 为“表现层状态转化”。要理解RESTful的架构，最好的方法就是去理解Representational State Transfer词组的意思。 资源REST翻译为“表现层状态转化”，省略的主语，“表现层”其实指的是“资源”的“表现层”。 “资源”就是网络上的一个实体，或者说就是网络上的一个具体信息。可以是一短文本、一张图片、一首歌曲，总之就是一个具体的存在实体。可以用一个URI访问它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以。上网就是与互联网上一系列的“资源”互动，调用它的URI。 表现层“资源”是一种信息实体，它可以有多种外在表现形式。我们把“资源”具体呈现出来的形式，叫做它的“表现层”。 比如：文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JSP格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格的说，有些网址最后的“.html”后缀名是不必要的，因为这个后缀名表示格式，属于“表现层”范围，而URL只代表“资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Context-Type字段指定，这两个字段才是对“表现层”的描述。 状态转换访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，涉及到数据和状态的变化。 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器发生“状态转换”。而这种转换你是建立在表现层之上的，所以就是“表现层状态转换”。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表现操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种操作：GET用来获取资源，POST用来新建资源（也可用来更新资源），PUT用来更新资源，DELETE用来删除资源。 总结综合以上学习，总结RESTful架构： （1）每一个URI代表一种资源 （2）客户端和服务器之间，传递这种资源的表现层。 （3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现“表现层状态转换”。 常见错误（1）URI不能包含动词 ​ 因为“资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。 例如：网上汇款，从账户1向账户2汇款200元 ​ POST /accounts/1/transfer/200/to/2/ 正确的写法应该是：POST /transaction HTTP/1.1 ​ Host: 127.0.0.1 ​ from=1&amp;to=2&amp;account=200.00 （2）在URI中不能加入版本号 ​ http://www.example.com/app/1.0/foo ​ http://www.example.com/app/1.1/foo ​ http://www.example.com/app/2.0/foo 不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头的Accept字段中进行区分 Accept: vnd.example-com.foo+json; version=1.0 Accept: vnd.example-com.foo+json; version=1.1 Accept: vnd.example-com.foo+json; version=2.0]]></content>
      <categories>
        <category>RESTful架构</category>
      </categories>
      <tags>
        <tag>RESTful架构和URI资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2018%2Fcjr7r6ljs001wfknut19ob0ca%2F</url>
    <content type="text"><![CDATA[​ 对于一个认真的程序员，在学习过程中总要写Blog来记录学习过程中的点点滴滴。踩过的坑终将变成成功道路上的跳板。 Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown解析文章，在几秒内，即可利用靓丽的主题生成静态网页。经过搜索资料，不断学习，请教别人，最终搭建好了我的个人博客框架，在此写下整个过程分享。博文包括三个部分：构建基本框架、不断优化、补充内容。 ​ 构建基本框架：从最简单的相关软件介绍到搭建完成属于自己的独立博客。不断优化：在完成简单的搭建之后，不断美化自己的页面展示。补充内容包括了Hexo的语法以及。。。。。。。 构建基本框架： 基础准备：&nbsp; &nbsp; &nbsp; &nbsp;安装Git&nbsp; &nbsp; &nbsp; &nbsp;将本地的Hexo提交到GitHub上进行管理&nbsp; &nbsp; &nbsp; &nbsp;安装步骤：&nbsp; &nbsp; &nbsp; &nbsp;1.在Git官网上(https://git-scm.com/download/win) 下载Windows版本。&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;2.下载完成后，双击.msi文件安装至G:\blogresoft\git。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 安装NodeJs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hexo是基于NodeJs环境的静态博客，里面的npm工具很有用。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装步骤：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.在Node.js官网(https://nodejs.org/en) 下载最新版本。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.点击最新64位的8.11.4LTS版本下载到G盘新建的blogresoft文件夹下。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3：双击.msi文件安装，不断点击next即可安装成功至G:\blogresoft\nodejs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GitHub账号&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 没有GitHub账号的情况下,在官网页面注册一个新的即可。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 配置SSH Keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 配置SSH Keys 之后,每次对自己的博客改动之后，提交的时候,不再需要重新输入GitHub的账号的密码了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置步骤:在 G:\blogresoft\git文件夹下点击git-bash.exe，输入以下命令检查.ssh文件是否已经存在： 1$ ls -al ~/.ssh 不存在会出现提示： ls: cannot access ‘/c/User/Administrator/ .ssh’:No such file or directory 接着执行如下代码，生成.ssh文件夹： 1$ mkdir .ssh 进入.ssh文件夹： 1$ cd .ssh 输入如下代码： 123$ ssh-keygen -t rsa -C&quot;GitHub登陆邮箱&quot;$ id_rsa 按回车键，提示是否使用长密码，按回车，继续按回车，不使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将ssh公钥部分添加到GitHub，.ssh文件夹下后缀名为.pub的文件是公钥，右键打开方式选择写字板打开，复制其中所有的内容。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在GitHub网站右上角点击setting。点击左侧SSH and GPG keys，点击右上角New SSH key，在Key中粘贴.ssh文件夹下后缀名为.pub的文件的所有内容，点击Add SSH key添加公钥，此时公钥状态为黑色。 在G:\blogresoft\git文件夹下双击git-bash.exe，输入以下命令： 123$ git config --global user.name &quot;usename&quot;$ git config --global user.email &quot;email&quot; 其中usename为注册GitHub时的账户名，email为注册GitHub时的邮箱。 输入如下命令，测试SSH是否配置成功： 1$ ssh -T git@github.com 出现提示，输入yes回车，出现欢迎提示: Hi minminminzhang! Your’ve successfully authenticated,but GitHub does not provide shell access. 此时回到SSH and GPG keys处，公钥状态变为绿色。 新建仓库​ 在Git上新建一个仓库 在GitHub上新建一个仓库，并取名为your_username.github.io，其中your_username是您自己的GitHub账号名。 在本地写博客 在G:/blogresoft/git文件夹下新建一个index.html文件，并输入一下内容： 12345678&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;你好！这是我的第一篇博客&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 用Git把index.html提交到GitHub上，在cmd中输入以下命令： 123456789$ git init $ git add index.html $ git commit -m &quot;我的第一篇博客&quot;$ git remote add originhttps://github.com/your_username/your_username.github$ git push -u origin master 在浏览器中输入your_username.github.io即可访问文件。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 hexo安装配置：*下载Hexo 下载官网： http://hexo.io github: https://github.com/hexojs/hexo 在G:/blogresoft/git文件夹下双击git-bash.exe 输入以下命令进行安装Hexo 1$ npm install -g hexo 在G:/blogresoft/git下安装文件夹hexo，并切换至Hexo工作目录 1$ cd hexo 初始化文件夹 1$ hexo init 安装hexo的扩展插件 1$ npm install 安装其他插件 1234$ npm install hexo-deployer-git -save$ npm install hexo-renderer-ejs -save$ npm install hexo-renderer-stylus -save$ npm install hexo-render-marked -save 生成静态页面 1$ hexo g 开启本地服务器 1$ hexo s 会出现提示： INFO Start processing INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop 此时：访问http://localhost:4000就可以看到刚刚创建的博客了。注意：若是无法访问，说明端口4000被占用了。可以输入如下的命令换端口试一下： 1$ hexo s -p 5000 更换后，访问http://localhost:5000进行查看。 *部署Hexo： 修改配置 修改站点配置文件G:/blogresoft/git/hexo/_config.yml,修改deploy项的内容： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: git@github.com:username/username.github.io.gitbranch: master 注意：1.hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，称为站点配置文件，一个是各个theme下的，称为主题配置文件； 2.type: repo: branch:分别和后面的内容之间有分隔输入下面的命令将Hexo博客部署到GitHub中： 清空静态页面 1$ hexo clean 生成静态页面 123$ hexo g$ npm install hexo -deployer-git -save 部署 1$ hexo d 在完成之后就可以访问https://minminminzhang.github.io,出现Hexo安装成功的页面提示。注意：我在最后一部配置的时候出现了仓库不存在的提示：出现这种错误，有两种原因： 1.修改站点文件时：仓库名输入有误 2.在部署之前没有执行$ npm install hexo -deployer-git -save还有一种错误的情况由G:/blogresoft/git/hexo下的.deploy_git隐藏文件所致,删除这个隐藏文件即可。完成之后进行重新部署： 12345$ hexo clean$ hexo g$ hexo d 重新访问进行验证。 不断优化更换主题 Hexo中G:/blogresoft/git/hexo/themes/landscape默认的主题很简陋，我们可以换成更美观的。本博客选择Next主题，简单美观，好配置。 下载主题： 在Next发布页面(https://github.com/iissnan/hexo-theme-next/releases) 下载最新版本hexo-theme-next-5.1.4。放在G:/blogresoft/git/hexo/themes文件夹下并改名为next。启用主题打开站点配置文件，在theme字段更改如下代码： 1theme： next 主题安装完成，在切换之前，用hexo clean来清除hexo的缓存。 验证主题： 启动Hexo本地站点，并开启调试模式： 1$ hexo s -debug 出现提示：INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop 此时使用浏览器访问http://localhost:4000，检查Next安装是否成功。Next安装成功之后的页面设置参考： https://blog.csdn.net/u012195214/article/details/79204088 写博客：定位到hexo根目录，执行命令： 1$ hexo new &apos;my first-blog&apos; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hexo会帮我们在 G:/blogresoft/git/hexo/source/_posts 下生成相关文件，我们只需要打开这个文件就可以开始写博客了。 当然也可以在G:/blogresoft/git/hexo/source/_posts 直接创建后缀为.md的文件。使用命令的好处是帮我们自动生成了时间。 &nbsp;&nbsp;&nbsp;&nbsp;打开文件，除了在文章开头部分的一些参数，比如标题(title:) 、创建时间(date:) 等，正文部分使用Markdown格式书写: 注意：NexT默认主页显示文章的全部内容，这对于有些很长的文章来说非常不美观，建议主页仅显示文章的摘要。 在合适的位置插入以下内容作为分隔符 1$ &lt;!--is more--&gt; 分隔符以前的内容将会在索引页上显示为摘要。 补充内容： Hexo常用命令： npm install hexo -g #安装npm update hexo -g #更新hexo init #初始化hexo publish [layout] #发表草稿。hexo n “name” #新建文章hexo g #生成静态网页hexo p #发表草稿。 hexo s #启动服务hexo d #部署网站 参数：-g 部署之前先生成静态文件。]]></content>
      <categories>
        <category>搭建个人博客</category>
      </categories>
      <tags>
        <tag>相关技术</tag>
      </tags>
  </entry>
</search>
